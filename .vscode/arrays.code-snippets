{
    "CP Array: Next Permutation (C++ Equivalent)": {
        "scope": "java",
        "prefix": "arrnextperm",
        "body": [
            "    // Generates the next lexicographical permutation. Returns false if it's the last one.",
            "    static boolean nextPermutation(int[] a) {",
            "        int i = a.length - 2;",
            "        while (i >= 0 && a[i] >= a[i + 1]) i--;",
            "        if (i < 0) return false;",
            "        int j = a.length - 1;",
            "        while (a[j] <= a[i]) j--;",
            "        int temp = a[i]; a[i] = a[j]; a[j] = temp;",
            "        for (int l = i + 1, r = a.length - 1; l < r; l++, r--) {",
            "            temp = a[l]; a[l] = a[r]; a[r] = temp;",
            "        }",
            "        return true;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: arrnextperm -> In-place next permutation in O(N). Essential for brute-forcing small constraints."
    },
    "CP Array: Reverse Primitives": {
        "scope": "java",
        "prefix": "arrreverse",
        "body": [
            "    static void reverse(int[] a) {",
            "        for (int i = 0, j = a.length - 1; i < j; i++, j--) {",
            "            int t = a[i]; a[i] = a[j]; a[j] = t;",
            "        }",
            "    }",
            "",
            "    static void reverse(long[] a) {",
            "        for (int i = 0, j = a.length - 1; i < j; i++, j--) {",
            "            long t = a[i]; a[i] = a[j]; a[j] = t;",
            "        }",
            "    }",
            "    $0"
        ],
        "description": "Prefix: arrreverse -> O(N) In-place array reversal (avoids Object boxing overhead)"
    },
    "CP Array: Coordinate Compression": {
        "scope": "java",
        "prefix": "arrcompress",
        "body": [
            "    // Maps sparse large numbers (e.g., 10^9) to dense small numbers (0 to N-1).",
            "    // Crucial for Segment Trees and Fenwick Trees.",
            "    static int[] compress(int[] a) {",
            "        int[] sorted = a.clone();",
            "        Arrays.sort(sorted);",
            "        int m = 0;",
            "        for (int i = 0; i < sorted.length; i++) {",
            "            if (i == 0 || sorted[i] != sorted[i - 1]) sorted[m++] = sorted[i];",
            "        }",
            "        int[] res = new int[a.length];",
            "        for (int i = 0; i < a.length; i++) {",
            "            res[i] = Arrays.binarySearch(sorted, 0, m, a[i]);",
            "        }",
            "        return res;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: arrcompress -> O(N log N) Coordinate compression for massive array values"
    },
    "CP Array: Rotate 2D Grid 90 Degrees": {
        "scope": "java",
        "prefix": "arrrotate",
        "body": [
            "    static int[][] rotate90(int[][] a) {",
            "        int n = a.length, m = a[0].length;",
            "        int[][] res = new int[m][n];",
            "        for (int i = 0; i < n; i++) {",
            "            for (int j = 0; j < m; j++) {",
            "                res[j][n - 1 - i] = a[i][j];",
            "            }",
            "        }",
            "        return res;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: arrrotate -> Rotates an N x M matrix 90 degrees clockwise instantly"
    },
    "CP Array: 1D Prefix & Suffix Sums": {
        "scope": "java",
        "prefix": "arrprefix",
        "body": [
            "    static long[] buildPrefixSum(int[] a) {",
            "        long[] pref = new long[a.length + 1];",
            "        for (int i = 0; i < a.length; i++) pref[i + 1] = pref[i] + a[i];",
            "        return pref;",
            "    }",
            "    ",
            "    // Query sum from index L to R (0-indexed, inclusive)",
            "    static long queryPrefix(long[] pref, int l, int r) {",
            "        return pref[r + 1] - pref[l];",
            "    }",
            "    $0"
        ],
        "description": "Prefix: arrprefix -> O(N) Prefix sum builder and O(1) range query"
    },
    "CP List: Lower Bound (Binary Search)": {
        "scope": "java",
        "prefix": "listlowerbound",
        "body": [
            "    // Returns the first index where list.get(index) >= key",
            "    static int lowerBound(List<Integer> list, int key) {",
            "        int l = 0, r = list.size();",
            "        while (l < r) {",
            "            int mid = l + (r - l) / 2;",
            "            if (list.get(mid) < key) l = mid + 1;",
            "            else r = mid;",
            "        }",
            "        return l;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: listlowerbound -> O(log N) C++ equivalent of std::lower_bound"
    },
    "CP List: Upper Bound (Binary Search)": {
        "scope": "java",
        "prefix": "listupperbound",
        "body": [
            "    // Returns the first index where list.get(index) > key",
            "    static int upperBound(List<Integer> list, int key) {",
            "        int l = 0, r = list.size();",
            "        while (l < r) {",
            "            int mid = l + (r - l) / 2;",
            "            if (list.get(mid) <= key) l = mid + 1;",
            "            else r = mid;",
            "        }",
            "        return l;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: listupperbound -> O(log N) C++ equivalent of std::upper_bound"
    },
    "CP List: Custom Linked List Node & Reversal": {
        "scope": "java",
        "prefix": "listnode",
        "body": [
            "    static class ListNode {",
            "        int val;",
            "        ListNode next;",
            "        ListNode(int val) { this.val = val; }",
            "    }",
            "",
            "    static ListNode reverseList(ListNode head) {",
            "        ListNode prev = null, curr = head;",
            "        while (curr != null) {",
            "            ListNode nextTemp = curr.next;",
            "            curr.next = prev;",
            "            prev = curr;",
            "            curr = nextTemp;",
            "        }",
            "        return prev;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: listnode -> Standard Linked List Node class and O(N) Iterative Reversal"
    },
    "CP Array: Difference Array (Range Addition)": {
        "scope": "java",
        "prefix": "arrdiff",
        "body": [
            "    static class DifferenceArray {",
            "        long[] diff;",
            "        DifferenceArray(int n) {",
            "            diff = new long[n + 2]; // 1-indexed safety",
            "        }",
            "        // Add val to range [l, r] inclusive (0-indexed inputs)",
            "        void add(int l, int r, long val) {",
            "            diff[l] += val;",
            "            diff[r + 1] -= val;",
            "        }",
            "        // Reconstructs the final array after all updates",
            "        long[] getFinalArray(int n) {",
            "            long[] res = new long[n];",
            "            long curr = 0;",
            "            for (int i = 0; i < n; i++) {",
            "                curr += diff[i];",
            "                res[i] = curr;",
            "            }",
            "            return res;",
            "        }",
            "    }",
            "    $0"
        ],
        "description": "Prefix: arrdiff -> O(1) Range Addition Queries. Evaluates in O(N) at the end."
    },
    "CP Array: Next Greater Element (Monotonic Stack)": {
        "scope": "java",
        "prefix": "arrnge",
        "body": [
            "    // Returns an array where res[i] is the INDEX of the next strictly greater element.",
            "    // If no greater element exists to the right, res[i] = -1.",
            "    static int[] nextGreaterElement(int[] a) {",
            "        int n = a.length;",
            "        int[] res = new int[n];",
            "        Arrays.fill(res, -1);",
            "        Deque<Integer> stack = new ArrayDeque<>(); // Stores indices",
            "        for (int i = 0; i < n; i++) {",
            "            while (!stack.isEmpty() && a[stack.peek()] < a[i]) {",
            "                res[stack.pop()] = i;",
            "            }",
            "            stack.push(i);",
            "        }",
            "        return res;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: arrnge -> O(N) Finds index of the Next Greater Element using a stack"
    },
    "CP Array: Lower & Upper Bound (Primitive Arrays)": {
        "scope": "java",
        "prefix": "arrbound",
        "body": [
            "    // Returns the first index where a[idx] >= key (C++ std::lower_bound)",
            "    static int lowerBound(long[] a, long key) {",
            "        int l = 0, r = a.length;",
            "        while (l < r) {",
            "            int mid = l + (r - l) / 2;",
            "            if (a[mid] < key) l = mid + 1;",
            "            else r = mid;",
            "        }",
            "        return l;",
            "    }",
            "",
            "    // Returns the first index where a[idx] > key (C++ std::upper_bound)",
            "    static int upperBound(long[] a, long key) {",
            "        int l = 0, r = a.length;",
            "        while (l < r) {",
            "            int mid = l + (r - l) / 2;",
            "            if (a[mid] <= key) l = mid + 1;",
            "            else r = mid;",
            "        }",
            "        return l;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: arrbound -> O(log N) Strict C++ equivalent binary searches for primitive arrays"
    },
    "CP Array: Sparse Table (O(1) Range Minimum/Maximum Query)": {
        "scope": "java",
        "prefix": "arrsparsetable",
        "body": [
            "    static class SparseTable {",
            "        int[][] st;",
            "        int[] log2;",
            "        ",
            "        // Change Math.min to Math.max, GCD, or Bitwise AND/OR as needed",
            "        SparseTable(int[] a) {",
            "            int n = a.length;",
            "            log2 = new int[n + 1];",
            "            for (int i = 2; i <= n; i++) log2[i] = log2[i / 2] + 1;",
            "            ",
            "            int K = log2[n] + 1;",
            "            st = new int[n][K];",
            "            ",
            "            for (int i = 0; i < n; i++) st[i][0] = a[i];",
            "            ",
            "            for (int j = 1; j < K; j++) {",
            "                for (int i = 0; i + (1 << j) <= n; i++) {",
            "                    st[i][j] = Math.min(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);",
            "                }",
            "            }",
            "        }",
            "        ",
            "        // Queries [L, R] inclusive in strictly O(1) time",
            "        int query(int l, int r) {",
            "            int j = log2[r - l + 1];",
            "            return Math.min(st[l][j], st[r - (1 << j) + 1][j]);",
            "        }",
            "    }",
            "    $0"
        ],
        "description": "Prefix: arrsparsetable -> O(N log N) build, O(1) query. Essential for idempotent operations without updates."
    },
    "CP Array: 2D Difference Array (Matrix Range Addition)": {
        "scope": "java",
        "prefix": "arrdiff2d",
        "body": [
            "    static class DifferenceArray2D {",
            "        long[][] diff;",
            "        int r, c;",
            "        ",
            "        DifferenceArray2D(int r, int c) {",
            "            this.r = r; this.c = c;",
            "            diff = new long[r + 2][c + 2]; // 1-indexed internally for safety",
            "        }",
            "        ",
            "        // Adds val to the submatrix bounded by top-left (r1, c1) and bottom-right (r2, c2). 0-indexed.",
            "        void add(int r1, int c1, int r2, int c2, long val) {",
            "            diff[r1 + 1][c1 + 1] += val;",
            "            diff[r2 + 2][c1 + 1] -= val;",
            "            diff[r1 + 1][c2 + 2] -= val;",
            "            diff[r2 + 2][c2 + 2] += val;",
            "        }",
            "        ",
            "        // Evaluates the matrix and returns the final state in O(R * C)",
            "        long[][] getFinalMatrix() {",
            "            long[][] res = new long[r][c];",
            "            for (int i = 1; i <= r; i++) {",
            "                for (int j = 1; j <= c; j++) {",
            "                    diff[i][j] += diff[i - 1][j] + diff[i][j - 1] - diff[i - 1][j - 1];",
            "                    res[i - 1][j - 1] = diff[i][j];",
            "                }",
            "            }",
            "            return res;",
            "        }",
            "    }",
            "    $0"
        ],
        "description": "Prefix: arrdiff2d -> O(1) 2D Submatrix Range Addition queries."
    },
    "CP Array: Inversion Count (Merge Sort Method)": {
        "scope": "java",
        "prefix": "arrinversions",
        "body": [
            "    // Returns the number of pairs (i, j) where i < j and a[i] > a[j].",
            "    // Often disguised as \"minimum number of adjacent swaps to sort an array\".",
            "    static long countInversions(int[] a) {",
            "        int[] temp = new int[a.length];",
            "        return mergeSortAndCount(a, temp, 0, a.length - 1);",
            "    }",
            "",
            "    static long mergeSortAndCount(int[] a, int[] temp, int left, int right) {",
            "        long invCount = 0;",
            "        if (left < right) {",
            "            int mid = left + (right - left) / 2;",
            "            invCount += mergeSortAndCount(a, temp, left, mid);",
            "            invCount += mergeSortAndCount(a, temp, mid + 1, right);",
            "            invCount += merge(a, temp, left, mid, right);",
            "        }",
            "        return invCount;",
            "    }",
            "",
            "    static long merge(int[] a, int[] temp, int left, int mid, int right) {",
            "        int i = left, j = mid + 1, k = left;",
            "        long invCount = 0;",
            "        while (i <= mid && j <= right) {",
            "            if (a[i] <= a[j]) temp[k++] = a[i++];",
            "            else {",
            "                temp[k++] = a[j++];",
            "                invCount += (mid - i + 1); // Core logic: if a[i] > a[j], all elements after i are also > a[j]",
            "            }",
            "        }",
            "        while (i <= mid) temp[k++] = a[i++];",
            "        while (j <= right) temp[k++] = a[j++];",
            "        for (i = left; i <= right; i++) a[i] = temp[i];",
            "        return invCount;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: arrinversions -> O(N log N) Exact inversion counting via Merge Sort"
    },
    "CP Array: Mo's Algorithm (Standard 1D Offline Queries)": {
        "scope": "java",
        "prefix": "arrmos",
        "body": [
            "    static class MosAlgorithm {",
            "        static class Query implements Comparable<Query> {",
            "            int l, r, id, block;",
            "            Query(int l, int r, int id, int blockSize) {",
            "                this.l = l; this.r = r; this.id = id;",
            "                this.block = l / blockSize;",
            "            }",
            "            public int compareTo(Query other) {",
            "                if (this.block != other.block) return Integer.compare(this.block, other.block);",
            "                // Optimization: alternate sorting direction for even/odd blocks",
            "                return (this.block % 2 == 1) ? Integer.compare(this.r, other.r) : Integer.compare(other.r, this.r);",
            "            }",
            "        }",
            "        ",
            "        static long[] processQueries(int[] a, int[][] queriesRaw) {",
            "            int n = a.length, q = queriesRaw.length;",
            "            int blockSize = (int) Math.max(1, Math.sqrt(n));",
            "            Query[] queries = new Query[q];",
            "            for (int i = 0; i < q; i++) {",
            "                // Assume queriesRaw contains [L, R] 0-indexed",
            "                queries[i] = new Query(queriesRaw[i][0], queriesRaw[i][1], i, blockSize);",
            "            }",
            "            Arrays.sort(queries);",
            "            ",
            "            long[] answers = new long[q];",
            "            int currL = 0, currR = -1;",
            "            long currentAnswer = 0;",
            "            // frequency array or other state data goes here",
            "            ",
            "            for (Query query : queries) {",
            "                while (currL > query.l) { currL--; /* add(a[currL]); */ }",
            "                while (currR < query.r) { currR++; /* add(a[currR]); */ }",
            "                while (currL < query.l) { /* remove(a[currL]); */ currL++; }",
            "                while (currR > query.r) { /* remove(a[currR]); */ currR--; }",
            "                ",
            "                answers[query.id] = currentAnswer;",
            "            }",
            "            return answers;",
            "        }",
            "    }",
            "    $0"
        ],
        "description": "Prefix: arrmos -> O((N+Q)*sqrt(N)) Mo's Algorithm for offline range array queries (e.g., distinct elements)"
    },
    "CP Array: Kadane's Algorithm (Max Subarray Sum)": {
        "scope": "java",
        "prefix": "arrkadane",
        "body": [
            "    // Returns {maxSum, start_index, end_index}",
            "    static long[] kadane(long[] a) {",
            "        long maxSum = Long.MIN_VALUE, currentSum = 0;",
            "        int start = 0, end = 0, tempStart = 0;",
            "        ",
            "        for (int i = 0; i < a.length; i++) {",
            "            currentSum += a[i];",
            "            if (currentSum > maxSum) {",
            "                maxSum = currentSum;",
            "                start = tempStart;",
            "                end = i;",
            "            }",
            "            if (currentSum < 0) {",
            "                currentSum = 0;",
            "                tempStart = i + 1;",
            "            }",
            "        }",
            "        return new long[]{maxSum, start, end};",
            "    }",
            "    $0"
        ],
        "description": "Prefix: arrkadane -> O(N) Kadane's algorithm identifying max sum and exact bounds"
    }
}