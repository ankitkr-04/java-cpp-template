{
    "CP Class: Base Point 2D & EPS": {
        "scope": "java",
        "prefix": "classpoint",
        "body": [
            "    static final double EPS = 1e-9;",
            "",
            "    static class Point implements Comparable<Point> {",
            "        double x, y;",
            "        Point(double x, double y) { this.x = x; this.y = y; }",
            "",
            "        // Sorts by X, then by Y.",
            "        public int compareTo(Point o) {",
            "            if (Math.abs(this.x - o.x) > EPS) return Double.compare(this.x, o.x);",
            "            return Double.compare(this.y, o.y);",
            "        }",
            "    }",
            "    $0"
        ],
        "description": "Prefix: classpoint -> Core 2D Point class and EPS precision constant"
    },
    "CP Class: 3D Point & Vector Math": {
        "scope": "java",
        "prefix": "classpoint3d",
        "body": [
            "    static class Point3D {",
            "        double x, y, z;",
            "        Point3D(double x, double y, double z) { this.x = x; this.y = y; this.z = z; }",
            "    }",
            "",
            "    static double dist3D(Point3D p1, Point3D p2) {",
            "        double dx = p1.x - p2.x, dy = p1.y - p2.y, dz = p1.z - p2.z;",
            "        return Math.sqrt(dx * dx + dy * dy + dz * dz);",
            "    }",
            "",
            "    static double dot3D(Point3D a, Point3D b) {",
            "        return a.x * b.x + a.y * b.y + a.z * b.z;",
            "    }",
            "",
            "    static Point3D cross3D(Point3D a, Point3D b) {",
            "        return new Point3D(",
            "            a.y * b.z - a.z * b.y,",
            "            a.z * b.x - a.x * b.z,",
            "            a.x * b.y - a.y * b.x",
            "        );",
            "    }",
            "    $0"
        ],
        "description": "Prefix: classpoint3d -> 3D Point class with distance, dot, and cross products"
    },
    "CP Class: Line Equation (Ax + By + C = 0)": {
        "scope": "java",
        "prefix": "classline",
        "body": [
            "    static class Line {",
            "        double a, b, c;",
            "        Line(double a, double b, double c) { this.a = a; this.b = b; this.c = c; }",
            "        Line(Point p1, Point p2) {",
            "            this.a = p1.y - p2.y;",
            "            this.b = p2.x - p1.x;",
            "            this.c = -this.a * p1.x - this.b * p1.y;",
            "        }",
            "    }",
            "    $0"
        ],
        "description": "Prefix: classline -> Standard Line class from two points"
    },
    "CP Class: Int Pair (Comparable)": {
        "scope": "java",
        "prefix": "classintpair",
        "body": [
            "    static class IntPair implements Comparable<IntPair> {",
            "        int first, second;",
            "        IntPair(int f, int s) { this.first = f; this.second = s; }",
            "        public int compareTo(IntPair o) {",
            "            if (this.first != o.first) return Integer.compare(this.first, o.first);",
            "            return Integer.compare(this.second, o.second);",
            "        }",
            "    }",
            "    $0"
        ],
        "description": "Prefix: classintpair -> High performance integer pair"
    },
    "CP Class: Long Pair (Comparable)": {
        "scope": "java",
        "prefix": "classlongpair",
        "body": [
            "    static class LongPair implements Comparable<LongPair> {",
            "        long first, second;",
            "        LongPair(long f, long s) { this.first = f; this.second = s; }",
            "        public int compareTo(LongPair o) {",
            "            if (this.first != o.first) return Long.compare(this.first, o.first);",
            "            return Long.compare(this.second, o.second);",
            "        }",
            "    }",
            "    $0"
        ],
        "description": "Prefix: classlongpair -> High performance long pair"
    },
    "CP Class: Exact Fraction": {
        "scope": "java",
        "prefix": "classfraction",
        "body": [
            "    static class Fraction implements Comparable<Fraction> {",
            "        long num, den;",
            "        Fraction(long n, long d) {",
            "            if (d == 0) throw new ArithmeticException(\"Divide by zero\");",
            "            long g = gcd(Math.abs(n), Math.abs(d));",
            "            this.num = n / g;",
            "            this.den = d / g;",
            "            if (this.den < 0) { this.num = -this.num; this.den = -this.den; }",
            "        }",
            "        static long gcd(long a, long b) { return b == 0 ? a : gcd(b, a % b); }",
            "        public int compareTo(Fraction o) {",
            "            return Long.compare(this.num * o.den, this.den * o.num);",
            "        }",
            "        public boolean equals(Object o) {",
            "            if (!(o instanceof Fraction)) return false;",
            "            Fraction f = (Fraction) o;",
            "            return this.num == f.num && this.den == f.den;",
            "        }",
            "        public int hashCode() { return Objects.hash(num, den); }",
            "    }",
            "    $0"
        ],
        "description": "Prefix: classfraction -> Exact math class (numerator/denominator) to bypass floating-point bugs"
    },
    "CP Class: Graph Edge": {
        "scope": "java",
        "prefix": "classedge",
        "body": [
            "    static class Edge implements Comparable<Edge> {",
            "        int u, v;",
            "        long w;",
            "        Edge(int u, int v, long w) { this.u = u; this.v = v; this.w = w; }",
            "        public int compareTo(Edge o) {",
            "            return Long.compare(this.w, o.w);",
            "        }",
            "    }",
            "    $0"
        ],
        "description": "Prefix: classedge -> Weighted Edge class for graphs, sorts by weight ascending"
    },
    "CP Class: Disjoint Set Union (DSU)": {
        "scope": "java",
        "prefix": "classdsu",
        "body": [
            "    static class DSU {",
            "        int[] parent, size;",
            "        int components;",
            "        DSU(int n) {",
            "            parent = new int[n + 1];",
            "            size = new int[n + 1];",
            "            components = n;",
            "            for (int i = 0; i <= n; i++) {",
            "                parent[i] = i;",
            "                size[i] = 1;",
            "            }",
            "        }",
            "        int find(int i) {",
            "            if (parent[i] == i) return i;",
            "            return parent[i] = find(parent[i]); // Path compression",
            "        }",
            "        boolean union(int i, int j) {",
            "            int rootI = find(i), rootJ = find(j);",
            "            if (rootI != rootJ) {",
            "                if (size[rootI] < size[rootJ]) {",
            "                    int temp = rootI; rootI = rootJ; rootJ = temp;",
            "                }",
            "                parent[rootJ] = rootI; // Union by size",
            "                size[rootI] += size[rootJ];",
            "                components--;",
            "                return true;",
            "            }",
            "            return false;",
            "        }",
            "    }",
            "    $0"
        ],
        "description": "Prefix: classdsu -> O(alpha(N)) Union-Find for Graph Connectivity & Kruskal's"
    },
    "CP Class: Fenwick Tree (BIT)": {
        "scope": "java",
        "prefix": "classbit",
        "body": [
            "    static class FenwickTree {",
            "        long[] tree;",
            "        int n;",
            "        FenwickTree(int n) {",
            "            this.n = n;",
            "            tree = new long[n + 1];",
            "        }",
            "        void add(int i, long delta) {",
            "            for (; i <= n; i += i & -i) tree[i] += delta;",
            "        }",
            "        long query(int i) {",
            "            long sum = 0;",
            "            for (; i > 0; i -= i & -i) sum += tree[i];",
            "            return sum;",
            "        }",
            "        long query(int l, int r) {",
            "            return query(r) - query(l - 1);",
            "        }",
            "    }",
            "    $0"
        ],
        "description": "Prefix: classbit -> O(log N) point updates and range sum queries (1-indexed)"
    },
    "CP Class: Segment Tree (Iterative)": {
        "scope": "java",
        "prefix": "classsegtree",
        "body": [
            "    static class SegmentTree {",
            "        long[] tree;",
            "        int n;",
            "        SegmentTree(long[] arr) {",
            "            n = arr.length;",
            "            tree = new long[2 * n];",
            "            for (int i = 0; i < n; i++) tree[n + i] = arr[i];",
            "            for (int i = n - 1; i > 0; --i) tree[i] = tree[i << 1] + tree[i << 1 | 1];",
            "        }",
            "        void update(int p, long val) {",
            "            for (tree[p += n] = val; p > 1; p >>= 1) ",
            "                tree[p >> 1] = tree[p] + tree[p ^ 1];",
            "        }",
            "        long query(int l, int r) { // Queries sum in [l, r) -> 0-indexed, exclusive right",
            "            long res = 0;",
            "            for (l += n, r += n; l < r; l >>= 1, r >>= 1) {",
            "                if ((l & 1) > 0) res += tree[l++];",
            "                if ((r & 1) > 0) res += tree[--r];",
            "            }",
            "            return res;",
            "        }",
            "    }",
            "    $0"
        ],
        "description": "Prefix: classsegtree -> Ultra-fast iterative segment tree for Point Update / Range Query"
    },
    "CP Class: Trie (Prefix Tree)": {
        "scope": "java",
        "prefix": "classtrie",
        "body": [
            "    static class TrieNode {",
            "        TrieNode[] child = new TrieNode[26];",
            "        boolean isEnd = false;",
            "        int prefixCount = 0;",
            "    }",
            "    static class Trie {",
            "        TrieNode root = new TrieNode();",
            "        void insert(String word) {",
            "            TrieNode curr = root;",
            "            for (char c : word.toCharArray()) {",
            "                int idx = c - 'a';",
            "                if (curr.child[idx] == null) curr.child[idx] = new TrieNode();",
            "                curr = curr.child[idx];",
            "                curr.prefixCount++;",
            "            }",
            "            curr.isEnd = true;",
            "        }",
            "        boolean search(String word) {",
            "            TrieNode curr = root;",
            "            for (char c : word.toCharArray()) {",
            "                if (curr.child[c - 'a'] == null) return false;",
            "                curr = curr.child[c - 'a'];",
            "            }",
            "            return curr.isEnd;",
            "        }",
            "    }",
            "    $0"
        ],
        "description": "Prefix: classtrie -> String matching and prefix counting"
    },
    "CP Class: Custom Linked List Node & Reversal": {
        "scope": "java",
        "prefix": "classlistnode",
        "body": [
            "    static class ListNode {",
            "        int val;",
            "        ListNode next;",
            "        ListNode(int val) { this.val = val; }",
            "    }",
            "",
            "    static ListNode reverseList(ListNode head) {",
            "        ListNode prev = null, curr = head;",
            "        while (curr != null) {",
            "            ListNode nextTemp = curr.next;",
            "            curr.next = prev;",
            "            prev = curr;",
            "            curr = nextTemp;",
            "        }",
            "        return prev;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: classlistnode -> Standard Linked List Node class and O(N) Iterative Reversal"
    }
}