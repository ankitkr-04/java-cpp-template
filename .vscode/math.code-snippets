{
    "CP Math: GCD & LCM": {
        "scope": "java",
        "prefix": "mathgcd",
        "body": [
            "    static long gcd(long a, long b) {",
            "        while (b != 0) {",
            "            long t = b;",
            "            b = a % b;",
            "            a = t;",
            "        }",
            "        return a;",
            "    }",
            "",
            "    static long lcm(long a, long b) {",
            "        return (a / gcd(a, b)) * b;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: mathgcd -> Standard iterative GCD and LCM"
    },
    "CP Math: Extended Euclidean Algorithm": {
        "scope": "java",
        "prefix": "mathextgcd",
        "body": [
            "    // Returns {gcd(a, b), x, y} such that a*x + b*y = gcd(a, b)",
            "    static long[] extendedGCD(long a, long b) {",
            "        if (b == 0) return new long[]{a, 1, 0};",
            "        long[] res = extendedGCD(b, a % b);",
            "        long x1 = res[1];",
            "        long y1 = res[2];",
            "        res[1] = y1;",
            "        res[2] = x1 - y1 * (a / b);",
            "        return res;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: mathextgcd -> Solves Ax + By = GCD(A, B) and advanced mod inverses"
    },
    "CP Math: Fast Modular Exponentiation & Inverse": {
        "scope": "java",
        "prefix": "mathmod",
        "body": [
            "    static long modPow(long base, long exp, long mod) {",
            "        long res = 1;",
            "        base %= mod;",
            "        while (exp > 0) {",
            "            if ((exp & 1) == 1) res = (res * base) % mod;",
            "            base = (base * base) % mod;",
            "            exp >>= 1;",
            "        }",
            "        return res;",
            "    }",
            "",
            "    static long modInverse(long n, long mod) {",
            "        return modPow(n, mod - 2, mod); // Valid ONLY if mod is a prime number",
            "    }",
            "    $0"
        ],
        "description": "Prefix: mathmod -> Fast exponentiation (base^exp % mod) and Modular Inverse"
    },
    "CP Math: Safe Modulo Arithmetic": {
        "scope": "java",
        "prefix": "mathsafemod",
        "body": [
            "    static long modAdd(long a, long b, long m) { return ((a % m) + (b % m)) % m; }",
            "    static long modSub(long a, long b, long m) { return ((a % m) - (b % m) + m) % m; }",
            "    static long modMul(long a, long b, long m) { return ((a % m) * (b % m)) % m; }",
            "    $0"
        ],
        "description": "Prefix: mathsafemod -> Safe addition, subtraction, and multiplication preventing negative modulo bugs"
    },
    "CP Math: Sieve & SPF (Fast Factorization)": {
        "scope": "java",
        "prefix": "mathsieve",
        "body": [
            "    static boolean[] isPrime;",
            "    static int[] spf; // Smallest Prime Factor",
            "",
            "    static void sieve(int n) {",
            "        isPrime = new boolean[n + 1];",
            "        spf = new int[n + 1];",
            "        Arrays.fill(isPrime, true);",
            "        isPrime[0] = isPrime[1] = false;",
            "        for (int i = 2; i <= n; i++) spf[i] = i;",
            "",
            "        for (int p = 2; p * p <= n; p++) {",
            "            if (isPrime[p]) {",
            "                for (int i = p * p; i <= n; i += p) {",
            "                    isPrime[i] = false;",
            "                    if (spf[i] == i) spf[i] = p;",
            "                }",
            "            }",
            "        }",
            "    }",
            "",
            "    static List<Integer> getFactorsFast(int n) {",
            "        List<Integer> factors = new ArrayList<>();",
            "        while (n != 1) {",
            "            factors.add(spf[n]);",
            "            n /= spf[n];",
            "        }",
            "        return factors;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: mathsieve -> Global Sieve + SPF for O(log N) prime factorization"
    },
    "CP Math: Basic Prime Check & Factorization": {
        "scope": "java",
        "prefix": "mathprime",
        "body": [
            "    static boolean isPrime(long n) {",
            "        if (n <= 1) return false;",
            "        if (n <= 3) return true;",
            "        if (n % 2 == 0 || n % 3 == 0) return false;",
            "        for (long i = 5; i * i <= n; i += 6) {",
            "            if (n % i == 0 || n % (i + 2) == 0) return false;",
            "        }",
            "        return true;",
            "    }",
            "",
            "    static Map<Long, Integer> primeFactors(long n) {",
            "        Map<Long, Integer> factors = new HashMap<>();",
            "        for (long d = 2; d * d <= n; d++) {",
            "            int count = 0;",
            "            while (n % d == 0) {",
            "                count++;",
            "                n /= d;",
            "            }",
            "            if (count > 0) factors.put(d, count);",
            "        }",
            "        if (n > 1) factors.put(n, 1);",
            "        return factors;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: mathprime -> O(sqrt(N)) Prime Check and Prime Factorization (returns Map)"
    },
    "CP Math: O(1) Probable Prime (Miller-Rabin Hack)": {
        "scope": "java",
        "prefix": "mathprimefast",
        "body": [
            "    static boolean isPrimeFast(long n) {",
            "        if (n <= 1) return false;",
            "        if (n <= 3) return true;",
            "        // 15 certainty is enough for numbers up to 10^18 in competitive programming",
            "        return java.math.BigInteger.valueOf(n).isProbablePrime(15);",
            "    }",
            "    $0"
        ],
        "description": "Prefix: mathprimefast -> Optimized Miller-Rabin prime check for massive numbers (10^18)"
    },
    "CP Math: Divisors of a Number": {
        "scope": "java",
        "prefix": "mathdivisors",
        "body": [
            "    static List<Long> getDivisors(long n) {",
            "        List<Long> div = new ArrayList<>();",
            "        for (long i = 1; i * i <= n; i++) {",
            "            if (n % i == 0) {",
            "                div.add(i);",
            "                if (i * i != n) div.add(n / i);",
            "            }",
            "        }",
            "        Collections.sort(div);",
            "        return div;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: mathdivisors -> Gets all divisors of N in O(sqrt(N)) and sorts them"
    },
    "CP Math: Euler's Totient Function (Phi)": {
        "scope": "java",
        "prefix": "mathphi",
        "body": [
            "    // Counts numbers <= n that are coprime to n",
            "    static long phi(long n) {",
            "        long result = n;",
            "        for (long p = 2; p * p <= n; p++) {",
            "            if (n % p == 0) {",
            "                while (n % p == 0) n /= p;",
            "                result -= result / p;",
            "            }",
            "        }",
            "        if (n > 1) result -= result / n;",
            "        return result;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: mathphi -> Euler's Totient (coprime count) in O(sqrt(N))"
    },
    "CP Math: Combinatorics (nCr, nPr with Modulo)": {
        "scope": "java",
        "prefix": "mathncr",
        "body": [
            "    static long[] fact, invFact;",
            "    static void precomputeFactorials(int n, long mod) {",
            "        fact = new long[n + 1];",
            "        invFact = new long[n + 1];",
            "        fact[0] = 1;",
            "        invFact[0] = 1;",
            "        for (int i = 1; i <= n; i++) {",
            "            fact[i] = (fact[i - 1] * i) % mod;",
            "        }",
            "        invFact[n] = modPow(fact[n], mod - 2, mod);",
            "        for (int i = n - 1; i >= 1; i--) {",
            "            invFact[i] = (invFact[i + 1] * (i + 1)) % mod;",
            "        }",
            "    }",
            "",
            "    static long nCr(int n, int r, long mod) {",
            "        if (r < 0 || r > n) return 0;",
            "        return fact[n] * invFact[r] % mod * invFact[n - r] % mod;",
            "    }",
            "",
            "    static long nPr(int n, int r, long mod) {",
            "        if (r < 0 || r > n) return 0;",
            "        return fact[n] * invFact[n - r] % mod;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: mathncr -> Precomputes Factorials and calculates nCr / nPr in O(1) time"
    },
    "CP Math: Iterative nCr (Huge N, Small R)": {
        "scope": "java",
        "prefix": "mathncriter",
        "body": [
            "    static long nCrIterative(long n, long r) {",
            "        if (r < 0 || r > n) return 0;",
            "        if (r > n / 2) r = n - r;",
            "        long res = 1;",
            "        for (long i = 1; i <= r; i++) {",
            "            res = res * (n - i + 1) / i;",
            "        }",
            "        return res;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: mathncriter -> O(R) time nCr without modulo. Best when N is huge but R is small."
    },
    "CP Math: Pascal's Triangle (nCr without Modulo)": {
        "scope": "java",
        "prefix": "mathpascal",
        "body": [
            "    static long[][] C;",
            "    static void buildPascal(int n) {",
            "        C = new long[n + 1][n + 1];",
            "        for (int i = 0; i <= n; i++) {",
            "            C[i][0] = 1;",
            "            for (int j = 1; j <= i; j++) {",
            "                C[i][j] = C[i - 1][j - 1] + C[i - 1][j];",
            "            }",
            "        }",
            "    }",
            "    // Safe for N <= 60 without overflowing standard long",
            "    $0"
        ],
        "description": "Prefix: mathpascal -> Global 2D array for exact nCr combinations (No Modulo)"
    },
    "CP Math: Catalan Numbers (O(N) with Modulo)": {
        "scope": "java",
        "prefix": "mathcatalan",
        "body": [
            "    static long[] generateCatalan(int n, long mod) {",
            "        long[] cat = new long[n + 1];",
            "        cat[0] = cat[1] = 1;",
            "        for (int i = 2; i <= n; i++) {",
            "            for (int j = 0; j < i; j++) {",
            "                cat[i] = (cat[i] + (cat[j] * cat[i - j - 1]) % mod) % mod;",
            "            }",
            "        }",
            "        return cat;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: mathcatalan -> Bracket matching, BST arrangements, chord intersections"
    },
    "CP Math: Matrix Exponentiation": {
        "scope": "java",
        "prefix": "mathmatexpo",
        "body": [
            "    static long[][] matMul(long[][] A, long[][] B, long mod) {",
            "        int rA = A.length, cA = A[0].length, cB = B[0].length;",
            "        long[][] C = new long[rA][cB];",
            "        for (int i = 0; i < rA; i++)",
            "            for (int j = 0; j < cB; j++)",
            "                for (int k = 0; k < cA; k++)",
            "                    C[i][j] = (C[i][j] + A[i][k] * B[k][j]) % mod;",
            "        return C;",
            "    }",
            "",
            "    static long[][] matPow(long[][] A, long exp, long mod) {",
            "        int n = A.length;",
            "        long[][] res = new long[n][n];",
            "        for (int i = 0; i < n; i++) res[i][i] = 1; // Identity matrix",
            "        while (exp > 0) {",
            "            if ((exp & 1) == 1) res = matMul(res, A, mod);",
            "            A = matMul(A, A, mod);",
            "            exp >>= 1;",
            "        }",
            "        return res;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: mathmatexpo -> O(K^3 log N) linear recurrences (e.g., massive Fibonacci)"
    },
    "CP Math: 2D Prefix Sums (Grid Math)": {
        "scope": "java",
        "prefix": "mathprefix2d",
        "body": [
            "    static long[][] build2DPrefixSum(int[][] grid) {",
            "        int r = grid.length, c = grid[0].length;",
            "        long[][] pref = new long[r + 1][c + 1];",
            "        for (int i = 1; i <= r; i++) {",
            "            for (int j = 1; j <= c; j++) {",
            "                pref[i][j] = grid[i - 1][j - 1] ",
            "                           + pref[i - 1][j] + pref[i][j - 1] ",
            "                           - pref[i - 1][j - 1];",
            "            }",
            "        }",
            "        return pref;",
            "    }",
            "",
            "    // Query sum of subgrid from (r1, c1) to (r2, c2) in O(1). 0-indexed.",
            "    static long query2DPrefix(long[][] pref, int r1, int c1, int r2, int c2) {",
            "        return pref[r2 + 1][c2 + 1] ",
            "             - pref[r1][c2 + 1] - pref[r2 + 1][c1] ",
            "             + pref[r1][c1];",
            "    }",
            "    $0"
        ],
        "description": "Prefix: mathprefix2d -> O(1) sum queries for subgrids/matrices"
    },
    "CP Math: Fast Fibonacci (Doubling Method O(log N))": {
        "scope": "java",
        "prefix": "mathfibo",
        "body": [
            "    // Returns {F_n, F_{n+1}} in O(log N)",
            "    static long[] fastFibonacci(long n, long mod) {",
            "        if (n == 0) return new long[]{0, 1};",
            "        long[] p = fastFibonacci(n >> 1, mod);",
            "        long c = p[0] * ((p[1] << 1) % mod - p[0] + mod) % mod;",
            "        long d = (p[0] * p[0] % mod + p[1] * p[1] % mod) % mod;",
            "        if ((n & 1) == 1) return new long[]{d, (c + d) % mod};",
            "        return new long[]{c, d};",
            "    }",
            "    $0"
        ],
        "description": "Prefix: mathfibo -> Lightning fast N-th Fibonacci up to 10^18"
    },
    "CP Math: Fast Bitwise Utilities": {
        "scope": "java",
        "prefix": "mathbit",
        "body": [
            "    static boolean isPowerOfTwo(long n) {",
            "        return n > 0 && (n & (n - 1)) == 0;",
            "    }",
            "",
            "    static long nextPowerOfTwo(long n) {",
            "        n--;",
            "        n |= n >> 1; n |= n >> 2;",
            "        n |= n >> 4; n |= n >> 8;",
            "        n |= n >> 16; n |= n >> 32;",
            "        return n + 1;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: mathbit -> Bit manipulation checks (powers of two)"
    },
    "CP Math: Base Converter (String <-> Base)": {
        "scope": "java",
        "prefix": "mathbase",
        "body": [
            "    static long toDecimal(String s, int base) {",
            "        return Long.parseLong(s, base);",
            "    }",
            "",
            "    static String fromDecimal(long n, int base) {",
            "        return Long.toString(n, base).toUpperCase();",
            "    }",
            "    $0"
        ],
        "description": "Prefix: mathbase -> Quickly shift numbers between bases (Binary, Hex, Custom)"
    },
    "CP Math: Chinese Remainder Theorem": {
        "scope": "java",
        "prefix": "mathcrt",
        "body": [
            "    // Solves system: x ≡ r1 (mod m1), x ≡ r2 (mod m2), ...",
            "    // Returns {x, lcm} such that answer = x + k*lcm for all k >= 0",
            "    // Returns null if no solution exists",
            "    static long[] crt(long r1, long m1, long r2, long m2) {",
            "        long[] eg = extendedGCD(m1, m2);",
            "        long g = eg[0], p = eg[1];",
            "        if ((r2 - r1) % g != 0) return null; // No solution",
            "        long lcm = m1 / g * m2;",
            "        long x = (r1 + m1 * ((r2 - r1) / g % (m2 / g) * p % (m2 / g))) % lcm;",
            "        if (x < 0) x += lcm;",
            "        return new long[]{x, lcm};",
            "    }",
            "",
            "    // Solves system of N congruences",
            "    static long[] crtMultiple(long[] remainders, long[] mods) {",
            "        long r = remainders[0], m = mods[0];",
            "        for (int i = 1; i < remainders.length; i++) {",
            "            long[] res = crt(r, m, remainders[i], mods[i]);",
            "            if (res == null) return null;",
            "            r = res[0]; m = res[1];",
            "        }",
            "        return new long[]{r, m};",
            "    }",
            "    $0"
        ],
        "description": "Prefix: mathcrt -> Solves system of modular congruences. Requires mathextgcd."
    },
    "CP Math: Lucas Theorem (nCr mod small prime)": {
        "scope": "java",
        "prefix": "mathlucas",
        "body": [
            "    // Computes nCr mod p where p is a SMALL prime (p <= 10^5).",
            "    // When N is astronomical (10^18) but p is small.",
            "    static long lucasCr(long n, long r, long p) {",
            "        if (r == 0) return 1;",
            "        return smallCr(n % p, r % p, p) * lucasCr(n / p, r / p, p) % p;",
            "    }",
            "",
            "    static long smallCr(long n, long r, long p) {",
            "        if (r > n) return 0;",
            "        long num = 1, den = 1;",
            "        for (long i = 0; i < r; i++) {",
            "            num = num * ((n - i) % p) % p;",
            "            den = den * ((i + 1) % p) % p;",
            "        }",
            "        return num % p * modPow(den, p - 2, p) % p;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: mathlucas -> nCr mod small prime when N is huge. Requires mathmod."
    },
    "CP Math: Gaussian Elimination (Linear System Solver)": {
        "scope": "java",
        "prefix": "mathgauss",
        "body": [
            "    // Solves A*x = b. Returns null if no unique solution.",
            "    // a[i] contains [A_i0, A_i1, ..., A_in, b_i] (augmented matrix row)",
            "    static double[] gaussianElimination(double[][] a) {",
            "        int n = a.length;",
            "        double EPS = 1e-9;",
            "        ",
            "        for (int col = 0; col < n; col++) {",
            "            // Partial Pivoting: find max element in this column",
            "            int maxRow = col;",
            "            for (int row = col + 1; row < n; row++) {",
            "                if (Math.abs(a[row][col]) > Math.abs(a[maxRow][col])) maxRow = row;",
            "            }",
            "            double[] temp = a[col]; a[col] = a[maxRow]; a[maxRow] = temp;",
            "            ",
            "            if (Math.abs(a[col][col]) < EPS) return null; // Singular or infinite solutions",
            "            ",
            "            // Eliminate below",
            "            for (int row = col + 1; row < n; row++) {",
            "                double factor = a[row][col] / a[col][col];",
            "                for (int j = col; j <= n; j++) a[row][j] -= factor * a[col][j];",
            "            }",
            "        }",
            "        ",
            "        // Back substitution",
            "        double[] x = new double[n];",
            "        for (int i = n - 1; i >= 0; i--) {",
            "            x[i] = a[i][n];",
            "            for (int j = i + 1; j < n; j++) x[i] -= a[i][j] * x[j];",
            "            x[i] /= a[i][i];",
            "        }",
            "        return x;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: mathgauss -> O(N^3) Solves systems of linear equations using Gaussian Elimination"
    },
    "CP Math: Gaussian Elimination Mod (GF2 / Modular)": {
        "scope": "java",
        "prefix": "mathgaussmod",
        "body": [
            "    // Solves A*x ≡ b (mod MOD). Returns null if no unique solution.",
            "    static long[] gaussianEliminationMod(long[][] a, long mod) {",
            "        int n = a.length;",
            "        ",
            "        for (int col = 0; col < n; col++) {",
            "            int pivot = -1;",
            "            for (int row = col; row < n; row++) {",
            "                if (a[row][col] % mod != 0) { pivot = row; break; }",
            "            }",
            "            if (pivot == -1) return null;",
            "            long[] temp = a[col]; a[col] = a[pivot]; a[pivot] = temp;",
            "            ",
            "            long inv = modPow(a[col][col], mod - 2, mod);",
            "            for (int j = col; j <= n; j++) a[col][j] = a[col][j] * inv % mod;",
            "            ",
            "            for (int row = 0; row < n; row++) {",
            "                if (row == col || a[row][col] == 0) continue;",
            "                long factor = a[row][col];",
            "                for (int j = col; j <= n; j++) {",
            "                    a[row][j] = (a[row][j] - factor * a[col][j] % mod + mod) % mod;",
            "                }",
            "            }",
            "        }",
            "        ",
            "        long[] x = new long[n];",
            "        for (int i = 0; i < n; i++) x[i] = a[i][n];",
            "        return x;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: mathgaussmod -> O(N^3) Modular Gaussian Elimination. Requires mathmod."
    },
    "CP Math: NTT (Number Theoretic Transform)": {
        "scope": "java",
        "prefix": "mathntt",
        "body": [
            "    // Polynomial multiplication mod 998244353 in O(N log N).",
            "    // NTT-friendly prime: 998244353 = 119 * 2^23 + 1, primitive root = 3",
            "    static final long NTT_MOD = 998244353;",
            "    static final long NTT_G = 3;",
            "",
            "    static void ntt(long[] a, boolean invert) {",
            "        int n = a.length;",
            "        for (int i = 1, j = 0; i < n; i++) {",
            "            int bit = n >> 1;",
            "            for (; (j & bit) != 0; bit >>= 1) j ^= bit;",
            "            j ^= bit;",
            "            if (i < j) { long t = a[i]; a[i] = a[j]; a[j] = t; }",
            "        }",
            "        for (int len = 2; len <= n; len <<= 1) {",
            "            long w = invert ? modPow(NTT_G, NTT_MOD - 1 - (NTT_MOD - 1) / len, NTT_MOD)",
            "                            : modPow(NTT_G, (NTT_MOD - 1) / len, NTT_MOD);",
            "            for (int i = 0; i < n; i += len) {",
            "                long wn = 1;",
            "                for (int j = 0; j < len / 2; j++) {",
            "                    long u = a[i + j];",
            "                    long v = a[i + j + len / 2] * wn % NTT_MOD;",
            "                    a[i + j] = (u + v) % NTT_MOD;",
            "                    a[i + j + len / 2] = (u - v + NTT_MOD) % NTT_MOD;",
            "                    wn = wn * w % NTT_MOD;",
            "                }",
            "            }",
            "        }",
            "        if (invert) {",
            "            long nInv = modPow(n, NTT_MOD - 2, NTT_MOD);",
            "            for (int i = 0; i < n; i++) a[i] = a[i] * nInv % NTT_MOD;",
            "        }",
            "    }",
            "",
            "    static long[] polyMultiply(long[] a, long[] b) {",
            "        int resultLen = a.length + b.length - 1;",
            "        int n = 1;",
            "        while (n < resultLen) n <<= 1;",
            "        long[] fa = new long[n], fb = new long[n];",
            "        System.arraycopy(a, 0, fa, 0, a.length);",
            "        System.arraycopy(b, 0, fb, 0, b.length);",
            "        ntt(fa, false); ntt(fb, false);",
            "        for (int i = 0; i < n; i++) fa[i] = fa[i] * fb[i] % NTT_MOD;",
            "        ntt(fa, true);",
            "        return Arrays.copyOf(fa, resultLen);",
            "    }",
            "    $0"
        ],
        "description": "Prefix: mathntt -> O(N log N) Polynomial multiplication mod 998244353. Requires mathmod."
    },
    "CP Math: Pollard's Rho Factorization": {
        "scope": "java",
        "prefix": "mathpollard",
        "body": [
            "    // Factorizes numbers up to 10^18 in ~O(N^1/4) expected time.",
            "    static java.math.BigInteger rho(java.math.BigInteger n) {",
            "        java.math.BigInteger TWO = java.math.BigInteger.valueOf(2);",
            "        if (n.mod(TWO).equals(java.math.BigInteger.ZERO)) return TWO;",
            "        Random rand = new Random();",
            "        java.math.BigInteger x, y, c, d;",
            "        do {",
            "            x = new java.math.BigInteger(n.bitLength(), rand).mod(n);",
            "            y = x;",
            "            c = new java.math.BigInteger(n.bitLength(), rand).mod(n);",
            "            d = java.math.BigInteger.ONE;",
            "            while (d.equals(java.math.BigInteger.ONE)) {",
            "                x = x.multiply(x).add(c).mod(n);",
            "                y = y.multiply(y).add(c).mod(n);",
            "                y = y.multiply(y).add(c).mod(n);",
            "                d = x.subtract(y).abs().gcd(n);",
            "            }",
            "        } while (d.equals(n));",
            "        return d;",
            "    }",
            "",
            "    static List<Long> factorizeLarge(long n) {",
            "        List<Long> factors = new ArrayList<>();",
            "        if (n <= 1) return factors;",
            "        Deque<Long> stack = new ArrayDeque<>();",
            "        stack.push(n);",
            "        while (!stack.isEmpty()) {",
            "            long val = stack.pop();",
            "            if (val == 1) continue;",
            "            if (java.math.BigInteger.valueOf(val).isProbablePrime(15)) {",
            "                factors.add(val);",
            "            } else {",
            "                long d = rho(java.math.BigInteger.valueOf(val)).longValue();",
            "                stack.push(d);",
            "                stack.push(val / d);",
            "            }",
            "        }",
            "        Collections.sort(factors);",
            "        return factors;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: mathpollard -> O(N^1/4) Factorizes huge numbers (up to 10^18) via Pollard's Rho"
    },
    "CP Math: Count Divisors (Sieve-based)": {
        "scope": "java",
        "prefix": "mathdivsieve",
        "body": [
            "    // Counts divisors for ALL numbers from 1 to N in O(N log N)",
            "    static int[] countDivisorsSieve(int n) {",
            "        int[] divCount = new int[n + 1];",
            "        for (int i = 1; i <= n; i++) {",
            "            for (int j = i; j <= n; j += i) {",
            "                divCount[j]++;",
            "            }",
            "        }",
            "        return divCount;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: mathdivsieve -> O(N log N) Count of divisors for every number 1..N"
    },
    "CP Math: Euler's Totient Sieve": {
        "scope": "java",
        "prefix": "mathphisieve",
        "body": [
            "    static int[] phiSieve(int n) {",
            "        int[] phi = new int[n + 1];",
            "        for (int i = 0; i <= n; i++) phi[i] = i;",
            "        for (int i = 2; i <= n; i++) {",
            "            if (phi[i] == i) { // i is prime",
            "                for (int j = i; j <= n; j += i) {",
            "                    phi[j] -= phi[j] / i;",
            "                }",
            "            }",
            "        }",
            "        return phi;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: mathphisieve -> O(N log log N) Euler's Totient for ALL numbers 1..N"
    },
    "CP Math: Mobius Function Sieve": {
        "scope": "java",
        "prefix": "mathmobius",
        "body": [
            "    // mu[n] = 1 if n is square-free with even number of prime factors",
            "    // mu[n] = -1 if n is square-free with odd number of prime factors",
            "    // mu[n] = 0 if n has a squared prime factor",
            "    static int[] mobiusSieve(int n) {",
            "        int[] mu = new int[n + 1];",
            "        boolean[] isPrime = new boolean[n + 1];",
            "        int[] primes = new int[n + 1];",
            "        int cnt = 0;",
            "        Arrays.fill(isPrime, true);",
            "        mu[1] = 1;",
            "        for (int i = 2; i <= n; i++) {",
            "            if (isPrime[i]) { primes[cnt++] = i; mu[i] = -1; }",
            "            for (int j = 0; j < cnt && (long)i * primes[j] <= n; j++) {",
            "                isPrime[i * primes[j]] = false;",
            "                if (i % primes[j] == 0) { mu[i * primes[j]] = 0; break; }",
            "                mu[i * primes[j]] = -mu[i];",
            "            }",
            "        }",
            "        return mu;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: mathmobius -> O(N) Linear sieve for Mobius function. Key for inclusion-exclusion."
    },
    "CP Math: Discrete Logarithm (Baby-step Giant-step)": {
        "scope": "java",
        "prefix": "mathbsgs",
        "body": [
            "    // Finds smallest x >= 0 such that a^x ≡ b (mod m). Returns -1 if no solution.",
            "    // Requires gcd(a, m) = 1.",
            "    static long babyStepGiantStep(long a, long b, long m) {",
            "        if (m == 1) return 0;",
            "        a %= m; b %= m;",
            "        if (b == 1 % m) return 0;",
            "        ",
            "        int sqrtM = (int) Math.ceil(Math.sqrt(m));",
            "        Map<Long, Integer> table = new HashMap<>();",
            "        ",
            "        // Baby step: store a^j mod m for j = 0..sqrtM-1",
            "        long cur = b;",
            "        for (int j = 0; j < sqrtM; j++) {",
            "            table.put(cur, j);",
            "            cur = cur * a % m;",
            "        }",
            "        ",
            "        // Giant step: a^sqrtM mod m",
            "        long factor = modPow(a, sqrtM, m);",
            "        cur = 1;",
            "        for (int i = 0; i <= sqrtM; i++) {",
            "            if (table.containsKey(cur)) {",
            "                long res = (long) i * sqrtM - table.get(cur);",
            "                if (res >= 0) return res;",
            "            }",
            "            cur = cur * factor % m;",
            "        }",
            "        return -1;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: mathbsgs -> O(sqrt(M)) Discrete logarithm. Requires mathmod."
    },
    "CP Math: Inclusion-Exclusion (Coprime Count)": {
        "scope": "java",
        "prefix": "mathinclexcl",
        "body": [
            "    // Counts numbers in [1, n] coprime to a given number m",
            "    static long countCoprime(long n, long m) {",
            "        List<Long> primeFactors = new ArrayList<>();",
            "        long temp = m;",
            "        for (long p = 2; p * p <= temp; p++) {",
            "            if (temp % p == 0) {",
            "                primeFactors.add(p);",
            "                while (temp % p == 0) temp /= p;",
            "            }",
            "        }",
            "        if (temp > 1) primeFactors.add(temp);",
            "        ",
            "        int sz = primeFactors.size();",
            "        long result = 0;",
            "        for (int mask = 1; mask < (1 << sz); mask++) {",
            "            long product = 1;",
            "            int bits = 0;",
            "            for (int i = 0; i < sz; i++) {",
            "                if ((mask & (1 << i)) != 0) {",
            "                    product *= primeFactors.get(i);",
            "                    bits++;",
            "                }",
            "            }",
            "            if (bits % 2 == 1) result += n / product;",
            "            else result -= n / product;",
            "        }",
            "        return n - result;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: mathinclexcl -> Counts coprime numbers via Inclusion-Exclusion principle"
    },
    "CP Math: Modular Constants": {
        "scope": "java",
        "prefix": "mathconst",
        "body": [
            "    static final long MOD = 1_000_000_007L;",
            "    static final long MOD2 = 998_244_353L;",
            "    static final int INF = Integer.MAX_VALUE;",
            "    static final long LINF = Long.MAX_VALUE;",
            "    $0"
        ],
        "description": "Prefix: mathconst -> Common CP constants (MOD, INF, LINF)"
    }
}