{
    "CP Geo: Basic Vector Math & Orientation": {
        "scope": "java",
        "prefix": "geobasic",
        "body": [
            "    static double dist(Point p1, Point p2) {",
            "        return Math.hypot(p1.x - p2.x, p1.y - p2.y);",
            "    }",
            "",
            "    // 2D Cross Product. Returns Z-component.",
            "    static double cross(Point o, Point a, Point b) {",
            "        return (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);",
            "    }",
            "",
            "    // Returns: 0 if collinear, > 0 if Left turn (CCW), < 0 if Right turn (CW)",
            "    static int orientation(Point o, Point a, Point b) {",
            "        double cp = cross(o, a, b);",
            "        if (Math.abs(cp) < EPS) return 0;",
            "        return cp > 0 ? 1 : -1;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: geobasic -> 2D Distance, Cross Product, and Turn Orientation"
    },
    "CP Geo: Line Intersection": {
        "scope": "java",
        "prefix": "geointersect",
        "body": [
            "    // Requires classline and classpoint",
            "    static Point intersect(Line l1, Line l2) {",
            "        double det = l1.a * l2.b - l2.a * l1.b;",
            "        if (Math.abs(det) < EPS) return null; // Parallel or collinear lines",
            "        double x = (l1.b * l2.c - l2.b * l1.c) / det;",
            "        double y = (l2.a * l1.c - l1.a * l2.c) / det;",
            "        return new Point(x, y);",
            "    }",
            "    $0"
        ],
        "description": "Prefix: geointersect -> Exact point of intersection of two Lines (Cramer's Rule)"
    },
    "CP Geo: Point to Line Segment Distance": {
        "scope": "java",
        "prefix": "geosegdist",
        "body": [
            "    // Shortest distance from point P to line segment AB",
            "    static double pointToSegmentDist(Point p, Point a, Point b) {",
            "        double l2 = dist(a, b);",
            "        l2 = l2 * l2; // squared length of segment",
            "        if (l2 < EPS) return dist(p, a); // A and B are the same point",
            "        ",
            "        // Consider the line extending the segment, parameterized as A + t (B - A).",
            "        // We find projection of point p onto the line. ",
            "        double t = ((p.x - a.x) * (b.x - a.x) + (p.y - a.y) * (b.y - a.y)) / l2;",
            "        t = Math.max(0, Math.min(1, t)); // Clamp t to the [0, 1] segment bounds",
            "        ",
            "        Point projection = new Point(a.x + t * (b.x - a.x), a.y + t * (b.y - a.y));",
            "        return dist(p, projection);",
            "    }",
            "    $0"
        ],
        "description": "Prefix: geosegdist -> Shortest distance from a Point to a Line Segment"
    },
    "CP Geo: Polygon Area & Point-in-Polygon": {
        "scope": "java",
        "prefix": "geopoly",
        "body": [
            "    // Shoelace Formula: O(N) Exact Area",
            "    static double polygonArea(Point[] p) {",
            "        double area = 0.0;",
            "        int n = p.length;",
            "        for (int i = 0; i < n; i++) {",
            "            area += (p[i].x * p[(i + 1) % n].y - p[(i + 1) % n].x * p[i].y);",
            "        }",
            "        return Math.abs(area) / 2.0;",
            "    }",
            "",
            "    // Ray-casting algorithm: returns true if point 'pt' is strictly inside polygon",
            "    static boolean isInsidePolygon(Point pt, Point[] poly) {",
            "        int n = poly.length;",
            "        boolean inside = false;",
            "        for (int i = 0, j = n - 1; i < n; j = i++) {",
            "            if (((poly[i].y > pt.y) != (poly[j].y > pt.y)) &&",
            "                (pt.x < (poly[j].x - poly[i].x) * (pt.y - poly[i].y) / (poly[j].y - poly[i].y) + poly[i].x)) {",
            "                inside = !inside;",
            "            }",
            "        }",
            "        return inside;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: geopoly -> Shoelace Polygon Area and Ray-Casting Point-in-Polygon checks"
    },
    "CP Geo: Convex Hull (Monotone Chain)": {
        "scope": "java",
        "prefix": "geohull",
        "body": [
            "    // O(N log N) Convex Hull. Requires geobasic (cross product) and classpoint.",
            "    static Point[] convexHull(Point[] pts) {",
            "        int n = pts.length, k = 0;",
            "        if (n <= 2) return pts;",
            "        Point[] hull = new Point[2 * n];",
            "        Arrays.sort(pts); // Depends on Point implementing Comparable",
            "        ",
            "        // Build lower hull",
            "        for (int i = 0; i < n; ++i) {",
            "            while (k >= 2 && cross(hull[k - 2], hull[k - 1], pts[i]) <= 0) k--;",
            "            hull[k++] = pts[i];",
            "        }",
            "        ",
            "        // Build upper hull",
            "        for (int i = n - 2, t = k + 1; i >= 0; i--) {",
            "            while (k >= t && cross(hull[k - 2], hull[k - 1], pts[i]) <= 0) k--;",
            "            hull[k++] = pts[i];",
            "        }",
            "        ",
            "        return Arrays.copyOfRange(hull, 0, k - 1);",
            "    }",
            "    $0"
        ],
        "description": "Prefix: geohull -> O(N log N) Convex Boundary calculation using Monotone Chain"
    },
    "CP Geo: 3D Point & Vector Math": {
        "scope": "java",
        "prefix": "geo3d",
        "body": [
            "    // Requires classpoint3d",
            "    static double dist3D(Point3D p1, Point3D p2) {",
            "        double dx = p1.x - p2.x, dy = p1.y - p2.y, dz = p1.z - p2.z;",
            "        return Math.sqrt(dx * dx + dy * dy + dz * dz);",
            "    }",
            "",
            "    static double dot3D(Point3D a, Point3D b) {",
            "        return a.x * b.x + a.y * b.y + a.z * b.z;",
            "    }",
            "",
            "    // Cross product in 3D returns a new vector perpendicular to both",
            "    static Point3D cross3D(Point3D a, Point3D b) {",
            "        return new Point3D(",
            "            a.y * b.z - a.z * b.y,",
            "            a.z * b.x - a.x * b.z,",
            "            a.x * b.y - a.y * b.x",
            "        );",
            "    }",
            "",
            "    static double magnitude3D(Point3D p) {",
            "        return Math.sqrt(p.x * p.x + p.y * p.y + p.z * p.z);",
            "    }",
            "    $0"
        ],
        "description": "Prefix: geo3d -> 3D Distance, Dot Product, and Cross Product Vector generation"
    },
    "CP Geo: Arc Length & Chord Math": {
        "scope": "java",
        "prefix": "geoarc",
        "body": [
            "    // Requires classpoint3d and geo3d (for dist3D)",
            "    // Specific to CodeVita 60-degree arc constraint: L = (PI * d) / 3",
            "    static double beetleArcDistance(Point3D p1, Point3D p2) {",
            "        return (Math.PI * dist3D(p1, p2)) / 3.0;",
            "    }",
            "",
            "    // General Arc Length given two points (chord) and angle subtended at center in degrees",
            "    static double arcLength(Point3D p1, Point3D p2, double angleDegrees) {",
            "        double chord = dist3D(p1, p2);",
            "        if (chord < EPS) return 0.0;",
            "        double angleRad = Math.toRadians(angleDegrees);",
            "        double radius = (chord / 2.0) / Math.sin(angleRad / 2.0);",
            "        return radius * angleRad;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: geoarc -> Calculates circular arc distances from chords"
    },
    "CP Geo: 3D to 2D Surface Unfolding (Cube Nets)": {
        "scope": "java",
        "prefix": "geocubenet",
        "body": [
            "    // Maps a 3D point on the surface of a bounding box (cube) to a 2D plane.",
            "    // Assumes cube from (0,0,0) to (S,S,S).",
            "    static Point flattenTo2D(Point3D p, double S) {",
            "        // Front face (y = 0)",
            "        if (Math.abs(p.y) < EPS) return new Point(p.x, -p.z);",
            "        // Back face (y = S)",
            "        if (Math.abs(p.y - S) < EPS) return new Point(p.x, S + p.z);",
            "        // Left face (x = 0)",
            "        if (Math.abs(p.x) < EPS) return new Point(-p.y, p.z);",
            "        // Right face (x = S)",
            "        if (Math.abs(p.x - S) < EPS) return new Point(S + p.y, p.z);",
            "        // Top face (z = S)",
            "        if (Math.abs(p.z - S) < EPS) return new Point(p.x, p.y + S);",
            "        // Bottom face (z = 0) - Often forbidden in CodeVita, but mapped here",
            "        if (Math.abs(p.z) < EPS) return new Point(p.x, -p.y - S);",
            "        ",
            "        return new Point(p.x, p.y); // Fallback",
            "    }",
            "    $0"
        ],
        "description": "Prefix: geocubenet -> Unfolds 3D cube coordinates into a 2D plane"
    },
    "CP Geo: Great Circle Distance (Spherical Math)": {
        "scope": "java",
        "prefix": "geosphere",
        "body": [
            "    // Calculates shortest distance between two points on the surface of a sphere",
            "    // lat/lon must be in degrees",
            "    static double greatCircleDist(double lat1, double lon1, double lat2, double lon2, double radius) {",
            "        double rLat1 = Math.toRadians(lat1);",
            "        double rLat2 = Math.toRadians(lat2);",
            "        double dLat = Math.toRadians(lat2 - lat1);",
            "        double dLon = Math.toRadians(lon2 - lon1);",
            "",
            "        double a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +",
            "                   Math.cos(rLat1) * Math.cos(rLat2) * ",
            "                   Math.sin(dLon / 2) * Math.sin(dLon / 2);",
            "        double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));",
            "        return radius * c;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: geosphere -> Haversine formula for shortest path on a sphere's surface"
    }
}