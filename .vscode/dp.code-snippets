{
    "CP DP: Digit DP Template": {
        "scope": "java",
        "prefix": "dpdigit",
        "body": [
            "    static class DigitDP {",
            "        static Long[][][] memo;",
            "        static char[] num;",
            "        ",
            "        // Call this as: solve(String.valueOf(R).toCharArray()) - solve(String.valueOf(L - 1).toCharArray())",
            "        static long solve(char[] R) {",
            "            num = R;",
            "            // State: [position][tight boolean][problem_specific_state (e.g., sum)]",
            "            memo = new Long[num.length][2][200]; ",
            "            return dp(0, 1, 0);",
            "        }",
            "",
            "        static long dp(int pos, int tight, int state) {",
            "            if (pos == num.length) return state; // Return valid condition (e.g., state == targetSum ? 1 : 0)",
            "            if (memo[pos][tight][state] != null) return memo[pos][tight][state];",
            "",
            "            int limit = (tight == 1) ? (num[pos] - '0') : 9;",
            "            long res = 0;",
            "            ",
            "            for (int d = 0; d <= limit; d++) {",
            "                int nextTight = (tight == 1 && d == limit) ? 1 : 0;",
            "                int nextState = state + d; // Problem specific logic here (e.g., counting digit occurrences)",
            "                res += dp(pos + 1, nextTight, nextState);",
            "            }",
            "            ",
            "            return memo[pos][tight][state] = res;",
            "        }",
            "    }",
            "    $0"
        ],
        "description": "Prefix: dpdigit -> O(log N) Digit Dynamic Programming for counting in massive ranges"
    },
    "CP DP: Submask Iteration O(3^N)": {
        "scope": "java",
        "prefix": "dpsubmask",
        "body": [
            "    // Used when transitioning from a mask to any of its subsets (e.g., partitioning problems)",
            "    static long solveSubmaskDP(int n, long[] subsetCost) {",
            "        long[] dp = new long[1 << n];",
            "        Arrays.fill(dp, Long.MAX_VALUE / 2);",
            "        dp[0] = 0;",
            "        ",
            "        for (int mask = 1; mask < (1 << n); mask++) {",
            "            // Iterate through all submasks of 'mask' in O(3^N) total time across all masks",
            "            for (int sub = mask; sub > 0; sub = (sub - 1) & mask) {",
            "                // Example: dp[mask] = min(dp[mask], dp[mask ^ sub] + cost[sub])",
            "                dp[mask] = Math.min(dp[mask], dp[mask ^ sub] + subsetCost[sub]);",
            "            }",
            "        }",
            "        return dp[(1 << n) - 1];",
            "    }",
            "    $0"
        ],
        "description": "Prefix: dpsubmask -> O(3^N) Bitmask DP for exact set partitioning and set covering"
    },
    "CP DP: Game Theory (Sprague-Grundy / MEX)": {
        "scope": "java",
        "prefix": "dpsprague",
        "body": [
            "    static class SpragueGrundy {",
            "        static int[] grundy;",
            "        ",
            "        static int calculateMex(Set<Integer> set) {",
            "            int mex = 0;",
            "            while (set.contains(mex)) mex++;",
            "            return mex;",
            "        }",
            "",
            "        // Populates Grundy numbers up to n.",
            "        static void buildGrundy(int n, int[] possibleMoves) {",
            "            grundy = new int[n + 1];",
            "            grundy[0] = 0; // Terminal state is usually a loss (Grundy = 0)",
            "            ",
            "            for (int state = 1; state <= n; state++) {",
            "                Set<Integer> reachableStates = new HashSet<>();",
            "                for (int move : possibleMoves) {",
            "                    if (state - move >= 0) {",
            "                        reachableStates.add(grundy[state - move]);",
            "                    }",
            "                }",
            "                grundy[state] = calculateMex(reachableStates);",
            "            }",
            "        }",
            "        ",
            "        // For multiple independent games, XOR their Grundy values.",
            "        // If final XOR sum > 0, First Player wins. If == 0, Second Player wins.",
            "    }",
            "    $0"
        ],
        "description": "Prefix: dpsprague -> Computes Nim-values (Grundy numbers) for impartial games using MEX"
    },
    "CP DP: Longest Increasing Subsequence O(N log N)": {
        "scope": "java",
        "prefix": "dplis",
        "body": [
            "    static int getLIS(int[] a) {",
            "        int n = a.length;",
            "        if (n == 0) return 0;",
            "        int[] tails = new int[n];",
            "        int size = 0;",
            "        ",
            "        for (int x : a) {",
            "            int l = 0, r = size;",
            "            while (l < r) {",
            "                int mid = l + (r - l) / 2;",
            "                if (tails[mid] < x) l = mid + 1;",
            "                else r = mid;",
            "            }",
            "            tails[l] = x;",
            "            if (l == size) size++;",
            "        }",
            "        return size;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: dplis -> O(N log N) Longest Increasing Subsequence using Binary Search and Tails array"
    },
    "CP DP: Space Optimized Knapsack": {
        "scope": "java",
        "prefix": "dpknapsack",
        "body": [
            "    static long solve01Knapsack(int maxWeight, int[] weights, long[] values) {",
            "        long[] dp = new long[maxWeight + 1];",
            "        for (int i = 0; i < weights.length; i++) {",
            "            // Traverse backwards for 0/1 Knapsack to avoid item reuse",
            "            for (int w = maxWeight; w >= weights[i]; w--) {",
            "                dp[w] = Math.max(dp[w], dp[w - weights[i]] + values[i]);",
            "            }",
            "        }",
            "        return dp[maxWeight];",
            "    }",
            "",
            "    static long solveUnboundedKnapsack(int maxWeight, int[] weights, long[] values) {",
            "        long[] dp = new long[maxWeight + 1];",
            "        for (int i = 0; i < weights.length; i++) {",
            "            // Traverse forwards for Unbounded Knapsack to allow item reuse",
            "            for (int w = weights[i]; w <= maxWeight; w++) {",
            "                dp[w] = Math.max(dp[w], dp[w - weights[i]] + values[i]);",
            "            }",
            "        }",
            "        return dp[maxWeight];",
            "    }",
            "    $0"
        ],
        "description": "Prefix: dpknapsack -> O(N * W) 0/1 and Unbounded Knapsack optimized to 1D arrays"
    },
    "CP DP: Interval DP (Matrix Chain Multiplication Pattern)": {
        "scope": "java",
        "prefix": "dpinterval",
        "body": [
            "    // Evaluates optimal cost to combine adjacent elements/intervals in an array",
            "    static long solveIntervalDP(int[] a) {",
            "        int n = a.length;",
            "        long[][] dp = new long[n][n];",
            "        ",
            "        // Base cases: intervals of length 1 are usually 0 cost or a[i]",
            "        // for (int i = 0; i < n; i++) dp[i][i] = 0;",
            "        ",
            "        for (int len = 2; len <= n; len++) {",
            "            for (int i = 0; i <= n - len; i++) {",
            "                int j = i + len - 1;",
            "                dp[i][j] = Long.MAX_VALUE;",
            "                ",
            "                for (int k = i; k < j; k++) {",
            "                    // Transition: Cost of left part + right part + cost to merge",
            "                    long cost = dp[i][k] + dp[k + 1][j] + (long) a[i] * a[k + 1] * a[j]; // Example MCM cost",
            "                    dp[i][j] = Math.min(dp[i][j], cost);",
            "                }",
            "            }",
            "        }",
            "        return dp[0][n - 1];",
            "    }",
            "    $0"
        ],
        "description": "Prefix: dpinterval -> O(N^3) DP over contiguous subarrays/intervals"
    },
    "CP DP: SOS DP (Sum Over Subsets)": {
        "scope": "java",
        "prefix": "dpsos",
        "body": [
            "    // Calculates the sum of A[x] for all x that are submasks of mask in O(N * 2^N)",
            "    static long[] solveSOS(int n, long[] a) {",
            "        int limit = 1 << n;",
            "        long[] dp = Arrays.copyOf(a, limit);",
            "        ",
            "        for (int i = 0; i < n; i++) {",
            "            for (int mask = 0; mask < limit; mask++) {",
            "                if ((mask & (1 << i)) != 0) {",
            "                    dp[mask] += dp[mask ^ (1 << i)];",
            "                }",
            "            }",
            "        }",
            "        return dp;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: dpsos -> O(N * 2^N) Highly optimized Sum Over Subsets"
    },
    "CP DP: Bitmask Job Assignment": {
        "scope": "java",
        "prefix": "dpassignment",
        "body": [
            "    // Assigns N workers to N jobs minimizing/maximizing total cost.",
            "    // costMatrix[worker][job] = cost",
            "    static long solveAssignment(int n, long[][] costMatrix) {",
            "        long[] dp = new long[1 << n];",
            "        Arrays.fill(dp, Long.MAX_VALUE);",
            "        dp[0] = 0;",
            "        ",
            "        for (int mask = 0; mask < (1 << n); mask++) {",
            "            if (dp[mask] == Long.MAX_VALUE) continue;",
            "            int worker = Integer.bitCount(mask); // Which worker we are assigning next",
            "            ",
            "            if (worker == n) continue;",
            "            ",
            "            for (int job = 0; job < n; job++) {",
            "                if ((mask & (1 << job)) == 0) {",
            "                    int nextMask = mask | (1 << job);",
            "                    dp[nextMask] = Math.min(dp[nextMask], dp[mask] + costMatrix[worker][job]);",
            "                }",
            "            }",
            "        }",
            "        return dp[(1 << n) - 1];",
            "    }",
            "    $0"
        ],
        "description": "Prefix: dpassignment -> O(N * 2^N) Job assignment/matching utilizing bitmasks"
    },
    "CP DP: 2D Kadane (Maximum Sum Submatrix)": {
        "scope": "java",
        "prefix": "dpkadane2d",
        "body": [
            "    static long maxSubmatrixSum(long[][] matrix) {",
            "        int r = matrix.length, c = matrix[0].length;",
            "        long maxSum = Long.MIN_VALUE;",
            "        ",
            "        for (int top = 0; top < r; top++) {",
            "            long[] temp = new long[c];",
            "            for (int bottom = top; bottom < r; bottom++) {",
            "                for (int col = 0; col < c; col++) {",
            "                    temp[col] += matrix[bottom][col];",
            "                }",
            "                ",
            "                // 1D Kadane on the compressed columns",
            "                long currentSum = 0;",
            "                long localMax = Long.MIN_VALUE;",
            "                for (long val : temp) {",
            "                    currentSum = Math.max(val, currentSum + val);",
            "                    localMax = Math.max(localMax, currentSum);",
            "                }",
            "                maxSum = Math.max(maxSum, localMax);",
            "            }",
            "        }",
            "        return maxSum;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: dpkadane2d -> O(R^2 * C) Maximum sum rectangle in a 2D grid"
    },
    "CP DP: Coin Change (Min Coins & Number of Ways)": {
        "scope": "java",
        "prefix": "dpcoin",
        "body": [
            "    static long minCoins(int amount, int[] coins) {",
            "        long[] dp = new long[amount + 1];",
            "        Arrays.fill(dp, Integer.MAX_VALUE);",
            "        dp[0] = 0;",
            "        for (int coin : coins) {",
            "            for (int i = coin; i <= amount; i++) {",
            "                if (dp[i - coin] != Integer.MAX_VALUE) {",
            "                    dp[i] = Math.min(dp[i], dp[i - coin] + 1);",
            "                }",
            "            }",
            "        }",
            "        return dp[amount] == Integer.MAX_VALUE ? -1 : dp[amount];",
            "    }",
            "",
            "    static long waysToMakeChange(int amount, int[] coins, long mod) {",
            "        long[] dp = new long[amount + 1];",
            "        dp[0] = 1;",
            "        for (int coin : coins) {",
            "            for (int i = coin; i <= amount; i++) {",
            "                dp[i] = (dp[i] + dp[i - coin]) % mod;",
            "            }",
            "        }",
            "        return dp[amount];",
            "    }",
            "    $0"
        ],
        "description": "Prefix: dpcoin -> O(N * Amount) Coin Change combinations and minimums"
    },
    "CP DP: Subset Sum (Boolean Space Optimized)": {
        "scope": "java",
        "prefix": "dpsubsetsum",
        "body": [
            "    static boolean canFormSum(int target, int[] a) {",
            "        boolean[] dp = new boolean[target + 1];",
            "        dp[0] = true;",
            "        for (int x : a) {",
            "            for (int i = target; i >= x; i--) {",
            "                if (dp[i - x]) dp[i] = true;",
            "            }",
            "        }",
            "        return dp[target];",
            "    }",
            "    $0"
        ],
        "description": "Prefix: dpsubsetsum -> O(N * Target) Checks if a specific subset sum is possible"
    },
    "CP DP: DP on Trees (Basic Template)": {
        "scope": "java",
        "prefix": "dptree",
        "body": [
            "    static List<List<Integer>> adj;",
            "    static long[] dpDown, dpUp; // dpDown[v] = answer for subtree of v, dpUp[v] = answer from ancestors",
            "",
            "    // Pass 1: Compute dp values going DOWN (leaves to root)",
            "    static void dfsDown(int u, int parent) {",
            "        dpDown[u] = 0; // Base case for a leaf",
            "        for (int v : adj.get(u)) {",
            "            if (v == parent) continue;",
            "            dfsDown(v, u);",
            "            dpDown[u] += dpDown[v] + 1; // Example: sum of subtree sizes",
            "        }",
            "    }",
            "",
            "    // Pass 2 (Optional Rerooting): Compute dp values going UP",
            "    static void dfsUp(int u, int parent) {",
            "        for (int v : adj.get(u)) {",
            "            if (v == parent) continue;",
            "            // dpUp[v] = contribution from parent's side",
            "            // Total answer for v as root = dpDown[v] + dpUp[v]",
            "            dpUp[v] = dpUp[u] + (dpDown[u] - dpDown[v] - 1) + 1; // Example: rerooting for sum of distances",
            "            dfsUp(v, u);",
            "        }",
            "    }",
            "",
            "    // Usage: dfsDown(0, -1); dpUp[0] = 0; dfsUp(0, -1);",
            "    // Full answer for node v as root = dpDown[v] + dpUp[v];",
            "    $0"
        ],
        "description": "Prefix: dptree -> Tree DP with optional rerooting (2-pass DFS)"
    },
    "CP DP: Profile DP / Broken Profile (Grid Tiling)": {
        "scope": "java",
        "prefix": "dpprofile",
        "body": [
            "    // Tile an M x N grid with 1x2 dominoes. M should be the smaller dimension (<= 20).",
            "    static long profileDP(int M, int N) {",
            "        int fullMask = (1 << M) - 1;",
            "        long[][] dp = new long[N + 1][1 << M];",
            "        dp[0][fullMask] = 1; // Initially all cells in column -1 are \"filled\"",
            "",
            "        for (int col = 0; col < N; col++) {",
            "            for (int mask = 0; mask <= fullMask; mask++) {",
            "                if (dp[col][mask] == 0) continue;",
            "                fillColumn(col, 0, mask, fullMask, dp, M, N);",
            "            }",
            "        }",
            "        return dp[N][fullMask];",
            "    }",
            "",
            "    static void fillColumn(int col, int row, int curMask, int fullMask, long[][] dp, int M, int N) {",
            "        if (row == M) {",
            "            dp[col + 1][curMask] += dp[col][/* original mask */0]; // Simplified; see full implementation",
            "            return;",
            "        }",
            "        if ((curMask & (1 << row)) != 0) {",
            "            // Cell already filled by horizontal domino from previous column",
            "            fillColumn(col, row + 1, curMask ^ (1 << row), fullMask, dp, M, N);",
            "        } else {",
            "            // Place horizontal domino covering (row, col) and (row, col+1)",
            "            if (col + 1 < N) {",
            "                fillColumn(col, row + 1, curMask | (1 << row), fullMask, dp, M, N);",
            "            }",
            "            // Place vertical domino covering (row, col) and (row+1, col)",
            "            if (row + 1 < M && (curMask & (1 << (row + 1))) == 0) {",
            "                fillColumn(col, row + 2, curMask, fullMask, dp, M, N);",
            "            }",
            "        }",
            "    }",
            "    $0"
        ],
        "description": "Prefix: dpprofile -> O(N * 2^M * M) Broken profile DP for grid tiling with dominoes"
    },
    "CP DP: Convex Hull Trick (Li Chao Tree)": {
        "scope": "java",
        "prefix": "dpcht",
        "body": [
            "    static class LiChaoTree {",
            "        long[] m, b; // y = m[i]*x + b[i]",
            "        int[] left, right;",
            "        int cnt = 0;",
            "        long lo, hi;",
            "        static final long INF = Long.MAX_VALUE;",
            "",
            "        LiChaoTree(long lo, long hi, int maxNodes) {",
            "            this.lo = lo; this.hi = hi;",
            "            m = new long[maxNodes]; b = new long[maxNodes];",
            "            left = new int[maxNodes]; right = new int[maxNodes];",
            "            Arrays.fill(left, -1); Arrays.fill(right, -1);",
            "            newLine(0, INF); // Identity line (always worst)",
            "        }",
            "",
            "        int newLine(long slope, long intercept) {",
            "            m[cnt] = slope; b[cnt] = intercept;",
            "            left[cnt] = right[cnt] = -1;",
            "            return cnt++;",
            "        }",
            "",
            "        long eval(int id, long x) { return m[id] * x + b[id]; }",
            "",
            "        // Insert line y = slope*x + intercept (for MINIMUM query)",
            "        void addLine(int node, long lo, long hi, long slope, long intercept) {",
            "            long mid = lo + (hi - lo) / 2;",
            "            boolean leftBetter = slope * lo + intercept < eval(node, lo);",
            "            boolean midBetter = slope * mid + intercept < eval(node, mid);",
            "",
            "            if (midBetter) {",
            "                long tmpM = m[node], tmpB = b[node];",
            "                m[node] = slope; b[node] = intercept;",
            "                slope = tmpM; intercept = tmpB;",
            "                leftBetter = !leftBetter;",
            "            }",
            "            if (lo == hi) return;",
            "            if (leftBetter) {",
            "                if (left[node] == -1) left[node] = newLine(slope, intercept);",
            "                else addLine(left[node], lo, mid, slope, intercept);",
            "            } else {",
            "                if (right[node] == -1) right[node] = newLine(slope, intercept);",
            "                else addLine(right[node], mid + 1, hi, slope, intercept);",
            "            }",
            "        }",
            "",
            "        void addLine(long slope, long intercept) { addLine(0, lo, hi, slope, intercept); }",
            "",
            "        // Query minimum y at x",
            "        long query(int node, long lo, long hi, long x) {",
            "            if (node == -1) return INF;",
            "            long mid = lo + (hi - lo) / 2;",
            "            long best = eval(node, x);",
            "            if (x <= mid) best = Math.min(best, query(left[node], lo, mid, x));",
            "            else best = Math.min(best, query(right[node], mid + 1, hi, x));",
            "            return best;",
            "        }",
            "",
            "        long query(long x) { return query(0, lo, hi, x); }",
            "    }",
            "    $0"
        ],
        "description": "Prefix: dpcht -> Li Chao Tree for Convex Hull Trick (min query over set of lines)"
    },
    "CP DP: Divide and Conquer Optimization": {
        "scope": "java",
        "prefix": "dpdnc",
        "body": [
            "    // Use when dp[i][j] = min over k in [0..j-1] of { dp[i-1][k] + cost(k+1, j) }",
            "    // and the optimal split point opt[i][j] is monotone: opt[i][j] <= opt[i][j+1]",
            "    static long[][] dp;",
            "    static int N, K;",
            "",
            "    static long cost(int l, int r) {",
            "        // Problem-specific cost function, must satisfy quadrangle inequality",
            "        return 0; // TODO: implement",
            "    }",
            "",
            "    static void solve(int layer, int lo, int hi, int optLo, int optHi) {",
            "        if (lo > hi) return;",
            "        int mid = (lo + hi) / 2;",
            "        long best = Long.MAX_VALUE;",
            "        int bestK = optLo;",
            "",
            "        for (int k = optLo; k <= Math.min(mid - 1, optHi); k++) {",
            "            long val = dp[layer - 1][k] + cost(k + 1, mid);",
            "            if (val < best) {",
            "                best = val;",
            "                bestK = k;",
            "            }",
            "        }",
            "        dp[layer][mid] = best;",
            "",
            "        solve(layer, lo, mid - 1, optLo, bestK);",
            "        solve(layer, mid + 1, hi, bestK, optHi);",
            "    }",
            "",
            "    // Usage: dp = new long[K+1][N+1]; fill base case dp[1][j]; then for i=2..K: solve(i, 1, N, 0, N-1);",
            "    $0"
        ],
        "description": "Prefix: dpdnc -> O(KN log N) DP optimization when optimal split is monotone"
    },
    "CP DP: Matrix Exponentiation for Linear Recurrences": {
        "scope": "java",
        "prefix": "dpmatexp",
        "body": [
            "    static final long MOD = 1_000_000_007;",
            "",
            "    static long[][] matMul(long[][] A, long[][] B) {",
            "        int n = A.length, m = B[0].length, k = B.length;",
            "        long[][] C = new long[n][m];",
            "        for (int i = 0; i < n; i++)",
            "            for (int j = 0; j < m; j++)",
            "                for (int p = 0; p < k; p++)",
            "                    C[i][j] = (C[i][j] + A[i][p] * B[p][j]) % MOD;",
            "        return C;",
            "    }",
            "",
            "    static long[][] matPow(long[][] M, long exp) {",
            "        int n = M.length;",
            "        long[][] result = new long[n][n];",
            "        for (int i = 0; i < n; i++) result[i][i] = 1; // Identity",
            "        while (exp > 0) {",
            "            if ((exp & 1) == 1) result = matMul(result, M);",
            "            M = matMul(M, M);",
            "            exp >>= 1;",
            "        }",
            "        return result;",
            "    }",
            "",
            "    // Example: Fibonacci F(n) in O(K^3 log N) where K = matrix size",
            "    // long[][] T = {{1, 1}, {1, 0}};  // Transition matrix",
            "    // long[][] base = {{1}, {0}};      // F(1), F(0)",
            "    // long[][] res = matMul(matPow(T, n - 1), base);",
            "    // Answer: res[0][0]",
            "    $0"
        ],
        "description": "Prefix: dpmatexp -> O(K^3 log N) Matrix exponentiation for linear recurrences"
    },
    "CP DP: Longest Palindromic Subsequence": {
        "scope": "java",
        "prefix": "dplps",
        "body": [
            "    static int longestPalindromicSubseq(String s) {",
            "        int n = s.length();",
            "        // dp[i][j] = LPS length of s[i..j]",
            "        int[][] dp = new int[n][n];",
            "        for (int i = 0; i < n; i++) dp[i][i] = 1;",
            "",
            "        for (int len = 2; len <= n; len++) {",
            "            for (int i = 0; i <= n - len; i++) {",
            "                int j = i + len - 1;",
            "                if (s.charAt(i) == s.charAt(j)) {",
            "                    dp[i][j] = dp[i + 1][j - 1] + 2;",
            "                } else {",
            "                    dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);",
            "                }",
            "            }",
            "        }",
            "        return dp[0][n - 1];",
            "    }",
            "    $0"
        ],
        "description": "Prefix: dplps -> O(N^2) Longest Palindromic Subsequence"
    },
    "CP DP: Expected Value / Probability DP": {
        "scope": "java",
        "prefix": "dpexpected",
        "body": [
            "    // Template: Expected number of steps/cost from state to goal",
            "    // E[goal] = 0, work backwards",
            "    // E[state] = 1 + sum(prob[next] * E[next]) for each reachable next state",
            "",
            "    static double expectedValueDP(int n) {",
            "        double[] E = new double[n + 1];",
            "        E[n] = 0; // Goal state",
            "",
            "        for (int state = n - 1; state >= 0; state--) {",
            "            // Example: Coupon Collector variant",
            "            // Probability of getting a new coupon when 'state' already collected: (n - state) / n",
            "            // E[state] = n / (n - state) + E[state + 1]",
            "            double probProgress = (double)(n - state) / n;",
            "            E[state] = 1.0 / probProgress + E[state + 1];",
            "        }",
            "        return E[0];",
            "    }",
            "",
            "    // For graph-based: solve system of equations or use Gaussian elimination",
            "    // E[u] = 1 + (1/deg(u)) * sum(E[v]) for neighbors v",
            "    // Rearrange: E[u] - (1/deg(u)) * sum(E[v]) = 1",
            "    $0"
        ],
        "description": "Prefix: dpexpected -> Expected value / probability DP template"
    },
    "CP DP: Longest Common Substring": {
        "scope": "java",
        "prefix": "dplcsubstr",
        "body": [
            "    static int longestCommonSubstring(String a, String b) {",
            "        int m = a.length(), n = b.length();",
            "        int[][] dp = new int[m + 1][n + 1];",
            "        int maxLen = 0;",
            "",
            "        for (int i = 1; i <= m; i++) {",
            "            for (int j = 1; j <= n; j++) {",
            "                if (a.charAt(i - 1) == b.charAt(j - 1)) {",
            "                    dp[i][j] = dp[i - 1][j - 1] + 1;",
            "                    maxLen = Math.max(maxLen, dp[i][j]);",
            "                }",
            "            }",
            "        }",
            "        return maxLen;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: dplcsubstr -> O(N*M) Longest Common Substring (contiguous)"
    },
    "CP DP: Steiner Tree (Bitmask DP on Graph)": {
        "scope": "java",
        "prefix": "dpsteiner",
        "body": [
            "    // Minimum cost to connect a set of terminal nodes in a weighted graph",
            "    // terminals: indices of required nodes, k = terminals.length (<= 15)",
            "    static long steinerTree(int n, int[][] edges, int[] terminals) {",
            "        int k = terminals.length;",
            "        int fullMask = (1 << k) - 1;",
            "        long[][] dp = new long[1 << k][n];",
            "        long INF = Long.MAX_VALUE / 2;",
            "        for (long[] row : dp) Arrays.fill(row, INF);",
            "",
            "        // Base: each terminal alone",
            "        for (int i = 0; i < k; i++) dp[1 << i][terminals[i]] = 0;",
            "",
            "        // Build adjacency list",
            "        List<List<long[]>> adj = new ArrayList<>();",
            "        for (int i = 0; i < n; i++) adj.add(new ArrayList<>());",
            "        for (int[] e : edges) {",
            "            adj.get(e[0]).add(new long[]{e[1], e[2]});",
            "            adj.get(e[1]).add(new long[]{e[0], e[2]});",
            "        }",
            "",
            "        for (int mask = 1; mask <= fullMask; mask++) {",
            "            // Merge two submasks",
            "            for (int sub = (mask - 1) & mask; sub > 0; sub = (sub - 1) & mask) {",
            "                int comp = mask ^ sub;",
            "                if (sub < comp) continue; // avoid duplicate",
            "                for (int v = 0; v < n; v++) {",
            "                    if (dp[sub][v] < INF && dp[comp][v] < INF)",
            "                        dp[mask][v] = Math.min(dp[mask][v], dp[sub][v] + dp[comp][v]);",
            "                }",
            "            }",
            "            // Shortest path relaxation (Dijkstra)",
            "            PriorityQueue<long[]> pq = new PriorityQueue<>((a, b) -> Long.compare(a[1], b[1]));",
            "            for (int v = 0; v < n; v++) if (dp[mask][v] < INF) pq.offer(new long[]{v, dp[mask][v]});",
            "            while (!pq.isEmpty()) {",
            "                long[] cur = pq.poll();",
            "                int u = (int) cur[0]; long d = cur[1];",
            "                if (d > dp[mask][u]) continue;",
            "                for (long[] e : adj.get(u)) {",
            "                    int v = (int) e[0]; long w = e[1];",
            "                    if (dp[mask][u] + w < dp[mask][v]) {",
            "                        dp[mask][v] = dp[mask][u] + w;",
            "                        pq.offer(new long[]{v, dp[mask][v]});",
            "                    }",
            "                }",
            "            }",
            "        }",
            "        long ans = INF;",
            "        for (int v = 0; v < n; v++) ans = Math.min(ans, dp[fullMask][v]);",
            "        return ans;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: dpsteiner -> O(3^K * N + 2^K * E log N) Steiner Tree connecting terminal nodes"
    },
    "CP DP: Knuth's Optimization": {
        "scope": "java",
        "prefix": "dpknuth",
        "body": [
            "    // Optimizes interval DP when cost satisfies quadrangle inequality",
            "    // Reduces O(N^3) -> O(N^2)",
            "    // Condition: cost(a,c) + cost(b,d) <= cost(a,d) + cost(b,c) for a<=b<=c<=d",
            "    static long knuthDP(int n, long[] prefix) {",
            "        long[][] dp = new long[n][n];",
            "        int[][] opt = new int[n][n]; // optimal split point",
            "",
            "        // Base case: length 1",
            "        for (int i = 0; i < n; i++) { dp[i][i] = 0; opt[i][i] = i; }",
            "",
            "        for (int len = 2; len <= n; len++) {",
            "            for (int i = 0; i <= n - len; i++) {",
            "                int j = i + len - 1;",
            "                dp[i][j] = Long.MAX_VALUE;",
            "                // Knuth's optimization: opt[i][j-1] <= opt[i][j] <= opt[i+1][j]",
            "                int lo = opt[i][j - 1], hi = (j + 1 < n) ? opt[i + 1][j] : j - 1;",
            "                for (int k = lo; k <= Math.min(hi, j - 1); k++) {",
            "                    long cost = dp[i][k] + dp[k + 1][j] + (prefix[j + 1] - prefix[i]);",
            "                    if (cost < dp[i][j]) {",
            "                        dp[i][j] = cost;",
            "                        opt[i][j] = k;",
            "                    }",
            "                }",
            "            }",
            "        }",
            "        return dp[0][n - 1];",
            "    }",
            "    $0"
        ],
        "description": "Prefix: dpknuth -> O(N^2) Knuth's optimization for interval DP with quadrangle inequality"
    }
}