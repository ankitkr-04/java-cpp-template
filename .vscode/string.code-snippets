{
    "CP String: Frequency Array (a-z)": {
        "scope": "java",
        "prefix": "strfreq",
        "body": [
            "    static int[] getFreq(String s) {",
            "        int[] freq = new int[26];",
            "        for (char c : s.toCharArray()) {",
            "            freq[c - 'a']++;",
            "        }",
            "        return freq;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: strfreq -> O(N) Converts lowercase string to int[26] frequency map"
    },
    "CP String: Edit Distance (Levenshtein)": {
        "scope": "java",
        "prefix": "streditdist",
        "body": [
            "    static int editDistance(String s1, String s2) {",
            "        int m = s1.length(), n = s2.length();",
            "        int[][] dp = new int[m + 1][n + 1];",
            "        for (int i = 0; i <= m; i++) {",
            "            for (int j = 0; j <= n; j++) {",
            "                if (i == 0) dp[i][j] = j; // Min operations is inserting all characters of s2",
            "                else if (j == 0) dp[i][j] = i; // Min operations is removing all characters of s1",
            "                else if (s1.charAt(i - 1) == s2.charAt(j - 1)) dp[i][j] = dp[i - 1][j - 1];",
            "                else dp[i][j] = 1 + Math.min(dp[i][j - 1], ",
            "                                    Math.min(dp[i - 1][j], dp[i - 1][j - 1]));",
            "            }",
            "        }",
            "        return dp[m][n];",
            "    }",
            "    $0"
        ],
        "description": "Prefix: streditdist -> O(N*M) Min operations (insert, delete, replace) to match strings"
    },
    "CP String: Longest Common Subsequence (LCS)": {
        "scope": "java",
        "prefix": "strlcs",
        "body": [
            "    static int lcs(String s1, String s2) {",
            "        int m = s1.length(), n = s2.length();",
            "        int[][] dp = new int[m + 1][n + 1];",
            "        for (int i = 1; i <= m; i++) {",
            "            for (int j = 1; j <= n; j++) {",
            "                if (s1.charAt(i - 1) == s2.charAt(j - 1)) {",
            "                    dp[i][j] = dp[i - 1][j - 1] + 1;",
            "                } else {",
            "                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);",
            "                }",
            "            }",
            "        }",
            "        return dp[m][n];",
            "    }",
            "    $0"
        ],
        "description": "Prefix: strlcs -> O(N*M) Finds the length of the Longest Common Subsequence"
    },
    "CP String: Minimal String Rotation (Booth's Algo)": {
        "scope": "java",
        "prefix": "strminrot",
        "body": [
            "    // Returns the starting index of the lexicographically smallest rotation of S in O(N)",
            "    static int minRotation(String s) {",
            "        s += s;",
            "        int n = s.length();",
            "        int[] f = new int[n];",
            "        Arrays.fill(f, -1);",
            "        int k = 0;",
            "        for (int j = 1; j < n; j++) {",
            "            char sj = s.charAt(j);",
            "            int i = f[j - k - 1];",
            "            while (i != -1 && sj != s.charAt(k + i + 1)) {",
            "                if (sj < s.charAt(k + i + 1)) k = j - i - 1;",
            "                i = f[i];",
            "            }",
            "            if (sj != s.charAt(k + i + 1)) {",
            "                if (sj < s.charAt(k)) k = j;",
            "                f[j - k] = -1;",
            "            } else {",
            "                f[j - k] = i + 1;",
            "            }",
            "        }",
            "        return k;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: strminrot -> O(N) Finds starting index of alphabetically smallest string rotation"
    },
    "CP String: Rolling Hash (O(1) Substring Compare)": {
        "scope": "java",
        "prefix": "strhash",
        "body": [
            "    static class StringHash {",
            "        long[] h, p;",
            "        long mod = (long) 1e9 + 7, base = 31;",
            "        StringHash(String s) {",
            "            int n = s.length();",
            "            h = new long[n + 1];",
            "            p = new long[n + 1];",
            "            p[0] = 1;",
            "            for (int i = 0; i < n; i++) {",
            "                p[i + 1] = (p[i] * base) % mod;",
            "                h[i + 1] = (h[i] * base + (s.charAt(i) - 'a' + 1)) % mod;",
            "            }",
            "        }",
            "        // 0-indexed, inclusive bounds [l, r]",
            "        long getHash(int l, int r) {",
            "            return (h[r + 1] - (h[l] * p[r - l + 1]) % mod + mod) % mod;",
            "        }",
            "    }",
            "    $0"
        ],
        "description": "Prefix: strhash -> Rabin-Karp Rolling Hash for O(1) Substring Equality / Palindrome checks"
    },
    "CP String: KMP Prefix Function (Pi Array)": {
        "scope": "java",
        "prefix": "strkmp",
        "body": [
            "    // pi[i] is the length of the longest proper prefix of s[0..i] ",
            "    // which is also a suffix of s[0..i].",
            "    static int[] prefixFunction(String s) {",
            "        int n = s.length();",
            "        int[] pi = new int[n];",
            "        for (int i = 1; i < n; i++) {",
            "            int j = pi[i - 1];",
            "            while (j > 0 && s.charAt(i) != s.charAt(j)) j = pi[j - 1];",
            "            if (s.charAt(i) == s.charAt(j)) j++;",
            "            pi[i] = j;",
            "        }",
            "        return pi;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: strkmp -> Knuth-Morris-Pratt Pi Array for O(N) pattern matching"
    },
    "CP String: Z-Function": {
        "scope": "java",
        "prefix": "strzfunc",
        "body": [
            "    // z[i] is the length of the longest common prefix between s and the suffix of s starting at i.",
            "    static int[] zFunction(String s) {",
            "        int n = s.length();",
            "        int[] z = new int[n];",
            "        for (int i = 1, l = 0, r = 0; i < n; i++) {",
            "            if (i <= r) z[i] = Math.min(r - i + 1, z[i - l]);",
            "            while (i + z[i] < n && s.charAt(z[i]) == s.charAt(i + z[i])) z[i]++;",
            "            if (i + z[i] - 1 > r) { l = i; r = i + z[i] - 1; }",
            "        }",
            "        return z;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: strzfunc -> Z-Array for exact substring matches in O(N)"
    },
    "CP String: Manacher's Algorithm (Longest Palindrome)": {
        "scope": "java",
        "prefix": "strmanacher",
        "body": [
            "    // Finds all sub-palindromes in O(N). ",
            "    // The max length of a palindrome centered at index i is p[i].",
            "    static int[] manacher(String s) {",
            "        StringBuilder t = new StringBuilder(\"^#\");",
            "        for (char c : s.toCharArray()) t.append(c).append(\"#\");",
            "        t.append(\"$\");",
            "        int n = t.length(), c = 0, r = 0;",
            "        int[] p = new int[n];",
            "        for (int i = 1; i < n - 1; i++) {",
            "            int mirror = c - (i - c);",
            "            if (r > i) p[i] = Math.min(r - i, p[mirror]);",
            "            while (t.charAt(i + 1 + p[i]) == t.charAt(i - 1 - p[i])) p[i]++;",
            "            if (i + p[i] > r) { c = i; r = i + p[i]; }",
            "        }",
            "        return p;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: strmanacher -> O(N) Palindrome finding. Handles both odd/even lengths safely."
    },
    "CP String: Suffix Array (O(N log^2 N))": {
        "scope": "java",
        "prefix": "strsuffixarray",
        "body": [
            "    static Integer[] buildSuffixArray(String s) {",
            "        int n = s.length();",
            "        Integer[] p = new Integer[n];",
            "        int[] c = new int[n];",
            "        for (int i = 0; i < n; i++) { p[i] = i; c[i] = s.charAt(i); }",
            "        ",
            "        for (int k = 0; (1 << k) < n || k == 0; k++) {",
            "            int len = 1 << k;",
            "            int[] prevC = c.clone();",
            "            Arrays.sort(p, (a, b) -> {",
            "                if (prevC[a] != prevC[b]) return Integer.compare(prevC[a], prevC[b]);",
            "                int rankA = a + len < n ? prevC[a + len] : -1;",
            "                int rankB = b + len < n ? prevC[b + len] : -1;",
            "                return Integer.compare(rankA, rankB);",
            "            });",
            "            c[p[0]] = 0;",
            "            for (int i = 1; i < n; i++) {",
            "                int curr1 = prevC[p[i]], curr2 = p[i] + len < n ? prevC[p[i] + len] : -1;",
            "                int prev1 = prevC[p[i - 1]], prev2 = p[i - 1] + len < n ? prevC[p[i - 1] + len] : -1;",
            "                c[p[i]] = c[p[i - 1]] + (curr1 == prev1 && curr2 == prev2 ? 0 : 1);",
            "            }",
            "        }",
            "        return p;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: strsuffixarray -> Sorts all suffixes of a string lexicographically"
    },
    "CP String: Math Expression Parser / Evaluator": {
        "scope": "java",
        "prefix": "streval",
        "body": [
            "    // Evaluates strings like \"3 + 5 * (2 - 8)\". Handles precedence automatically.",
            "    static double evalExpression(String expression) {",
            "        return new Object() {",
            "            int pos = -1, ch;",
            "            void nextChar() { ch = (++pos < expression.length()) ? expression.charAt(pos) : -1; }",
            "            boolean eat(int charToEat) {",
            "                while (ch == ' ') nextChar();",
            "                if (ch == charToEat) { nextChar(); return true; }",
            "                return false;",
            "            }",
            "            double parse() {",
            "                nextChar();",
            "                double x = parseExpression();",
            "                if (pos < expression.length()) throw new RuntimeException(\"Unexpected: \" + (char)ch);",
            "                return x;",
            "            }",
            "            double parseExpression() {",
            "                double x = parseTerm();",
            "                for (;;) {",
            "                    if (eat('+')) x += parseTerm();",
            "                    else if (eat('-')) x -= parseTerm();",
            "                    else return x;",
            "                }",
            "            }",
            "            double parseTerm() {",
            "                double x = parseFactor();",
            "                for (;;) {",
            "                    if (eat('*')) x *= parseFactor();",
            "                    else if (eat('/')) x /= parseFactor();",
            "                    else return x;",
            "                }",
            "            }",
            "            double parseFactor() {",
            "                if (eat('+')) return parseFactor();",
            "                if (eat('-')) return -parseFactor();",
            "                double x;",
            "                int startPos = this.pos;",
            "                if (eat('(')) {",
            "                    x = parseExpression();",
            "                    eat(')');",
            "                } else if ((ch >= '0' && ch <= '9') || ch == '.') {",
            "                    while ((ch >= '0' && ch <= '9') || ch == '.') nextChar();",
            "                    x = Double.parseDouble(expression.substring(startPos, this.pos));",
            "                } else throw new RuntimeException(\"Unexpected: \" + (char)ch);",
            "                return x;",
            "            }",
            "        }.parse();",
            "    }",
            "    $0"
        ],
        "description": "Prefix: streval -> Recursive Descent Parser for evaluating math string equations"
    },
    "CP String: Kasai's Algorithm (LCP Array for Suffix Array)": {
        "scope": "java",
        "prefix": "strkasai",
        "body": [
            "    // Requires the Suffix Array 'p'. Returns the Longest Common Prefix array of adjacent suffixes.",
            "    static int[] buildLCP(String s, Integer[] p) {",
            "        int n = s.length();",
            "        int[] rank = new int[n];",
            "        for (int i = 0; i < n; i++) rank[p[i]] = i;",
            "        int[] lcp = new int[n - 1];",
            "        ",
            "        for (int i = 0, h = 0; i < n; i++) {",
            "            if (rank[i] < n - 1) {",
            "                int j = p[rank[i] + 1];",
            "                while (Math.max(i, j) + h < n && s.charAt(i + h) == s.charAt(j + h)) h++;",
            "                lcp[rank[i]] = h;",
            "                if (h > 0) h--;",
            "            }",
            "        }",
            "        return lcp;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: strkasai -> O(N) Kasai's Algorithm to build the LCP array. Crucial for advanced substring logic."
    },
    "CP String: Double Rolling Hash (Anti-Collision)": {
        "scope": "java",
        "prefix": "strdoublehash",
        "body": [
            "    static class DoubleHash {",
            "        long[] h1, h2, p1, p2;",
            "        long mod1 = (long) 1e9 + 7, mod2 = (long) 1e9 + 9;",
            "        long base1 = 31, base2 = 37;",
            "        ",
            "        DoubleHash(String s) {",
            "            int n = s.length();",
            "            h1 = new long[n + 1]; h2 = new long[n + 1];",
            "            p1 = new long[n + 1]; p2 = new long[n + 1];",
            "            p1[0] = 1; p2[0] = 1;",
            "            ",
            "            for (int i = 0; i < n; i++) {",
            "                p1[i + 1] = (p1[i] * base1) % mod1;",
            "                p2[i + 1] = (p2[i] * base2) % mod2;",
            "                h1[i + 1] = (h1[i] * base1 + (s.charAt(i) - 'a' + 1)) % mod1;",
            "                h2[i + 1] = (h2[i] * base2 + (s.charAt(i) - 'a' + 1)) % mod2;",
            "            }",
            "        }",
            "        ",
            "        // 0-indexed, inclusive bounds [l, r]. Returns a unified 64-bit hash.",
            "        long getHash(int l, int r) {",
            "            long hash1 = (h1[r + 1] - (h1[l] * p1[r - l + 1]) % mod1 + mod1) % mod1;",
            "            long hash2 = (h2[r + 1] - (h2[l] * p2[r - l + 1]) % mod2 + mod2) % mod2;",
            "            return (hash1 << 32) | hash2;",
            "        }",
            "    }",
            "    $0"
        ],
        "description": "Prefix: strdoublehash -> O(1) Substring comparison using two primes to virtually eliminate collision chances."
    },
    "CP String: KMP Search (Pattern Matching Loop)": {
        "scope": "java",
        "prefix": "strkmpsearch",
        "body": [
            "    // Requires: prefixFunction (strkmp snippet)",
            "    static List<Integer> kmpSearch(String text, String pattern) {",
            "        List<Integer> occurrences = new ArrayList<>();",
            "        int[] pi = prefixFunction(pattern);",
            "        int n = text.length(), m = pattern.length();",
            "        int j = 0;",
            "        ",
            "        for (int i = 0; i < n; i++) {",
            "            while (j > 0 && text.charAt(i) != pattern.charAt(j)) j = pi[j - 1];",
            "            if (text.charAt(i) == pattern.charAt(j)) j++;",
            "            if (j == m) {",
            "                occurrences.add(i - m + 1); // 0-indexed starting position of match",
            "                j = pi[j - 1];",
            "            }",
            "        }",
            "        return occurrences;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: strkmpsearch -> O(N+M) Exact sub-string matching loop utilizing the Pi array."
    },
    "CP String: 2D Rolling Hash (Grid Pattern Matching)": {
        "scope": "java",
        "prefix": "strhash2d",
        "body": [
            "    static class Hash2D {",
            "        long[][] h, pR, pC;",
            "        long mod = (long) 1e9 + 7, baseR = 31, baseC = 37;",
            "        ",
            "        Hash2D(String[] grid) {",
            "            int r = grid.length, c = grid[0].length();",
            "            h = new long[r + 1][c + 1];",
            "            pR = new long[r + 1][c + 1];",
            "            pC = new long[r + 1][c + 1];",
            "            ",
            "            pR[0][0] = 1; pC[0][0] = 1;",
            "            for (int i = 0; i < r; i++) {",
            "                for (int j = 0; j < c; j++) {",
            "                    long val = grid[i].charAt(j) - 'a' + 1;",
            "                    h[i + 1][j + 1] = (h[i][j + 1] * baseR + h[i + 1][j] * baseC - (h[i][j] * baseR * baseC % mod) + val + mod) % mod;",
            "                    // Precompute powers if necessary for specific subgrid extractions",
            "                }",
            "            }",
            "        }",
            "        // Exact query logic requires careful base multiplication based on rectangle dimensions",
            "    }",
            "    $0"
        ],
        "description": "Prefix: strhash2d -> 2D Matrix Hashing. Essential for finding a small 2D pattern within a massive 2D grid."
    },
    "CP String: Aho-Corasick (Multi-Pattern String Search)": {
        "scope": "java",
        "prefix": "strahocorasick",
        "body": [
            "    static class AhoCorasick {",
            "        static final int K = 26;",
            "        static class Node {",
            "            int[] next = new int[K];",
            "            int fail = -1;",
            "            List<Integer> output = new ArrayList<>();",
            "            Node() { Arrays.fill(next, -1); }",
            "        }",
            "        ",
            "        List<Node> trie = new ArrayList<>();",
            "        ",
            "        AhoCorasick() { trie.add(new Node()); }",
            "        ",
            "        void insert(String s, int patternIndex) {",
            "            int v = 0;",
            "            for (char ch : s.toCharArray()) {",
            "                int c = ch - 'a';",
            "                if (trie.get(v).next[c] == -1) {",
            "                    trie.get(v).next[c] = trie.size();",
            "                    trie.add(new Node());",
            "                }",
            "                v = trie.get(v).next[c];",
            "            }",
            "            trie.get(v).output.add(patternIndex);",
            "        }",
            "        ",
            "        void build() {",
            "            Queue<Integer> q = new ArrayDeque<>();",
            "            trie.get(0).fail = 0;",
            "            for (int c = 0; c < K; c++) {",
            "                if (trie.get(0).next[c] != -1) {",
            "                    trie.get(trie.get(0).next[c]).fail = 0;",
            "                    q.add(trie.get(0).next[c]);",
            "                } else {",
            "                    trie.get(0).next[c] = 0;",
            "                }",
            "            }",
            "            while (!q.isEmpty()) {",
            "                int u = q.poll();",
            "                for (int c = 0; c < K; c++) {",
            "                    int v = trie.get(u).next[c];",
            "                    if (v != -1) {",
            "                        trie.get(v).fail = trie.get(trie.get(u).fail).next[c];",
            "                        trie.get(v).output.addAll(trie.get(trie.get(v).fail).output);",
            "                        q.add(v);",
            "                    } else {",
            "                        trie.get(u).next[c] = trie.get(trie.get(u).fail).next[c];",
            "                    }",
            "                }",
            "            }",
            "        }",
            "    }",
            "    $0"
        ],
        "description": "Prefix: strahocorasick -> O(N + M + Matches) Finds multiple string patterns simultaneously in a text."
    }
}