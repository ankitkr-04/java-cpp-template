{
    "CP Queue: Monotonic Deque (Sliding Window Max/Min)": {
        "scope": "java",
        "prefix": "queuemono",
        "body": [
            "    static class SlidingWindow {",
            "        // Returns an array of size (N - K + 1) containing the max of each window of size K.",
            "        static long[] maxSlidingWindow(long[] a, int k) {",
            "            int n = a.length;",
            "            if (n == 0 || k == 0) return new long[0];",
            "            long[] res = new long[n - k + 1];",
            "            int[] dq = new int[n]; // Store indices",
            "            int head = 0, tail = -1;",
            "            ",
            "            for (int i = 0; i < n; i++) {",
            "                // 1. Purge elements out of the current window",
            "                if (head <= tail && dq[head] < i - k + 1) head++;",
            "                ",
            "                // 2. Maintain monotonicity (decreasing for Max)",
            "                while (head <= tail && a[dq[tail]] <= a[i]) tail--;",
            "                ",
            "                // 3. Add current element",
            "                dq[++tail] = i;",
            "                ",
            "                // 4. Extract answer for current window",
            "                if (i >= k - 1) res[i - k + 1] = a[dq[head]];",
            "            }",
            "            return res;",
            "        }",
            "",
            "        static long[] minSlidingWindow(long[] a, int k) {",
            "            int n = a.length;",
            "            if (n == 0 || k == 0) return new long[0];",
            "            long[] res = new long[n - k + 1];",
            "            int[] dq = new int[n]; ",
            "            int head = 0, tail = -1;",
            "            ",
            "            for (int i = 0; i < n; i++) {",
            "                if (head <= tail && dq[head] < i - k + 1) head++;",
            "                while (head <= tail && a[dq[tail]] >= a[i]) tail--; // Increasing for Min",
            "                dq[++tail] = i;",
            "                if (i >= k - 1) res[i - k + 1] = a[dq[head]];",
            "            }",
            "            return res;",
            "        }",
            "    }",
            "    $0"
        ],
        "description": "Prefix: queuemono -> O(N) Array-backed Deque for sliding window extrema"
    },
    "CP Queue: 2D Grid BFS (Matrix Maneuvering)": {
        "scope": "java",
        "prefix": "queuegridbfs",
        "body": [
            "    static class GridBFS {",
            "        static final int[] dr = {-1, 1, 0, 0}; // Up, Down, Left, Right",
            "        static final int[] dc = {0, 0, -1, 1};",
            "        ",
            "        static int[][] getDistances(char[][] grid, int sr, int sc) {",
            "            int r = grid.length, c = grid[0].length;",
            "            int[][] dist = new int[r][c];",
            "            for (int[] row : dist) Arrays.fill(row, -1);",
            "            ",
            "            int[] q = new int[r * c];",
            "            int head = 0, tail = 0;",
            "            ",
            "            dist[sr][sc] = 0;",
            "            q[tail++] = sr * c + sc; // Flatten 2D coordinate to 1D integer",
            "            ",
            "            while (head < tail) {",
            "                int curr = q[head++];",
            "                int currR = curr / c, currC = curr % c;",
            "                ",
            "                for (int i = 0; i < 4; i++) {",
            "                    int nr = currR + dr[i];",
            "                    int nc = currC + dc[i];",
            "                    ",
            "                    // Bounds check and obstacle check (e.g., '#' is a wall)",
            "                    if (nr >= 0 && nr < r && nc >= 0 && nc < c && grid[nr][nc] != '#' && dist[nr][nc] == -1) {",
            "                        dist[nr][nc] = dist[currR][currC] + 1;",
            "                        q[tail++] = nr * c + nc;",
            "                    }",
            "                }",
            "            }",
            "            return dist;",
            "        }",
            "    }",
            "    $0"
        ],
        "description": "Prefix: queuegridbfs -> O(R*C) Array-backed queue for incredibly fast 2D grid pathfinding"
    },
    "CP Queue: Ultra-Fast Primitive Int Queue": {
        "scope": "java",
        "prefix": "queueint",
        "body": [
            "    static class IntQueue {",
            "        int[] q;",
            "        int head, tail;",
            "        IntQueue(int capacity) {",
            "            q = new int[capacity];",
            "            head = 0; tail = 0;",
            "        }",
            "        void enqueue(int val) { q[tail++] = val; }",
            "        int dequeue() { return q[head++]; }",
            "        int peek() { return q[head]; }",
            "        boolean isEmpty() { return head == tail; }",
            "        int size() { return tail - head; }",
            "        void clear() { head = tail = 0; }",
            "    }",
            "    $0"
        ],
        "description": "Prefix: queueint -> O(1) Zero-overhead primitive integer queue"
    },
    "CP Queue: Ultra-Fast Primitive Deque": {
        "scope": "java",
        "prefix": "queuedeque",
        "body": [
            "    // Array-backed double-ended queue. Shifted to the middle to allow addFirst and addLast.",
            "    static class IntDeque {",
            "        int[] q;",
            "        int head, tail;",
            "        IntDeque(int maxOperations) {",
            "            q = new int[maxOperations * 2 + 1];",
            "            head = maxOperations; tail = maxOperations;",
            "        }",
            "        void addLast(int val) { q[tail++] = val; }",
            "        void addFirst(int val) { q[--head] = val; }",
            "        int removeFirst() { return q[head++]; }",
            "        int removeLast() { return q[--tail]; }",
            "        int peekFirst() { return q[head]; }",
            "        int peekLast() { return q[tail - 1]; }",
            "        boolean isEmpty() { return head == tail; }",
            "        int size() { return tail - head; }",
            "    }",
            "    $0"
        ],
        "description": "Prefix: queuedeque -> O(1) Primitive Deque, essential for 0-1 BFS"
    },
    "CP Queue: Circular Queue": {
        "scope": "java",
        "prefix": "queuecircular",
        "body": [
            "    static class CircularQueue {",
            "        int[] q;",
            "        int head, tail, size, capacity;",
            "        CircularQueue(int k) {",
            "            capacity = k;",
            "            q = new int[k];",
            "            head = 0; tail = 0; size = 0;",
            "        }",
            "        boolean enqueue(int val) {",
            "            if (size == capacity) return false;",
            "            q[tail] = val;",
            "            tail = (tail + 1) % capacity;",
            "            size++;",
            "            return true;",
            "        }",
            "        int dequeue() {",
            "            if (size == 0) return -1;",
            "            int val = q[head];",
            "            head = (head + 1) % capacity;",
            "            size--;",
            "            return val;",
            "        }",
            "        boolean isEmpty() { return size == 0; }",
            "        boolean isFull() { return size == capacity; }",
            "    }",
            "    $0"
        ],
        "description": "Prefix: queuecircular -> O(1) Memory-constrained circular array queue"
    },
    "CP Queue: Priority Queue Boilerplate (Min/Max/Custom)": {
        "scope": "java",
        "prefix": "queuepq",
        "body": [
            "    // Min-Heap (Default)",
            "    PriorityQueue<Long> minPQ = new PriorityQueue<>();",
            "    ",
            "    // Max-Heap",
            "    PriorityQueue<Long> maxPQ = new PriorityQueue<>(Collections.reverseOrder());",
            "    ",
            "    // Custom Object Min-Heap (e.g., sorting by distance [node, distance])",
            "    PriorityQueue<int[]> customPQ = new PriorityQueue<>(Comparator.comparingInt(a -> a[1]));",
            "    ",
            "    // Custom Object Max-Heap",
            "    PriorityQueue<int[]> customMaxPQ = new PriorityQueue<>((a, b) -> Integer.compare(b[1], a[1]));",
            "    $0"
        ],
        "description": "Prefix: queuepq -> Boilerplate for Min/Max and custom Priority Queues"
    },
    "CP Queue: Multi-Source Grid BFS (Rotting Oranges)": {
        "scope": "java",
        "prefix": "queuemultisource",
        "body": [
            "    static int[][] multiSourceGridBfs(int r, int c, List<int[]> sources) {",
            "        int[][] dist = new int[r][c];",
            "        for (int[] row : dist) Arrays.fill(row, -1);",
            "        ",
            "        int[] q = new int[r * c];",
            "        int head = 0, tail = 0;",
            "        ",
            "        // Enqueue all sources",
            "        for (int[] src : sources) {",
            "            int sr = src[0], sc = src[1];",
            "            dist[sr][sc] = 0;",
            "            q[tail++] = sr * c + sc;",
            "        }",
            "        ",
            "        int[] dr = {-1, 1, 0, 0};",
            "        int[] dc = {0, 0, -1, 1};",
            "        ",
            "        while (head < tail) {",
            "            int curr = q[head++];",
            "            int currR = curr / c, currC = curr % c;",
            "            ",
            "            for (int i = 0; i < 4; i++) {",
            "                int nr = currR + dr[i], nc = currC + dc[i];",
            "                if (nr >= 0 && nr < r && nc >= 0 && nc < c && dist[nr][nc] == -1) {",
            "                    dist[nr][nc] = dist[currR][currC] + 1;",
            "                    q[tail++] = nr * c + nc;",
            "                }",
            "            }",
            "        }",
            "        return dist;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: queuemultisource -> O(R*C) Fast simultaneous BFS from multiple starting points"
    },
    "CP Queue: Grid 0-1 BFS (Obstacle Breaking / Free Moves)": {
        "scope": "java",
        "prefix": "queue01bfsgrid",
        "body": [
            "    // Use when moving to an empty cell costs 0, but breaking a wall/moving to a special cell costs 1",
            "    static int[][] bfs01Grid(char[][] grid, int sr, int sc) {",
            "        int r = grid.length, c = grid[0].length;",
            "        int[][] dist = new int[r][c];",
            "        for (int[] row : dist) Arrays.fill(row, Integer.MAX_VALUE);",
            "        ",
            "        Deque<Integer> dq = new ArrayDeque<>();",
            "        dist[sr][sc] = 0;",
            "        dq.addFirst(sr * c + sc);",
            "        ",
            "        int[] dr = {-1, 1, 0, 0}, dc = {0, 0, -1, 1};",
            "        ",
            "        while (!dq.isEmpty()) {",
            "            int curr = dq.pollFirst();",
            "            int currR = curr / c, currC = curr % c;",
            "            ",
            "            for (int i = 0; i < 4; i++) {",
            "                int nr = currR + dr[i], nc = currC + dc[i];",
            "                if (nr >= 0 && nr < r && nc >= 0 && nc < c) {",
            "                    int weight = (grid[nr][nc] == '#') ? 1 : 0; // Example condition",
            "                    if (dist[currR][currC] + weight < dist[nr][nc]) {",
            "                        dist[nr][nc] = dist[currR][currC] + weight;",
            "                        if (weight == 0) dq.addFirst(nr * c + nc);",
            "                        else dq.addLast(nr * c + nc);",
            "                    }",
            "                }",
            "            }",
            "        }",
            "        return dist;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: queue01bfsgrid -> O(R*C) Fast shortest path for 2D grids with strictly 0 or 1 edge costs"
    },
    "CP Queue: Level-Order BFS (Step-by-Step Processing)": {
        "scope": "java",
        "prefix": "queuelevel",
        "body": [
            "    // Process graph or grid exactly level by level (useful for step-based simulations)",
            "    static void levelOrderBfs(int startNode, List<Integer>[] adj) {",
            "        Queue<Integer> q = new ArrayDeque<>();",
            "        boolean[] vis = new boolean[adj.length];",
            "        ",
            "        q.add(startNode);",
            "        vis[startNode] = true;",
            "        int level = 0;",
            "        ",
            "        while (!q.isEmpty()) {",
            "            int size = q.size();",
            "            // Process all nodes at the current level",
            "            for (int i = 0; i < size; i++) {",
            "                int u = q.poll();",
            "                // process(u, level);",
            "                ",
            "                for (int v : adj[u]) {",
            "                    if (!vis[v]) {",
            "                        vis[v] = true;",
            "                        q.add(v);",
            "                    }",
            "                }",
            "            }",
            "            level++;",
            "        }",
            "    }",
            "    $0"
        ],
        "description": "Prefix: queuelevel -> O(V+E) BFS that tracks exact depth/levels explicitly"
    },
    "CP Queue: State-Space BFS (Bitmask/Keys in Grid)": {
        "scope": "java",
        "prefix": "queuestate",
        "body": [
            "    // Used when pathfinding requires collecting keys (a, b, c) to open doors (A, B, C)",
            "    static int stateSpaceBfs(char[][] grid, int sr, int sc, int targetR, int targetC) {",
            "        int r = grid.length, c = grid[0].length;",
            "        // visited[row][col][bitmask of keys held]",
            "        boolean[][][] vis = new boolean[r][c][1 << 6]; // Assume up to 6 keys (a-f)",
            "        ",
            "        // Queue stores: {row, col, keys_mask, distance}",
            "        Queue<int[]> q = new ArrayDeque<>();",
            "        q.add(new int[]{sr, sc, 0, 0});",
            "        vis[sr][sc][0] = true;",
            "        ",
            "        int[] dr = {-1, 1, 0, 0}, dc = {0, 0, -1, 1};",
            "        ",
            "        while (!q.isEmpty()) {",
            "            int[] curr = q.poll();",
            "            int currR = curr[0], currC = curr[1], mask = curr[2], dist = curr[3];",
            "            ",
            "            if (currR == targetR && currC == targetC) return dist;",
            "            ",
            "            for (int i = 0; i < 4; i++) {",
            "                int nr = currR + dr[i], nc = currC + dc[i];",
            "                if (nr >= 0 && nr < r && nc >= 0 && nc < c && grid[nr][nc] != '#') {",
            "                    char cell = grid[nr][nc];",
            "                    int nextMask = mask;",
            "                    ",
            "                    // If it's a key, pick it up",
            "                    if (cell >= 'a' && cell <= 'z') nextMask |= (1 << (cell - 'a'));",
            "                    ",
            "                    // If it's a door, check if we have the corresponding key",
            "                    if (cell >= 'A' && cell <= 'Z' && (mask & (1 << (cell - 'A'))) == 0) continue;",
            "                    ",
            "                    if (!vis[nr][nc][nextMask]) {",
            "                        vis[nr][nc][nextMask] = true;",
            "                        q.add(new int[]{nr, nc, nextMask, dist + 1});",
            "                    }",
            "                }",
            "            }",
            "        }",
            "        return -1; // Unreachable",
            "    }",
            "    $0"
        ],
        "description": "Prefix: queuestate -> O(R*C*2^K) Advanced BFS storing state constraints (e.g., bitmask of keys) alongside coordinates"
    },
    "CP Queue: Grid Dijkstra (PQ on Matrix)": {
        "scope": "java",
        "prefix": "queuedijkstragrid",
        "body": [
            "    static long[][] dijkstraGrid(int[][] costMatrix, int sr, int sc) {",
            "        int r = costMatrix.length, c = costMatrix[0].length;",
            "        long[][] dist = new long[r][c];",
            "        for (long[] row : dist) Arrays.fill(row, Long.MAX_VALUE);",
            "        ",
            "        // PQ stores: {row, col, accumulated_cost}",
            "        PriorityQueue<long[]> pq = new PriorityQueue<>(Comparator.comparingLong(a -> a[2]));",
            "        ",
            "        dist[sr][sc] = costMatrix[sr][sc];",
            "        pq.add(new long[]{sr, sc, dist[sr][sc]});",
            "        ",
            "        int[] dr = {-1, 1, 0, 0}, dc = {0, 0, -1, 1};",
            "        ",
            "        while (!pq.isEmpty()) {",
            "            long[] curr = pq.poll();",
            "            int currR = (int) curr[0], currC = (int) curr[1];",
            "            long d = curr[2];",
            "            ",
            "            if (d > dist[currR][currC]) continue;",
            "            ",
            "            for (int i = 0; i < 4; i++) {",
            "                int nr = currR + dr[i], nc = currC + dc[i];",
            "                if (nr >= 0 && nr < r && nc >= 0 && nc < c) {",
            "                    if (dist[currR][currC] + costMatrix[nr][nc] < dist[nr][nc]) {",
            "                        dist[nr][nc] = dist[currR][currC] + costMatrix[nr][nc];",
            "                        pq.add(new long[]{nr, nc, dist[nr][nc]});",
            "                    }",
            "                }",
            "            }",
            "        }",
            "        return dist;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: queuedijkstragrid -> O((R*C) log(R*C)) Shortest path on a weighted 2D grid using a Priority Queue"
    },
    "CP Queue: First Non-Repeating Character in Stream": {
        "scope": "java",
        "prefix": "queuestream",
        "body": [
            "    static class StreamFirstUnique {",
            "        int[] count = new int[26];",
            "        Queue<Character> q = new ArrayDeque<>();",
            "        ",
            "        void add(char c) {",
            "            count[c - 'a']++;",
            "            q.add(c);",
            "        }",
            "        ",
            "        char getFirstUnique() {",
            "            while (!q.isEmpty() && count[q.peek() - 'a'] > 1) {",
            "                q.poll();",
            "            }",
            "            return q.isEmpty() ? '#' : q.peek();",
            "        }",
            "    }",
            "    $0"
        ],
        "description": "Prefix: queuestream -> O(1) Amortized time to find the first non-repeating char in a stream"
    }
}