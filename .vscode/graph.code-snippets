{
    "CP Graph: Tarjan's SCC & Condensation Graph": {
        "scope": "java",
        "prefix": "graphscc",
        "body": [
            "    static class SCC {",
            "        int n, timer, sccCount;",
            "        int[] tin, low, comp;",
            "        boolean[] inStack;",
            "        Deque<Integer> stack;",
            "        List<Integer>[] adj, sccAdj;",
            "        List<List<Integer>> sccNodes;",
            "",
            "        SCC(int n, List<Integer>[] adj) {",
            "            this.n = n; this.adj = adj;",
            "            tin = new int[n]; low = new int[n]; comp = new int[n];",
            "            Arrays.fill(tin, -1);",
            "            inStack = new boolean[n];",
            "            stack = new ArrayDeque<>();",
            "            sccNodes = new ArrayList<>();",
            "            for (int i = 0; i < n; i++) if (tin[i] == -1) dfs(i);",
            "        }",
            "",
            "        void dfs(int u) {",
            "            tin[u] = low[u] = ++timer;",
            "            stack.push(u); inStack[u] = true;",
            "            for (int v : adj[u]) {",
            "                if (tin[v] == -1) { dfs(v); low[u] = Math.min(low[u], low[v]); }",
            "                else if (inStack[v]) low[u] = Math.min(low[u], tin[v]);",
            "            }",
            "            if (low[u] == tin[u]) {",
            "                List<Integer> currentSCC = new ArrayList<>();",
            "                while (true) {",
            "                    int v = stack.pop(); inStack[v] = false;",
            "                    comp[v] = sccCount;",
            "                    currentSCC.add(v);",
            "                    if (u == v) break;",
            "                }",
            "                sccNodes.add(currentSCC); sccCount++;",
            "            }",
            "        }",
            "",
            "        void buildCondensationGraph() {",
            "            sccAdj = new ArrayList[sccCount];",
            "            for (int i = 0; i < sccCount; i++) sccAdj[i] = new ArrayList<>();",
            "            for (int u = 0; u < n; u++) {",
            "                for (int v : adj[u]) {",
            "                    if (comp[u] != comp[v]) sccAdj[comp[u]].add(comp[v]);",
            "                }",
            "            }",
            "        }",
            "    }",
            "    $0"
        ],
        "description": "Prefix: graphscc -> O(V+E) Tarjan's SCC and Condensation DAG Builder"
    },
    "CP Graph: Bridges & Articulation Points": {
        "scope": "java",
        "prefix": "graphbridges",
        "body": [
            "    static class CutVerticesAndBridges {",
            "        int timer;",
            "        int[] tin, low;",
            "        boolean[] isArticulation;",
            "        List<int[]> bridges; // [u, v]",
            "        List<Integer>[] adj;",
            "",
            "        CutVerticesAndBridges(int n, List<Integer>[] adj) {",
            "            this.adj = adj;",
            "            tin = new int[n]; low = new int[n];",
            "            Arrays.fill(tin, -1);",
            "            isArticulation = new boolean[n];",
            "            bridges = new ArrayList<>();",
            "            for (int i = 0; i < n; i++) if (tin[i] == -1) dfs(i, -1);",
            "        }",
            "",
            "        void dfs(int u, int p) {",
            "            tin[u] = low[u] = ++timer;",
            "            int children = 0;",
            "            for (int v : adj[u]) {",
            "                if (v == p) continue;",
            "                if (tin[v] != -1) low[u] = Math.min(low[u], tin[v]);",
            "                else {",
            "                    dfs(v, u);",
            "                    low[u] = Math.min(low[u], low[v]);",
            "                    if (low[v] >= tin[u] && p != -1) isArticulation[u] = true;",
            "                    if (low[v] > tin[u]) bridges.add(new int[]{Math.min(u, v), Math.max(u, v)});",
            "                    children++;",
            "                }",
            "            }",
            "            if (p == -1 && children > 1) isArticulation[u] = true;",
            "        }",
            "    }",
            "    $0"
        ],
        "description": "Prefix: graphbridges -> O(V+E) Finds vulnerable network points and edges"
    },
    "CP Graph: Dinic's Max Flow": {
        "scope": "java",
        "prefix": "graphdinic",
        "body": [
            "    static class Dinic {",
            "        static class Edge {",
            "            int to, rev;",
            "            long cap, flow;",
            "            Edge(int to, int rev, long cap) { this.to = to; this.rev = rev; this.cap = cap; }",
            "        }",
            "        int n;",
            "        List<Edge>[] adj;",
            "        int[] level, ptr;",
            "",
            "        Dinic(int n) {",
            "            this.n = n;",
            "            adj = new ArrayList[n];",
            "            for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();",
            "            level = new int[n]; ptr = new int[n];",
            "        }",
            "",
            "        void addEdge(int from, int to, long cap) {",
            "            adj[from].add(new Edge(to, adj[to].size(), cap));",
            "            adj[to].add(new Edge(from, adj[from].size() - 1, 0)); // 0 for directed",
            "        }",
            "",
            "        boolean bfs(int s, int t) {",
            "            Arrays.fill(level, -1);",
            "            level[s] = 0;",
            "            Queue<Integer> q = new LinkedList<>();",
            "            q.add(s);",
            "            while (!q.isEmpty()) {",
            "                int v = q.poll();",
            "                for (Edge edge : adj[v]) {",
            "                    if (edge.cap - edge.flow > 0 && level[edge.to] == -1) {",
            "                        level[edge.to] = level[v] + 1;",
            "                        q.add(edge.to);",
            "                    }",
            "                }",
            "            }",
            "            return level[t] != -1;",
            "        }",
            "",
            "        long dfs(int v, int t, long pushed) {",
            "            if (pushed == 0 || v == t) return pushed;",
            "            for (int cid = ptr[v]; cid < adj[v].size(); ++cid, ++ptr[v]) {",
            "                Edge edge = adj[v].get(cid);",
            "                int tr = edge.to;",
            "                if (level[v] + 1 != level[tr] || edge.cap - edge.flow == 0) continue;",
            "                long push = dfs(tr, t, Math.min(pushed, edge.cap - edge.flow));",
            "                if (push == 0) continue;",
            "                edge.flow += push;",
            "                adj[tr].get(edge.rev).flow -= push;",
            "                return push;",
            "            }",
            "            return 0;",
            "        }",
            "",
            "        long maxFlow(int s, int t) {",
            "            long flow = 0;",
            "            while (bfs(s, t)) {",
            "                Arrays.fill(ptr, 0);",
            "                long pushed;",
            "                while ((pushed = dfs(s, t, Long.MAX_VALUE)) != 0) flow += pushed;",
            "            }",
            "            return flow;",
            "        }",
            "    }",
            "    $0"
        ],
        "description": "Prefix: graphdinic -> O(V^2 E) Extremely fast Network Flow with Level Graphs"
    },
    "CP Graph: Kuhn's Bipartite Matching": {
        "scope": "java",
        "prefix": "graphkuhn",
        "body": [
            "    static class Kuhn {",
            "        int n, k;",
            "        List<Integer>[] adj;",
            "        int[] match;",
            "        boolean[] vis;",
            "",
            "        Kuhn(int n, int k, List<Integer>[] adj) {",
            "            this.n = n; this.k = k; // n = set 1 size, k = set 2 size",
            "            this.adj = adj;",
            "            match = new int[k];",
            "            Arrays.fill(match, -1);",
            "            vis = new boolean[n];",
            "        }",
            "",
            "        boolean dfs(int u) {",
            "            for (int v : adj[u]) {",
            "                if (vis[v]) continue;",
            "                vis[v] = true;",
            "                if (match[v] < 0 || dfs(match[v])) {",
            "                    match[v] = u;",
            "                    return true;",
            "                }",
            "            }",
            "            return false;",
            "        }",
            "",
            "        int maxMatching() {",
            "            int res = 0;",
            "            for (int i = 0; i < n; i++) {",
            "                Arrays.fill(vis, false);",
            "                if (dfs(i)) res++;",
            "            }",
            "            return res;",
            "        }",
            "    }",
            "    $0"
        ],
        "description": "Prefix: graphkuhn -> O(VE) Maximum Bipartite Matching via augmenting paths"
    },
    "CP Graph: BFS (Unweighted Shortest Path)": {
        "scope": "java",
        "prefix": "graphbfs",
        "body": [
            "    static int[] bfs(int source, int n, List<Integer>[] adj) {",
            "        int[] dist = new int[n];",
            "        Arrays.fill(dist, -1);",
            "        Queue<Integer> q = new ArrayDeque<>();",
            "        ",
            "        dist[source] = 0;",
            "        q.add(source);",
            "        ",
            "        while (!q.isEmpty()) {",
            "            int u = q.poll();",
            "            for (int v : adj[u]) {",
            "                if (dist[v] == -1) {",
            "                    dist[v] = dist[u] + 1;",
            "                    q.add(v);",
            "                }",
            "            }",
            "        }",
            "        return dist;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: graphbfs -> O(V+E) Standard Breadth-First Search returning distance array"
    },
    "CP Graph: DFS (Connected Components)": {
        "scope": "java",
        "prefix": "graphdfs",
        "body": [
            "    static boolean[] vis;",
            "    static void dfs(int u, List<Integer>[] adj) {",
            "        vis[u] = true;",
            "        for (int v : adj[u]) {",
            "            if (!vis[v]) dfs(v, adj);",
            "        }",
            "    }",
            "",
            "    static int countComponents(int n, List<Integer>[] adj) {",
            "        vis = new boolean[n];",
            "        int components = 0;",
            "        for (int i = 0; i < n; i++) {",
            "            if (!vis[i]) {",
            "                components++;",
            "                dfs(i, adj);",
            "            }",
            "        }",
            "        return components;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: graphdfs -> O(V+E) Standard Depth-First Search and component counting"
    },
    "CP Graph: Dijkstra (Weighted Shortest Path)": {
        "scope": "java",
        "prefix": "graphdijkstra",
        "body": [
            "    // Requires adj list of int[]{destination, weight}",
            "    static long[] dijkstra(int source, int n, List<int[]>[] adj) {",
            "        long[] dist = new long[n];",
            "        Arrays.fill(dist, Long.MAX_VALUE);",
            "        PriorityQueue<long[]> pq = new PriorityQueue<>(Comparator.comparingLong(a -> a[1]));",
            "        ",
            "        dist[source] = 0;",
            "        pq.add(new long[]{source, 0});",
            "        ",
            "        while (!pq.isEmpty()) {",
            "            long[] curr = pq.poll();",
            "            int u = (int) curr[0];",
            "            long d = curr[1];",
            "            ",
            "            if (d > dist[u]) continue; // Stale node optimization",
            "            ",
            "            for (int[] edge : adj[u]) {",
            "                int v = edge[0];",
            "                long weight = edge[1];",
            "                if (dist[u] + weight < dist[v]) {",
            "                    dist[v] = dist[u] + weight;",
            "                    pq.add(new long[]{v, dist[v]});",
            "                }",
            "            }",
            "        }",
            "        return dist;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: graphdijkstra -> O(E log V) Shortest path for positive weighted graphs"
    },
    "CP Graph: 0-1 BFS (Deque)": {
        "scope": "java",
        "prefix": "graph01bfs",
        "body": [
            "    // Useful for matrix/grid problems where moves cost 0 or 1",
            "    static int[] bfs01(int source, int n, List<int[]>[] adj) {",
            "        int[] dist = new int[n];",
            "        Arrays.fill(dist, Integer.MAX_VALUE);",
            "        Deque<Integer> dq = new ArrayDeque<>();",
            "        ",
            "        dist[source] = 0;",
            "        dq.addFirst(source);",
            "        ",
            "        while (!dq.isEmpty()) {",
            "            int u = dq.pollFirst();",
            "            for (int[] edge : adj[u]) {",
            "                int v = edge[0];",
            "                int weight = edge[1]; // Must be 0 or 1",
            "                if (dist[u] + weight < dist[v]) {",
            "                    dist[v] = dist[u] + weight;",
            "                    if (weight == 0) dq.addFirst(v);",
            "                    else dq.addLast(v);",
            "                }",
            "            }",
            "        }",
            "        return dist;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: graph01bfs -> O(V+E) Shortest path strictly for 0/1 edge weights"
    },
    "CP Graph: Topological Sort (Kahn's)": {
        "scope": "java",
        "prefix": "graphtoposort",
        "body": [
            "    static List<Integer> topoSort(int n, List<Integer>[] adj) {",
            "        int[] inDegree = new int[n];",
            "        for (int i = 0; i < n; i++) {",
            "            for (int v : adj[i]) inDegree[v]++;",
            "        }",
            "        ",
            "        Queue<Integer> q = new ArrayDeque<>();",
            "        for (int i = 0; i < n; i++) {",
            "            if (inDegree[i] == 0) q.add(i);",
            "        }",
            "        ",
            "        List<Integer> order = new ArrayList<>();",
            "        while (!q.isEmpty()) {",
            "            int u = q.poll();",
            "            order.add(u);",
            "            for (int v : adj[u]) {",
            "                if (--inDegree[v] == 0) q.add(v);",
            "            }",
            "        }",
            "        ",
            "        // If order.size() < n, the graph contains a cycle",
            "        return order;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: graphtoposort -> O(V+E) Kahn's algorithm for directed acyclic graphs (DAGs)"
    },
    "CP Graph: Bellman-Ford (Negative Cycle Detection)": {
        "scope": "java",
        "prefix": "graphbellmanford",
        "body": [
            "    // Edges format: {u, v, weight}",
            "    static long[] bellmanFord(int n, int source, List<int[]> edges) {",
            "        long[] dist = new long[n];",
            "        Arrays.fill(dist, Long.MAX_VALUE);",
            "        dist[source] = 0;",
            "        ",
            "        // Relax edges V - 1 times",
            "        for (int i = 0; i < n - 1; i++) {",
            "            for (int[] edge : edges) {",
            "                int u = edge[0], v = edge[1], w = edge[2];",
            "                if (dist[u] != Long.MAX_VALUE && dist[u] + w < dist[v]) {",
            "                    dist[v] = dist[u] + w;",
            "                }",
            "            }",
            "        }",
            "        ",
            "        // 1 extra relaxation to check for negative weight cycles",
            "        for (int[] edge : edges) {",
            "            int u = edge[0], v = edge[1], w = edge[2];",
            "            if (dist[u] != Long.MAX_VALUE && dist[u] + w < dist[v]) {",
            "                return null; // Negative cycle detected",
            "            }",
            "        }",
            "        return dist;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: graphbellmanford -> O(VE) Shortest path capable of handling negative weights and detecting cycles"
    },
    "CP Graph: Floyd-Warshall (All-Pairs Shortest Path)": {
        "scope": "java",
        "prefix": "graphfloydwarshall",
        "body": [
            "    static long[][] floydWarshall(int n, long[][] adjMatrix) {",
            "        long[][] dist = new long[n][n];",
            "        for (int i = 0; i < n; i++) {",
            "            for (int j = 0; j < n; j++) {",
            "                dist[i][j] = adjMatrix[i][j];",
            "            }",
            "        }",
            "        ",
            "        for (int k = 0; k < n; k++) {",
            "            for (int i = 0; i < n; i++) {",
            "                for (int j = 0; j < n; j++) {",
            "                    if (dist[i][k] != Long.MAX_VALUE && dist[k][j] != Long.MAX_VALUE) {",
            "                        dist[i][j] = Math.min(dist[i][j], dist[i][k] + dist[k][j]);",
            "                    }",
            "                }",
            "            }",
            "        }",
            "        return dist;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: graphfloydwarshall -> O(V^3) All-Pairs Shortest Path. Dense graphs only (N <= 500)."
    },
    "CP Graph: Kruskal's Minimum Spanning Tree (MST)": {
        "scope": "java",
        "prefix": "graphkruskal",
        "body": [
            "    static class KruskalMST {",
            "        int[] parent;",
            "        ",
            "        int find(int i) {",
            "            return parent[i] == i ? i : (parent[i] = find(parent[i]));",
            "        }",
            "        ",
            "        boolean union(int i, int j) {",
            "            int rootI = find(i), rootJ = find(j);",
            "            if (rootI != rootJ) {",
            "                parent[rootI] = rootJ;",
            "                return true;",
            "            }",
            "            return false;",
            "        }",
            "        ",
            "        // Edges format: {u, v, weight}",
            "        long getMSTWeight(int n, List<int[]> edges) {",
            "            parent = new int[n];",
            "            for (int i = 0; i < n; i++) parent[i] = i;",
            "            ",
            "            // Sort edges by weight ascending",
            "            edges.sort(Comparator.comparingInt(a -> a[2]));",
            "            ",
            "            long mstWeight = 0;",
            "            int edgesUsed = 0;",
            "            for (int[] edge : edges) {",
            "                if (union(edge[0], edge[1])) {",
            "                    mstWeight += edge[2];",
            "                    edgesUsed++;",
            "                    if (edgesUsed == n - 1) break;",
            "                }",
            "            }",
            "            return edgesUsed == n - 1 ? mstWeight : -1; // -1 if graph is disconnected",
            "        }",
            "    }",
            "    $0"
        ],
        "description": "Prefix: graphkruskal -> O(E log E) Minimum Spanning Tree utilizing lightweight DSU"
    },
    "CP Graph: Bipartite Check (Graph Coloring)": {
        "scope": "java",
        "prefix": "graphbipartite",
        "body": [
            "    static boolean isBipartite(int n, List<Integer>[] adj) {",
            "        int[] color = new int[n];",
            "        Arrays.fill(color, -1);",
            "        ",
            "        for (int i = 0; i < n; i++) {",
            "            if (color[i] != -1) continue;",
            "            Queue<Integer> q = new ArrayDeque<>();",
            "            q.add(i);",
            "            color[i] = 0;",
            "            ",
            "            while (!q.isEmpty()) {",
            "                int u = q.poll();",
            "                for (int v : adj[u]) {",
            "                    if (color[v] == -1) {",
            "                        color[v] = 1 - color[u];",
            "                        q.add(v);",
            "                    } else if (color[v] == color[u]) {",
            "                        return false; // Graph is not bipartite",
            "                    }",
            "                }",
            "            }",
            "        }",
            "        return true;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: graphbipartite -> O(V+E) Validates if graph can be split into two independent sets"
    },
    "CP Graph: Hierholzer's Algorithm (Eulerian Path/Circuit)": {
        "scope": "java",
        "prefix": "grapheuler",
        "body": [
            "    // Requires Directed Graph. Modifies the adjacency list during execution!",
            "    static List<Integer> getEulerianPath(int n, List<Integer>[] adj, int startNode) {",
            "        List<Integer> path = new ArrayList<>();",
            "        Deque<Integer> stack = new ArrayDeque<>();",
            "        int[] edgePtr = new int[n];",
            "        ",
            "        stack.push(startNode);",
            "        while (!stack.isEmpty()) {",
            "            int u = stack.peek();",
            "            if (edgePtr[u] < adj[u].size()) {",
            "                stack.push(adj[u].get(edgePtr[u]++));",
            "            } else {",
            "                path.add(stack.pop());",
            "            }",
            "        }",
            "        Collections.reverse(path);",
            "        return path;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: grapheuler -> O(V+E) Finds a path traversing every edge exactly once"
    },
    "CP Graph: Cycle Detection (Undirected)": {
        "scope": "java",
        "prefix": "graphcycleundirected",
        "body": [
            "    static boolean hasCycleUndirected(int n, List<Integer>[] adj) {",
            "        boolean[] vis = new boolean[n];",
            "        for (int i = 0; i < n; i++) {",
            "            if (!vis[i]) {",
            "                if (dfsCycleUndirected(i, -1, vis, adj)) return true;",
            "            }",
            "        }",
            "        return false;",
            "    }",
            "    ",
            "    static boolean dfsCycleUndirected(int u, int p, boolean[] vis, List<Integer>[] adj) {",
            "        vis[u] = true;",
            "        for (int v : adj[u]) {",
            "            if (!vis[v]) {",
            "                if (dfsCycleUndirected(v, u, vis, adj)) return true;",
            "            } else if (v != p) {",
            "                return true; // Back-edge found",
            "            }",
            "        }",
            "        return false;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: graphcycleundirected -> O(V+E) Simple cycle detection for undirected graphs"
    },
    "CP Graph: Multi-Source BFS": {
        "scope": "java",
        "prefix": "graphmultibfs",
        "body": [
            "    // Finds the shortest distance from ANY of the source nodes to all other nodes.",
            "    static int[] multiSourceBfs(int n, List<Integer> sources, List<Integer>[] adj) {",
            "        int[] dist = new int[n];",
            "        Arrays.fill(dist, -1);",
            "        Queue<Integer> q = new ArrayDeque<>();",
            "        ",
            "        for (int s : sources) {",
            "            dist[s] = 0;",
            "            q.add(s);",
            "        }",
            "        ",
            "        while (!q.isEmpty()) {",
            "            int u = q.poll();",
            "            for (int v : adj[u]) {",
            "                if (dist[v] == -1) {",
            "                    dist[v] = dist[u] + 1;",
            "                    q.add(v);",
            "                }",
            "            }",
            "        }",
            "        return dist;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: graphmultibfs -> O(V+E) Grid/Graph shortest path from multiple starting points"
    },
    "CP Graph: Directed Cycle Detection (3-Color)": {
        "scope": "java",
        "prefix": "graphcycledir",
        "body": [
            "    static boolean hasCycleDirected(int n, List<Integer>[] adj) {",
            "        int[] color = new int[n]; // 0: unvisited, 1: visiting (in stack), 2: fully visited",
            "        for (int i = 0; i < n; i++) {",
            "            if (color[i] == 0) {",
            "                if (dfsCycleDir(i, color, adj)) return true;",
            "            }",
            "        }",
            "        return false;",
            "    }",
            "    ",
            "    static boolean dfsCycleDir(int u, int[] color, List<Integer>[] adj) {",
            "        color[u] = 1;",
            "        for (int v : adj[u]) {",
            "            if (color[v] == 0) {",
            "                if (dfsCycleDir(v, color, adj)) return true;",
            "            } else if (color[v] == 1) {",
            "                return true; // Back-edge found -> Cycle!",
            "            }",
            "        }",
            "        color[u] = 2;",
            "        return false;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: graphcycledir -> O(V+E) Detects cycles in directed graphs (dependencies/deadlocks)"
    },
    "CP Graph: Prim's MST (Dense Graphs)": {
        "scope": "java",
        "prefix": "graphprim",
        "body": [
            "    // Faster than Kruskal's for extremely dense graphs (E approaching V^2).",
            "    static long primMST(int n, List<int[]>[] adj) {",
            "        boolean[] inMST = new boolean[n];",
            "        long[] minEdge = new long[n];",
            "        Arrays.fill(minEdge, Long.MAX_VALUE);",
            "        ",
            "        PriorityQueue<long[]> pq = new PriorityQueue<>(Comparator.comparingLong(a -> a[1]));",
            "        minEdge[0] = 0;",
            "        pq.add(new long[]{0, 0});",
            "        ",
            "        long mstWeight = 0;",
            "        int nodesIncluded = 0;",
            "        ",
            "        while (!pq.isEmpty() && nodesIncluded < n) {",
            "            long[] curr = pq.poll();",
            "            int u = (int) curr[0];",
            "            long weight = curr[1];",
            "            ",
            "            if (inMST[u]) continue;",
            "            inMST[u] = true;",
            "            mstWeight += weight;",
            "            nodesIncluded++;",
            "            ",
            "            for (int[] edge : adj[u]) {",
            "                int v = edge[0];",
            "                long w = edge[1];",
            "                if (!inMST[v] && w < minEdge[v]) {",
            "                    minEdge[v] = w;",
            "                    pq.add(new long[]{v, w});",
            "                }",
            "            }",
            "        }",
            "        return nodesIncluded == n ? mstWeight : -1; // -1 if disconnected",
            "    }",
            "    $0"
        ],
        "description": "Prefix: graphprim -> O(E log V) MST utilizing a Priority Queue"
    },
    "CP Graph: TSP / Hamiltonian Path (Bitmask DP)": {
        "scope": "java",
        "prefix": "graphtsp",
        "body": [
            "    // Exact shortest path visiting ALL nodes exactly once. Solves N <= 20 constraints.",
            "    // distMatrix[u][v] should be distance from u to v. INF if no edge.",
            "    static long tsp(int n, long[][] distMatrix) {",
            "        long[][] dp = new long[1 << n][n];",
            "        long INF = (long) 1e16;",
            "        for (long[] row : dp) Arrays.fill(row, INF);",
            "        ",
            "        // Base case: Start at node 0 (can modify to loop over all starting nodes)",
            "        dp[1][0] = 0;",
            "        ",
            "        for (int mask = 1; mask < (1 << n); mask += 2) { // += 2 ensures node 0 is always in the mask",
            "            for (int u = 0; u < n; u++) {",
            "                if ((mask & (1 << u)) == 0 || dp[mask][u] == INF) continue;",
            "                for (int v = 0; v < n; v++) {",
            "                    if ((mask & (1 << v)) == 0 && distMatrix[u][v] != INF) {",
            "                        int nextMask = mask | (1 << v);",
            "                        dp[nextMask][v] = Math.min(dp[nextMask][v], dp[mask][u] + distMatrix[u][v]);",
            "                    }",
            "                }",
            "            }",
            "        }",
            "        ",
            "        long minTour = INF;",
            "        int fullMask = (1 << n) - 1;",
            "        for (int i = 1; i < n; i++) {",
            "            if (distMatrix[i][0] != INF) {",
            "                minTour = Math.min(minTour, dp[fullMask][i] + distMatrix[i][0]); // Return to start",
            "            }",
            "        }",
            "        return minTour == INF ? -1 : minTour;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: graphtsp -> O(N^2 * 2^N) Traveling Salesperson using DP + Bitmasking"
    },
    "CP Graph: Min-Cost Max-Flow (SPFA)": {
        "scope": "java",
        "prefix": "graphmcmf",
        "body": [
            "    // Use for assignment problems with costs, or routing with specific distance penalties.",
            "    static class MCMF {",
            "        static class Edge {",
            "            int to, rev;",
            "            long cap, flow, cost;",
            "            Edge(int to, int rev, long cap, long cost) {",
            "                this.to = to; this.rev = rev; this.cap = cap; this.cost = cost;",
            "            }",
            "        }",
            "        int n;",
            "        List<Edge>[] adj;",
            "        long[] dist;",
            "        int[] parentEdge, parentNode;",
            "        boolean[] inQueue;",
            "",
            "        MCMF(int n) {",
            "            this.n = n;",
            "            adj = new ArrayList[n];",
            "            for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();",
            "            dist = new long[n];",
            "            parentEdge = new int[n]; parentNode = new int[n];",
            "            inQueue = new boolean[n];",
            "        }",
            "",
            "        void addEdge(int from, int to, long cap, long cost) {",
            "            adj[from].add(new Edge(to, adj[to].size(), cap, cost));",
            "            adj[to].add(new Edge(from, adj[from].size() - 1, 0, -cost));",
            "        }",
            "",
            "        boolean spfa(int s, int t) {",
            "            Arrays.fill(dist, Long.MAX_VALUE);",
            "            Arrays.fill(inQueue, false);",
            "            Queue<Integer> q = new ArrayDeque<>();",
            "            ",
            "            dist[s] = 0; q.add(s); inQueue[s] = true;",
            "            ",
            "            while (!q.isEmpty()) {",
            "                int u = q.poll();",
            "                inQueue[u] = false;",
            "                for (int i = 0; i < adj[u].size(); i++) {",
            "                    Edge e = adj[u].get(i);",
            "                    if (e.cap - e.flow > 0 && dist[u] != Long.MAX_VALUE && dist[u] + e.cost < dist[e.to]) {",
            "                        dist[e.to] = dist[u] + e.cost;",
            "                        parentNode[e.to] = u;",
            "                        parentEdge[e.to] = i;",
            "                        if (!inQueue[e.to]) {",
            "                            q.add(e.to);",
            "                            inQueue[e.to] = true;",
            "                        }",
            "                    }",
            "                }",
            "            }",
            "            return dist[t] != Long.MAX_VALUE;",
            "        }",
            "",
            "        long[] getMinCostMaxFlow(int s, int t) {",
            "            long flow = 0, cost = 0;",
            "            while (spfa(s, t)) {",
            "                long push = Long.MAX_VALUE;",
            "                int curr = t;",
            "                while (curr != s) {",
            "                    int p = parentNode[curr];",
            "                    int idx = parentEdge[curr];",
            "                    push = Math.min(push, adj[p].get(idx).cap - adj[p].get(idx).flow);",
            "                    curr = p;",
            "                }",
            "                ",
            "                flow += push;",
            "                cost += push * dist[t];",
            "                curr = t;",
            "                while (curr != s) {",
            "                    int p = parentNode[curr];",
            "                    int idx = parentEdge[curr];",
            "                    Edge e = adj[p].get(idx);",
            "                    e.flow += push;",
            "                    adj[curr].get(e.rev).flow -= push;",
            "                    curr = p;",
            "                }",
            "            }",
            "            return new long[]{flow, cost};",
            "        }",
            "    }",
            "    $0"
        ],
        "description": "Prefix: graphmcmf -> O(V^2 E^2) Min-Cost Max-Flow using SPFA"
    },
    "CP Graph: 2-SAT Solver": {
        "scope": "java",
        "prefix": "graph2sat",
        "body": [
            "    // Solves boolean satisfiability: (A OR B) AND (!C OR D)...",
            "    // Requires: `SCC` class (graphscc snippet)",
            "    static class TwoSat {",
            "        int n;",
            "        List<Integer>[] adj;",
            "        boolean[] assignment;",
            "",
            "        TwoSat(int variables) {",
            "            this.n = variables;",
            "            adj = new ArrayList[2 * n];",
            "            for (int i = 0; i < 2 * n; i++) adj[i] = new ArrayList<>();",
            "            assignment = new boolean[n];",
            "        }",
            "",
            "        // Variables are 0-indexed. isTrue is boolean.",
            "        void addClause(int i, boolean f, int j, boolean g) {",
            "            adj[2 * i + (f ? 0 : 1)].add(2 * j + (g ? 1 : 0)); // !i => j",
            "            adj[2 * j + (g ? 0 : 1)].add(2 * i + (f ? 1 : 0)); // !j => i",
            "        }",
            "",
            "        boolean solve() {",
            "            SCC scc = new SCC(2 * n, adj); // Calls your existing SCC logic",
            "            for (int i = 0; i < n; i++) {",
            "                if (scc.comp[2 * i] == scc.comp[2 * i + 1]) return false; // i and !i in same component",
            "                // Topologically sorted by SCC IDs (smaller ID = later in topo sort)",
            "                assignment[i] = scc.comp[2 * i] > scc.comp[2 * i + 1];",
            "            }",
            "            return true;",
            "        }",
            "    }",
            "    $0"
        ],
        "description": "Prefix: graph2sat -> O(V+E) Solves 2-SAT using Implication Graphs and SCCs"
    }
}