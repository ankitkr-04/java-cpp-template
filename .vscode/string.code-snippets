{
    "CP String: Frequency Array (a-z)": {
        "scope": "java",
        "prefix": "strfreq",
        "body": [
            "    static int[] getFreq(String s) {",
            "        int[] freq = new int[26];",
            "        for (char c : s.toCharArray()) {",
            "            freq[c - 'a']++;",
            "        }",
            "        return freq;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: strfreq -> O(N) Converts lowercase string to int[26] frequency map"
    },
    "CP String: Edit Distance (Levenshtein)": {
        "scope": "java",
        "prefix": "streditdist",
        "body": [
            "    static int editDistance(String s1, String s2) {",
            "        int m = s1.length(), n = s2.length();",
            "        int[][] dp = new int[m + 1][n + 1];",
            "        for (int i = 0; i <= m; i++) {",
            "            for (int j = 0; j <= n; j++) {",
            "                if (i == 0) dp[i][j] = j; // Min operations is inserting all characters of s2",
            "                else if (j == 0) dp[i][j] = i; // Min operations is removing all characters of s1",
            "                else if (s1.charAt(i - 1) == s2.charAt(j - 1)) dp[i][j] = dp[i - 1][j - 1];",
            "                else dp[i][j] = 1 + Math.min(dp[i][j - 1], ",
            "                                    Math.min(dp[i - 1][j], dp[i - 1][j - 1]));",
            "            }",
            "        }",
            "        return dp[m][n];",
            "    }",
            "    $0"
        ],
        "description": "Prefix: streditdist -> O(N*M) Min operations (insert, delete, replace) to match strings"
    },
    "CP String: Longest Common Subsequence (LCS)": {
        "scope": "java",
        "prefix": "strlcs",
        "body": [
            "    static int lcs(String s1, String s2) {",
            "        int m = s1.length(), n = s2.length();",
            "        int[][] dp = new int[m + 1][n + 1];",
            "        for (int i = 1; i <= m; i++) {",
            "            for (int j = 1; j <= n; j++) {",
            "                if (s1.charAt(i - 1) == s2.charAt(j - 1)) {",
            "                    dp[i][j] = dp[i - 1][j - 1] + 1;",
            "                } else {",
            "                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);",
            "                }",
            "            }",
            "        }",
            "        return dp[m][n];",
            "    }",
            "    $0"
        ],
        "description": "Prefix: strlcs -> O(N*M) Finds the length of the Longest Common Subsequence"
    },
    "CP String: Minimal String Rotation (Booth's Algo)": {
        "scope": "java",
        "prefix": "strminrot",
        "body": [
            "    // Returns the starting index of the lexicographically smallest rotation of S in O(N)",
            "    static int minRotation(String s) {",
            "        s += s;",
            "        int n = s.length();",
            "        int[] f = new int[n];",
            "        Arrays.fill(f, -1);",
            "        int k = 0;",
            "        for (int j = 1; j < n; j++) {",
            "            char sj = s.charAt(j);",
            "            int i = f[j - k - 1];",
            "            while (i != -1 && sj != s.charAt(k + i + 1)) {",
            "                if (sj < s.charAt(k + i + 1)) k = j - i - 1;",
            "                i = f[i];",
            "            }",
            "            if (sj != s.charAt(k + i + 1)) {",
            "                if (sj < s.charAt(k)) k = j;",
            "                f[j - k] = -1;",
            "            } else {",
            "                f[j - k] = i + 1;",
            "            }",
            "        }",
            "        return k;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: strminrot -> O(N) Finds starting index of alphabetically smallest string rotation"
    },
    "CP String: Rolling Hash (O(1) Substring Compare)": {
        "scope": "java",
        "prefix": "strhash",
        "body": [
            "    static class StringHash {",
            "        long[] h, p;",
            "        long mod = (long) 1e9 + 7, base = 31;",
            "        StringHash(String s) {",
            "            int n = s.length();",
            "            h = new long[n + 1];",
            "            p = new long[n + 1];",
            "            p[0] = 1;",
            "            for (int i = 0; i < n; i++) {",
            "                p[i + 1] = (p[i] * base) % mod;",
            "                h[i + 1] = (h[i] * base + (s.charAt(i) - 'a' + 1)) % mod;",
            "            }",
            "        }",
            "        // 0-indexed, inclusive bounds [l, r]",
            "        long getHash(int l, int r) {",
            "            return (h[r + 1] - (h[l] * p[r - l + 1]) % mod + mod) % mod;",
            "        }",
            "    }",
            "    $0"
        ],
        "description": "Prefix: strhash -> Rabin-Karp Rolling Hash for O(1) Substring Equality / Palindrome checks"
    },
    "CP String: KMP Prefix Function (Pi Array)": {
        "scope": "java",
        "prefix": "strkmp",
        "body": [
            "    // pi[i] is the length of the longest proper prefix of s[0..i] ",
            "    // which is also a suffix of s[0..i].",
            "    static int[] prefixFunction(String s) {",
            "        int n = s.length();",
            "        int[] pi = new int[n];",
            "        for (int i = 1; i < n; i++) {",
            "            int j = pi[i - 1];",
            "            while (j > 0 && s.charAt(i) != s.charAt(j)) j = pi[j - 1];",
            "            if (s.charAt(i) == s.charAt(j)) j++;",
            "            pi[i] = j;",
            "        }",
            "        return pi;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: strkmp -> Knuth-Morris-Pratt Pi Array for O(N) pattern matching"
    },
    "CP String: Z-Function": {
        "scope": "java",
        "prefix": "strzfunc",
        "body": [
            "    // z[i] is the length of the longest common prefix between s and the suffix of s starting at i.",
            "    static int[] zFunction(String s) {",
            "        int n = s.length();",
            "        int[] z = new int[n];",
            "        for (int i = 1, l = 0, r = 0; i < n; i++) {",
            "            if (i <= r) z[i] = Math.min(r - i + 1, z[i - l]);",
            "            while (i + z[i] < n && s.charAt(z[i]) == s.charAt(i + z[i])) z[i]++;",
            "            if (i + z[i] - 1 > r) { l = i; r = i + z[i] - 1; }",
            "        }",
            "        return z;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: strzfunc -> Z-Array for exact substring matches in O(N)"
    },
    "CP String: Manacher's Algorithm (Longest Palindrome)": {
        "scope": "java",
        "prefix": "strmanacher",
        "body": [
            "    // Finds all sub-palindromes in O(N). ",
            "    // The max length of a palindrome centered at index i is p[i].",
            "    static int[] manacher(String s) {",
            "        StringBuilder t = new StringBuilder(\"^#\");",
            "        for (char c : s.toCharArray()) t.append(c).append(\"#\");",
            "        t.append(\"$\");",
            "        int n = t.length(), c = 0, r = 0;",
            "        int[] p = new int[n];",
            "        for (int i = 1; i < n - 1; i++) {",
            "            int mirror = c - (i - c);",
            "            if (r > i) p[i] = Math.min(r - i, p[mirror]);",
            "            while (t.charAt(i + 1 + p[i]) == t.charAt(i - 1 - p[i])) p[i]++;",
            "            if (i + p[i] > r) { c = i; r = i + p[i]; }",
            "        }",
            "        return p;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: strmanacher -> O(N) Palindrome finding. Handles both odd/even lengths safely."
    },
    "CP String: Suffix Array (O(N log^2 N))": {
        "scope": "java",
        "prefix": "strsuffixarray",
        "body": [
            "    static Integer[] buildSuffixArray(String s) {",
            "        int n = s.length();",
            "        Integer[] p = new Integer[n];",
            "        int[] c = new int[n];",
            "        for (int i = 0; i < n; i++) { p[i] = i; c[i] = s.charAt(i); }",
            "        ",
            "        for (int k = 0; (1 << k) < n || k == 0; k++) {",
            "            int len = 1 << k;",
            "            int[] prevC = c.clone();",
            "            Arrays.sort(p, (a, b) -> {",
            "                if (prevC[a] != prevC[b]) return Integer.compare(prevC[a], prevC[b]);",
            "                int rankA = a + len < n ? prevC[a + len] : -1;",
            "                int rankB = b + len < n ? prevC[b + len] : -1;",
            "                return Integer.compare(rankA, rankB);",
            "            });",
            "            c[p[0]] = 0;",
            "            for (int i = 1; i < n; i++) {",
            "                int curr1 = prevC[p[i]], curr2 = p[i] + len < n ? prevC[p[i] + len] : -1;",
            "                int prev1 = prevC[p[i - 1]], prev2 = p[i - 1] + len < n ? prevC[p[i - 1] + len] : -1;",
            "                c[p[i]] = c[p[i - 1]] + (curr1 == prev1 && curr2 == prev2 ? 0 : 1);",
            "            }",
            "        }",
            "        return p;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: strsuffixarray -> Sorts all suffixes of a string lexicographically"
    },
    "CP String: Math Expression Parser / Evaluator": {
        "scope": "java",
        "prefix": "streval",
        "body": [
            "    // Evaluates strings like \"3 + 5 * (2 - 8)\". Handles precedence automatically.",
            "    static double evalExpression(String expression) {",
            "        return new Object() {",
            "            int pos = -1, ch;",
            "            void nextChar() { ch = (++pos < expression.length()) ? expression.charAt(pos) : -1; }",
            "            boolean eat(int charToEat) {",
            "                while (ch == ' ') nextChar();",
            "                if (ch == charToEat) { nextChar(); return true; }",
            "                return false;",
            "            }",
            "            double parse() {",
            "                nextChar();",
            "                double x = parseExpression();",
            "                if (pos < expression.length()) throw new RuntimeException(\"Unexpected: \" + (char)ch);",
            "                return x;",
            "            }",
            "            double parseExpression() {",
            "                double x = parseTerm();",
            "                for (;;) {",
            "                    if (eat('+')) x += parseTerm();",
            "                    else if (eat('-')) x -= parseTerm();",
            "                    else return x;",
            "                }",
            "            }",
            "            double parseTerm() {",
            "                double x = parseFactor();",
            "                for (;;) {",
            "                    if (eat('*')) x *= parseFactor();",
            "                    else if (eat('/')) x /= parseFactor();",
            "                    else return x;",
            "                }",
            "            }",
            "            double parseFactor() {",
            "                if (eat('+')) return parseFactor();",
            "                if (eat('-')) return -parseFactor();",
            "                double x;",
            "                int startPos = this.pos;",
            "                if (eat('(')) {",
            "                    x = parseExpression();",
            "                    eat(')');",
            "                } else if ((ch >= '0' && ch <= '9') || ch == '.') {",
            "                    while ((ch >= '0' && ch <= '9') || ch == '.') nextChar();",
            "                    x = Double.parseDouble(expression.substring(startPos, this.pos));",
            "                } else throw new RuntimeException(\"Unexpected: \" + (char)ch);",
            "                return x;",
            "            }",
            "        }.parse();",
            "    }",
            "    $0"
        ],
        "description": "Prefix: streval -> Recursive Descent Parser for evaluating math string equations"
    }
}