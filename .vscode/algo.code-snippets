{
    "CP Algo: Lazy Propagation Segment Tree": {
        "scope": "java",
        "prefix": "algosegtreelazy",
        "body": [
            "    static class LazySegmentTree {",
            "        long[] tree, lazy;",
            "        int n;",
            "",
            "        LazySegmentTree(int n) {",
            "            this.n = n;",
            "            tree = new long[4 * n];",
            "            lazy = new long[4 * n];",
            "        }",
            "",
            "        void push(int node, int start, int end) {",
            "            if (lazy[node] != 0) {",
            "                tree[node] += lazy[node] * (end - start + 1); // For Sum Query. (Just lazy[node] for Min/Max)",
            "                if (start != end) {",
            "                    lazy[2 * node] += lazy[node];",
            "                    lazy[2 * node + 1] += lazy[node];",
            "                }",
            "                lazy[node] = 0;",
            "            }",
            "        }",
            "",
            "        void updateRange(int node, int start, int end, int l, int r, long val) {",
            "            push(node, start, end);",
            "            if (start > end || start > r || end < l) return;",
            "            if (start >= l && end <= r) {",
            "                lazy[node] += val;",
            "                push(node, start, end);",
            "                return;",
            "            }",
            "            int mid = (start + end) / 2;",
            "            updateRange(2 * node, start, mid, l, r, val);",
            "            updateRange(2 * node + 1, mid + 1, end, l, r, val);",
            "            tree[node] = tree[2 * node] + tree[2 * node + 1]; // Merge logic",
            "        }",
            "",
            "        long queryRange(int node, int start, int end, int l, int r) {",
            "            if (start > end || start > r || end < l) return 0; // 0 for Sum, INF for Min",
            "            push(node, start, end);",
            "            if (start >= l && end <= r) return tree[node];",
            "            int mid = (start + end) / 2;",
            "            long p1 = queryRange(2 * node, start, mid, l, r);",
            "            long p2 = queryRange(2 * node + 1, mid + 1, end, l, r);",
            "            return p1 + p2; // Merge logic",
            "        }",
            "        ",
            "        // Wrappers for 0-indexed usage",
            "        void update(int l, int r, long val) { updateRange(1, 0, n - 1, l, r, val); }",
            "        long query(int l, int r) { return queryRange(1, 0, n - 1, l, r); }",
            "    }",
            "    $0"
        ],
        "description": "Prefix: algosegtreelazy -> O(log N) Range Updates and Range Queries"
    },
    "CP Algo: Sweep Line (Interval Overlaps / Max Depth)": {
        "scope": "java",
        "prefix": "algosweepline",
        "body": [
            "    static class SweepEvent implements Comparable<SweepEvent> {",
            "        long x;",
            "        int type; // +1 for start, -1 for end",
            "        SweepEvent(long x, int type) { this.x = x; this.type = type; }",
            "        public int compareTo(SweepEvent o) {",
            "            if (this.x != o.x) return Long.compare(this.x, o.x);",
            "            return Integer.compare(this.type, o.type); // Process ends (-1) before starts (+1) to avoid false overlaps",
            "        }",
            "    }",
            "",
            "    static int maxOverlappingIntervals(long[][] intervals) {",
            "        List<SweepEvent> events = new ArrayList<>();",
            "        for (long[] interval : intervals) {",
            "            events.add(new SweepEvent(interval[0], 1));",
            "            events.add(new SweepEvent(interval[1], -1));",
            "        }",
            "        Collections.sort(events);",
            "        ",
            "        int active = 0, maxActive = 0;",
            "        for (SweepEvent event : events) {",
            "            active += event.type;",
            "            maxActive = Math.max(maxActive, active);",
            "        }",
            "        return maxActive;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: algosweepline -> O(N log N) Processes 1D geometry/intervals via chronological event sorting"
    },
    "CP Algo: Meet in the Middle (Subset Sum <= 40)": {
        "scope": "java",
        "prefix": "algomeetmiddle",
        "body": [
            "    // Solves Subset Sum and Knapsack variations where N <= 40 (O(2^N) is TLE).",
            "    static long meetInTheMiddle(long[] a, long target) {",
            "        int n = a.length;",
            "        int mid = n / 2;",
            "        ",
            "        List<Long> leftSums = new ArrayList<>();",
            "        List<Long> rightSums = new ArrayList<>();",
            "        ",
            "        // Generate all 2^(N/2) sums for left half",
            "        for (int i = 0; i < (1 << mid); i++) {",
            "            long sum = 0;",
            "            for (int j = 0; j < mid; j++) if ((i & (1 << j)) != 0) sum += a[j];",
            "            leftSums.add(sum);",
            "        }",
            "        ",
            "        // Generate all 2^(N - N/2) sums for right half",
            "        int rightSize = n - mid;",
            "        for (int i = 0; i < (1 << rightSize); i++) {",
            "            long sum = 0;",
            "            for (int j = 0; j < rightSize; j++) if ((i & (1 << j)) != 0) sum += a[mid + j];",
            "            rightSums.add(sum);",
            "        }",
            "        ",
            "        Collections.sort(rightSums);",
            "        long closestSum = 0;",
            "        ",
            "        for (long leftSum : leftSums) {",
            "            if (leftSum > target) continue;",
            "            long remainder = target - leftSum;",
            "            ",
            "            // Binary Search to find the largest rightSum <= remainder",
            "            int l = 0, r = rightSums.size() - 1, bestIdx = -1;",
            "            while (l <= r) {",
            "                int m = l + (r - l) / 2;",
            "                if (rightSums.get(m) <= remainder) {",
            "                    bestIdx = m;",
            "                    l = m + 1;",
            "                } else {",
            "                    r = m - 1;",
            "                }",
            "            }",
            "            if (bestIdx != -1) {",
            "                closestSum = Math.max(closestSum, leftSum + rightSums.get(bestIdx));",
            "            }",
            "        }",
            "        return closestSum;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: algomeetmiddle -> O(2^(N/2) * log(2^(N/2))) Cracks O(2^N) constraints by splitting search space"
    },
    "CP Algo: Ternary Search (Min/Max of Unimodal Function)": {
        "scope": "java",
        "prefix": "algoternary",
        "body": [
            "    // Used for Geometry, physics formulas, and continuous convex/concave functions.",
            "    static double f(double x) {",
            "        // Define unimodal function here",
            "        return -(x * x) + 5 * x + 10; ",
            "    }",
            "",
            "    static double ternarySearch(double l, double r) {",
            "        double EPS = 1e-9;",
            "        // Use exact loop counts (e.g., 200 iterations) for extreme precision safety without infinite loops",
            "        for (int i = 0; i < 200; i++) {",
            "            double m1 = l + (r - l) / 3.0;",
            "            double m2 = r - (r - l) / 3.0;",
            "            ",
            "            if (f(m1) < f(m2)) {",
            "                l = m1; // Finding MAXIMUM. Reverse for minimum.",
            "            } else {",
            "                r = m2;",
            "            }",
            "        }",
            "        return f(l); // Return f(l) for max value, or l for the x-coordinate",
            "    }",
            "    $0"
        ],
        "description": "Prefix: algoternary -> O(log_1.5 N) Finds peak/valley of continuous or discrete unimodal graphs"
    },
    "CP Algo: 2D Fenwick Tree (Binary Indexed Tree)": {
        "scope": "java",
        "prefix": "algobit2d",
        "body": [
            "    static class FenwickTree2D {",
            "        long[][] tree;",
            "        int r, c;",
            "        FenwickTree2D(int r, int c) {",
            "            this.r = r; this.c = c;",
            "            tree = new long[r + 1][c + 1];",
            "        }",
            "        ",
            "        // 1-indexed coordinates.",
            "        void add(int x, int y, long delta) {",
            "            for (int i = x; i <= r; i += i & -i) {",
            "                for (int j = y; j <= c; j += j & -j) {",
            "                    tree[i][j] += delta;",
            "                }",
            "            }",
            "        }",
            "        ",
            "        long query(int x, int y) {",
            "            long sum = 0;",
            "            for (int i = x; i > 0; i -= i & -i) {",
            "                for (int j = y; j > 0; j -= j & -j) {",
            "                    sum += tree[i][j];",
            "                }",
            "            }",
            "            return sum;",
            "        }",
            "        ",
            "        // Query exact submatrix from (x1, y1) to (x2, y2)",
            "        long queryRect(int x1, int y1, int x2, int y2) {",
            "            return query(x2, y2) - query(x1 - 1, y2) - query(x2, y1 - 1) + query(x1 - 1, y1 - 1);",
            "        }",
            "    }",
            "    $0"
        ],
        "description": "Prefix: algobit2d -> O(log R * log C) Dynamic 2D Prefix Sums with Point Updates"
    },
    "CP Algo: Simulated Annealing (Heuristic Optimization)": {
        "scope": "java",
        "prefix": "algosiman",
        "body": [
            "    // USE CASE: NP-Hard problems (TSP variations, complex geometry packing) when N is too large.",
            "    static double solveSimulatedAnnealing() {",
            "        double temp = 10000.0;",
            "        double coolingRate = 0.995;",
            "        double absoluteTemp = 0.00001;",
            "        ",
            "        // Define initial state and calculate its energy (cost/score)",
            "        double currentEnergy = calculateEnergy(/* initialState */);",
            "        double bestEnergy = currentEnergy;",
            "        ",
            "        Random rand = new Random();",
            "        ",
            "        while (temp > absoluteTemp) {",
            "            // Create a small random modification to the state (e.g., swap two elements)",
            "            double neighborEnergy = calculateEnergy(/* modifiedState */);",
            "            ",
            "            // If it's better, or if probability function allows a worse move to escape local minima",
            "            if (neighborEnergy < currentEnergy || Math.exp((currentEnergy - neighborEnergy) / temp) > rand.nextDouble()) {",
            "                currentEnergy = neighborEnergy;",
            "                // Apply the modification permanently to the state",
            "                ",
            "                if (currentEnergy < bestEnergy) {",
            "                    bestEnergy = currentEnergy;",
            "                    // Save best absolute state",
            "                }",
            "            } else {",
            "                // Revert the modification",
            "            }",
            "            temp *= coolingRate;",
            "        }",
            "        return bestEnergy;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: algosiman -> Probabilistic approximation algorithm to break NP-Complete TLE barriers"
    },
    "CP Algo: QuickSelect (O(N) K-th Smallest/Largest)": {
        "scope": "java",
        "prefix": "algoquickselect",
        "body": [
            "    // Finds the K-th smallest element (0-indexed) in O(N) average time.",
            "    // Modifies the array in place.",
            "    static int quickSelect(int[] a, int left, int right, int k) {",
            "        if (left == right) return a[left];",
            "        ",
            "        // Random pivot to prevent O(N^2) worst case on sorted arrays",
            "        int pivotIndex = left + (int)(Math.random() * (right - left + 1));",
            "        pivotIndex = partition(a, left, right, pivotIndex);",
            "        ",
            "        if (k == pivotIndex) return a[k];",
            "        else if (k < pivotIndex) return quickSelect(a, left, pivotIndex - 1, k);",
            "        else return quickSelect(a, pivotIndex + 1, right, k);",
            "    }",
            "",
            "    static int partition(int[] a, int left, int right, int pivotIndex) {",
            "        int pivotValue = a[pivotIndex];",
            "        swap(a, pivotIndex, right); // Move pivot to end",
            "        int storeIndex = left;",
            "        for (int i = left; i < right; i++) {",
            "            if (a[i] < pivotValue) {",
            "                swap(a, storeIndex, i);",
            "                storeIndex++;",
            "            }",
            "        }",
            "        swap(a, right, storeIndex); // Move pivot to its final place",
            "        return storeIndex;",
            "    }",
            "",
            "    static void swap(int[] a, int i, int j) {",
            "        int temp = a[i]; a[i] = a[j]; a[j] = temp;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: algoquickselect -> O(N) average time selection algorithm, avoiding O(N log N) sorting overhead"
    },
    "CP Algo: Merge Sort Tree (Segment Tree of Arrays)": {
        "scope": "java",
        "prefix": "algomergesorttree",
        "body": [
            "    // Answers queries like: \"How many elements in range [L, R] are strictly less than K?\"",
            "    static class MergeSortTree {",
            "        List<Integer>[] tree;",
            "        int n;",
            "        ",
            "        MergeSortTree(int[] a) {",
            "            n = a.length;",
            "            tree = new ArrayList[4 * n];",
            "            for (int i = 0; i < tree.length; i++) tree[i] = new ArrayList<>();",
            "            build(1, 0, n - 1, a);",
            "        }",
            "        ",
            "        void build(int node, int start, int end, int[] a) {",
            "            if (start == end) {",
            "                tree[node].add(a[start]);",
            "                return;",
            "            }",
            "            int mid = (start + end) / 2;",
            "            build(2 * node, start, mid, a);",
            "            build(2 * node + 1, mid + 1, end, a);",
            "            ",
            "            // Merge the two sorted child arrays into the parent node",
            "            int i = 0, j = 0;",
            "            List<Integer> left = tree[2 * node];",
            "            List<Integer> right = tree[2 * node + 1];",
            "            while (i < left.size() && j < right.size()) {",
            "                if (left.get(i) <= right.get(j)) tree[node].add(left.get(i++));",
            "                else tree[node].add(right.get(j++));",
            "            }",
            "            while (i < left.size()) tree[node].add(left.get(i++));",
            "            while (j < right.size()) tree[node].add(right.get(j++));",
            "        }",
            "        ",
            "        // Returns count of elements strictly less than K in range [l, r]",
            "        int query(int node, int start, int end, int l, int r, int k) {",
            "            if (start > end || start > r || end < l) return 0;",
            "            if (start >= l && end <= r) {",
            "                // Binary Search (Lower Bound) inside the node's list",
            "                int lSearch = 0, rSearch = tree[node].size();",
            "                while (lSearch < rSearch) {",
            "                    int mid = lSearch + (rSearch - lSearch) / 2;",
            "                    if (tree[node].get(mid) < k) lSearch = mid + 1;",
            "                    else rSearch = mid;",
            "                }",
            "                return lSearch;",
            "            }",
            "            int mid = (start + end) / 2;",
            "            return query(2 * node, start, mid, l, r, k) + ",
            "                   query(2 * node + 1, mid + 1, end, l, r, k);",
            "        }",
            "    }",
            "    $0"
        ],
        "description": "Prefix: algomergesorttree -> O(N log N) build, O(log^2 N) query for dynamic range counting"
    }
}