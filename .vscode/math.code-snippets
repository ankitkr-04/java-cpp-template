{
    "CP Math: GCD & LCM": {
        "scope": "java",
        "prefix": "mathgcd",
        "body": [
            "    static long gcd(long a, long b) {",
            "        while (b != 0) {",
            "            long t = b;",
            "            b = a % b;",
            "            a = t;",
            "        }",
            "        return a;",
            "    }",
            "",
            "    static long lcm(long a, long b) {",
            "        return (a / gcd(a, b)) * b;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: mathgcd -> Standard iterative GCD and LCM"
    },
    "CP Math: Extended Euclidean Algorithm": {
        "scope": "java",
        "prefix": "mathextgcd",
        "body": [
            "    // Returns {gcd(a, b), x, y} such that a*x + b*y = gcd(a, b)",
            "    static long[] extendedGCD(long a, long b) {",
            "        if (b == 0) return new long[]{a, 1, 0};",
            "        long[] res = extendedGCD(b, a % b);",
            "        long x1 = res[1];",
            "        long y1 = res[2];",
            "        res[1] = y1;",
            "        res[2] = x1 - y1 * (a / b);",
            "        return res;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: mathextgcd -> Solves Ax + By = GCD(A, B) and advanced mod inverses"
    },
    "CP Math: Fast Modular Exponentiation & Inverse": {
        "scope": "java",
        "prefix": "mathmod",
        "body": [
            "    static long modPow(long base, long exp, long mod) {",
            "        long res = 1;",
            "        base %= mod;",
            "        while (exp > 0) {",
            "            if ((exp & 1) == 1) res = (res * base) % mod;",
            "            base = (base * base) % mod;",
            "            exp >>= 1;",
            "        }",
            "        return res;",
            "    }",
            "",
            "    static long modInverse(long n, long mod) {",
            "        return modPow(n, mod - 2, mod); // Valid ONLY if mod is a prime number",
            "    }",
            "    $0"
        ],
        "description": "Prefix: mathmod -> Fast exponentiation (base^exp % mod) and Modular Inverse"
    },
    "CP Math: Safe Modulo Arithmetic": {
        "scope": "java",
        "prefix": "mathsafemod",
        "body": [
            "    static long modAdd(long a, long b, long m) { return ((a % m) + (b % m)) % m; }",
            "    static long modSub(long a, long b, long m) { return ((a % m) - (b % m) + m) % m; }",
            "    static long modMul(long a, long b, long m) { return ((a % m) * (b % m)) % m; }",
            "    $0"
        ],
        "description": "Prefix: mathsafemod -> Safe addition, subtraction, and multiplication preventing negative modulo bugs"
    },
    "CP Math: Sieve & SPF (Fast Factorization)": {
        "scope": "java",
        "prefix": "mathsieve",
        "body": [
            "    static boolean[] isPrime;",
            "    static int[] spf; // Smallest Prime Factor",
            "",
            "    static void sieve(int n) {",
            "        isPrime = new boolean[n + 1];",
            "        spf = new int[n + 1];",
            "        Arrays.fill(isPrime, true);",
            "        isPrime[0] = isPrime[1] = false;",
            "        for (int i = 2; i <= n; i++) spf[i] = i;",
            "",
            "        for (int p = 2; p * p <= n; p++) {",
            "            if (isPrime[p]) {",
            "                for (int i = p * p; i <= n; i += p) {",
            "                    isPrime[i] = false;",
            "                    if (spf[i] == i) spf[i] = p;",
            "                }",
            "            }",
            "        }",
            "    }",
            "",
            "    static List<Integer> getFactorsFast(int n) {",
            "        List<Integer> factors = new ArrayList<>();",
            "        while (n != 1) {",
            "            factors.add(spf[n]);",
            "            n /= spf[n];",
            "        }",
            "        return factors;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: mathsieve -> Global Sieve + SPF for O(log N) prime factorization"
    },
    "CP Math: Basic Prime Check & Factorization": {
        "scope": "java",
        "prefix": "mathprime",
        "body": [
            "    static boolean isPrime(long n) {",
            "        if (n <= 1) return false;",
            "        if (n <= 3) return true;",
            "        if (n % 2 == 0 || n % 3 == 0) return false;",
            "        for (long i = 5; i * i <= n; i += 6) {",
            "            if (n % i == 0 || n % (i + 2) == 0) return false;",
            "        }",
            "        return true;",
            "    }",
            "",
            "    static Map<Long, Integer> primeFactors(long n) {",
            "        Map<Long, Integer> factors = new HashMap<>();",
            "        for (long d = 2; d * d <= n; d++) {",
            "            int count = 0;",
            "            while (n % d == 0) {",
            "                count++;",
            "                n /= d;",
            "            }",
            "            if (count > 0) factors.put(d, count);",
            "        }",
            "        if (n > 1) factors.put(n, 1);",
            "        return factors;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: mathprime -> O(sqrt(N)) Prime Check and Prime Factorization (returns Map)"
    },
    "CP Math: O(1) Probable Prime (Miller-Rabin Hack)": {
        "scope": "java",
        "prefix": "mathprimefast",
        "body": [
            "    static boolean isPrimeFast(long n) {",
            "        if (n <= 1) return false;",
            "        if (n <= 3) return true;",
            "        // 15 certainty is enough for numbers up to 10^18 in competitive programming",
            "        return java.math.BigInteger.valueOf(n).isProbablePrime(15);",
            "    }",
            "    $0"
        ],
        "description": "Prefix: mathprimefast -> Optimized Miller-Rabin prime check for massive numbers (10^18)"
    },
    "CP Math: Divisors of a Number": {
        "scope": "java",
        "prefix": "mathdivisors",
        "body": [
            "    static List<Long> getDivisors(long n) {",
            "        List<Long> div = new ArrayList<>();",
            "        for (long i = 1; i * i <= n; i++) {",
            "            if (n % i == 0) {",
            "                div.add(i);",
            "                if (i * i != n) div.add(n / i);",
            "            }",
            "        }",
            "        Collections.sort(div);",
            "        return div;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: mathdivisors -> Gets all divisors of N in O(sqrt(N)) and sorts them"
    },
    "CP Math: Euler's Totient Function (Phi)": {
        "scope": "java",
        "prefix": "mathphi",
        "body": [
            "    // Counts numbers <= n that are coprime to n",
            "    static long phi(long n) {",
            "        long result = n;",
            "        for (long p = 2; p * p <= n; p++) {",
            "            if (n % p == 0) {",
            "                while (n % p == 0) n /= p;",
            "                result -= result / p;",
            "            }",
            "        }",
            "        if (n > 1) result -= result / n;",
            "        return result;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: mathphi -> Euler's Totient (coprime count) in O(sqrt(N))"
    },
    "CP Math: Combinatorics (nCr, nPr with Modulo)": {
        "scope": "java",
        "prefix": "mathncr",
        "body": [
            "    static long[] fact, invFact;",
            "    static void precomputeFactorials(int n, long mod) {",
            "        fact = new long[n + 1];",
            "        invFact = new long[n + 1];",
            "        fact[0] = 1;",
            "        invFact[0] = 1;",
            "        for (int i = 1; i <= n; i++) {",
            "            fact[i] = (fact[i - 1] * i) % mod;",
            "        }",
            "        invFact[n] = modPow(fact[n], mod - 2, mod);",
            "        for (int i = n - 1; i >= 1; i--) {",
            "            invFact[i] = (invFact[i + 1] * (i + 1)) % mod;",
            "        }",
            "    }",
            "",
            "    static long nCr(int n, int r, long mod) {",
            "        if (r < 0 || r > n) return 0;",
            "        return fact[n] * invFact[r] % mod * invFact[n - r] % mod;",
            "    }",
            "",
            "    static long nPr(int n, int r, long mod) {",
            "        if (r < 0 || r > n) return 0;",
            "        return fact[n] * invFact[n - r] % mod;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: mathncr -> Precomputes Factorials and calculates nCr / nPr in O(1) time"
    },
    "CP Math: Iterative nCr (Huge N, Small R)": {
        "scope": "java",
        "prefix": "mathncriter",
        "body": [
            "    static long nCrIterative(long n, long r) {",
            "        if (r < 0 || r > n) return 0;",
            "        if (r > n / 2) r = n - r;",
            "        long res = 1;",
            "        for (long i = 1; i <= r; i++) {",
            "            res = res * (n - i + 1) / i;",
            "        }",
            "        return res;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: mathncriter -> O(R) time nCr without modulo. Best when N is huge but R is small."
    },
    "CP Math: Pascal's Triangle (nCr without Modulo)": {
        "scope": "java",
        "prefix": "mathpascal",
        "body": [
            "    static long[][] C;",
            "    static void buildPascal(int n) {",
            "        C = new long[n + 1][n + 1];",
            "        for (int i = 0; i <= n; i++) {",
            "            C[i][0] = 1;",
            "            for (int j = 1; j <= i; j++) {",
            "                C[i][j] = C[i - 1][j - 1] + C[i - 1][j];",
            "            }",
            "        }",
            "    }",
            "    // Safe for N <= 60 without overflowing standard long",
            "    $0"
        ],
        "description": "Prefix: mathpascal -> Global 2D array for exact nCr combinations (No Modulo)"
    },
    "CP Math: Catalan Numbers (O(N) with Modulo)": {
        "scope": "java",
        "prefix": "mathcatalan",
        "body": [
            "    static long[] generateCatalan(int n, long mod) {",
            "        long[] cat = new long[n + 1];",
            "        cat[0] = cat[1] = 1;",
            "        for (int i = 2; i <= n; i++) {",
            "            for (int j = 0; j < i; j++) {",
            "                cat[i] = (cat[i] + (cat[j] * cat[i - j - 1]) % mod) % mod;",
            "            }",
            "        }",
            "        return cat;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: mathcatalan -> Bracket matching, BST arrangements, chord intersections"
    },
    "CP Math: Matrix Exponentiation": {
        "scope": "java",
        "prefix": "mathmatexpo",
        "body": [
            "    static long[][] matMul(long[][] A, long[][] B, long mod) {",
            "        int rA = A.length, cA = A[0].length, cB = B[0].length;",
            "        long[][] C = new long[rA][cB];",
            "        for (int i = 0; i < rA; i++)",
            "            for (int j = 0; j < cB; j++)",
            "                for (int k = 0; k < cA; k++)",
            "                    C[i][j] = (C[i][j] + A[i][k] * B[k][j]) % mod;",
            "        return C;",
            "    }",
            "",
            "    static long[][] matPow(long[][] A, long exp, long mod) {",
            "        int n = A.length;",
            "        long[][] res = new long[n][n];",
            "        for (int i = 0; i < n; i++) res[i][i] = 1; // Identity matrix",
            "        while (exp > 0) {",
            "            if ((exp & 1) == 1) res = matMul(res, A, mod);",
            "            A = matMul(A, A, mod);",
            "            exp >>= 1;",
            "        }",
            "        return res;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: mathmatexpo -> O(K^3 log N) linear recurrences (e.g., massive Fibonacci)"
    },
    "CP Math: 2D Prefix Sums (Grid Math)": {
        "scope": "java",
        "prefix": "mathprefix2d",
        "body": [
            "    static long[][] build2DPrefixSum(int[][] grid) {",
            "        int r = grid.length, c = grid[0].length;",
            "        long[][] pref = new long[r + 1][c + 1];",
            "        for (int i = 1; i <= r; i++) {",
            "            for (int j = 1; j <= c; j++) {",
            "                pref[i][j] = grid[i - 1][j - 1] ",
            "                           + pref[i - 1][j] + pref[i][j - 1] ",
            "                           - pref[i - 1][j - 1];",
            "            }",
            "        }",
            "        return pref;",
            "    }",
            "",
            "    // Query sum of subgrid from (r1, c1) to (r2, c2) in O(1). 0-indexed.",
            "    static long query2DPrefix(long[][] pref, int r1, int c1, int r2, int c2) {",
            "        return pref[r2 + 1][c2 + 1] ",
            "             - pref[r1][c2 + 1] - pref[r2 + 1][c1] ",
            "             + pref[r1][c1];",
            "    }",
            "    $0"
        ],
        "description": "Prefix: mathprefix2d -> O(1) sum queries for subgrids/matrices"
    },
    "CP Math: Fast Fibonacci (Doubling Method O(log N))": {
        "scope": "java",
        "prefix": "mathfibo",
        "body": [
            "    // Returns {F_n, F_{n+1}} in O(log N)",
            "    static long[] fastFibonacci(long n, long mod) {",
            "        if (n == 0) return new long[]{0, 1};",
            "        long[] p = fastFibonacci(n >> 1, mod);",
            "        long c = p[0] * ((p[1] << 1) % mod - p[0] + mod) % mod;",
            "        long d = (p[0] * p[0] % mod + p[1] * p[1] % mod) % mod;",
            "        if ((n & 1) == 1) return new long[]{d, (c + d) % mod};",
            "        return new long[]{c, d};",
            "    }",
            "    $0"
        ],
        "description": "Prefix: mathfibo -> Lightning fast N-th Fibonacci up to 10^18"
    },
    "CP Math: Fast Bitwise Utilities": {
        "scope": "java",
        "prefix": "mathbit",
        "body": [
            "    static boolean isPowerOfTwo(long n) {",
            "        return n > 0 && (n & (n - 1)) == 0;",
            "    }",
            "",
            "    static long nextPowerOfTwo(long n) {",
            "        n--;",
            "        n |= n >> 1; n |= n >> 2;",
            "        n |= n >> 4; n |= n >> 8;",
            "        n |= n >> 16; n |= n >> 32;",
            "        return n + 1;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: mathbit -> Bit manipulation checks (powers of two)"
    },
    "CP Math: Base Converter (String <-> Base)": {
        "scope": "java",
        "prefix": "mathbase",
        "body": [
            "    static long toDecimal(String s, int base) {",
            "        return Long.parseLong(s, base);",
            "    }",
            "",
            "    static String fromDecimal(long n, int base) {",
            "        return Long.toString(n, base).toUpperCase();",
            "    }",
            "    $0"
        ],
        "description": "Prefix: mathbase -> Quickly shift numbers between bases (Binary, Hex, Custom)"
    }
}