{
    "CP Algo: Lazy Propagation Segment Tree": {
        "scope": "java",
        "prefix": "algosegtreelazy",
        "body": [
            "    static class LazySegmentTree {",
            "        long[] tree, lazy;",
            "        int n;",
            "",
            "        LazySegmentTree(int n) {",
            "            this.n = n;",
            "            tree = new long[4 * n];",
            "            lazy = new long[4 * n];",
            "        }",
            "",
            "        void push(int node, int start, int end) {",
            "            if (lazy[node] != 0) {",
            "                tree[node] += lazy[node] * (end - start + 1); // For Sum Query. (Just lazy[node] for Min/Max)",
            "                if (start != end) {",
            "                    lazy[2 * node] += lazy[node];",
            "                    lazy[2 * node + 1] += lazy[node];",
            "                }",
            "                lazy[node] = 0;",
            "            }",
            "        }",
            "",
            "        void updateRange(int node, int start, int end, int l, int r, long val) {",
            "            push(node, start, end);",
            "            if (start > end || start > r || end < l) return;",
            "            if (start >= l && end <= r) {",
            "                lazy[node] += val;",
            "                push(node, start, end);",
            "                return;",
            "            }",
            "            int mid = (start + end) / 2;",
            "            updateRange(2 * node, start, mid, l, r, val);",
            "            updateRange(2 * node + 1, mid + 1, end, l, r, val);",
            "            tree[node] = tree[2 * node] + tree[2 * node + 1]; // Merge logic",
            "        }",
            "",
            "        long queryRange(int node, int start, int end, int l, int r) {",
            "            if (start > end || start > r || end < l) return 0; // 0 for Sum, INF for Min",
            "            push(node, start, end);",
            "            if (start >= l && end <= r) return tree[node];",
            "            int mid = (start + end) / 2;",
            "            long p1 = queryRange(2 * node, start, mid, l, r);",
            "            long p2 = queryRange(2 * node + 1, mid + 1, end, l, r);",
            "            return p1 + p2; // Merge logic",
            "        }",
            "        ",
            "        // Wrappers for 0-indexed usage",
            "        void update(int l, int r, long val) { updateRange(1, 0, n - 1, l, r, val); }",
            "        long query(int l, int r) { return queryRange(1, 0, n - 1, l, r); }",
            "    }",
            "    $0"
        ],
        "description": "Prefix: algosegtreelazy -> O(log N) Range Updates and Range Queries"
    },
    "CP Algo: Sweep Line (Interval Overlaps / Max Depth)": {
        "scope": "java",
        "prefix": "algosweepline",
        "body": [
            "    static class SweepEvent implements Comparable<SweepEvent> {",
            "        long x;",
            "        int type; // +1 for start, -1 for end",
            "        SweepEvent(long x, int type) { this.x = x; this.type = type; }",
            "        public int compareTo(SweepEvent o) {",
            "            if (this.x != o.x) return Long.compare(this.x, o.x);",
            "            return Integer.compare(this.type, o.type); // Process ends (-1) before starts (+1) to avoid false overlaps",
            "        }",
            "    }",
            "",
            "    static int maxOverlappingIntervals(long[][] intervals) {",
            "        List<SweepEvent> events = new ArrayList<>();",
            "        for (long[] interval : intervals) {",
            "            events.add(new SweepEvent(interval[0], 1));",
            "            events.add(new SweepEvent(interval[1], -1));",
            "        }",
            "        Collections.sort(events);",
            "        ",
            "        int active = 0, maxActive = 0;",
            "        for (SweepEvent event : events) {",
            "            active += event.type;",
            "            maxActive = Math.max(maxActive, active);",
            "        }",
            "        return maxActive;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: algosweepline -> O(N log N) Processes 1D geometry/intervals via chronological event sorting"
    },
    "CP Algo: Meet in the Middle (Subset Sum <= 40)": {
        "scope": "java",
        "prefix": "algomeetmiddle",
        "body": [
            "    // Solves Subset Sum and Knapsack variations where N <= 40 (O(2^N) is TLE).",
            "    static long meetInTheMiddle(long[] a, long target) {",
            "        int n = a.length;",
            "        int mid = n / 2;",
            "        ",
            "        List<Long> leftSums = new ArrayList<>();",
            "        List<Long> rightSums = new ArrayList<>();",
            "        ",
            "        // Generate all 2^(N/2) sums for left half",
            "        for (int i = 0; i < (1 << mid); i++) {",
            "            long sum = 0;",
            "            for (int j = 0; j < mid; j++) if ((i & (1 << j)) != 0) sum += a[j];",
            "            leftSums.add(sum);",
            "        }",
            "        ",
            "        // Generate all 2^(N - N/2) sums for right half",
            "        int rightSize = n - mid;",
            "        for (int i = 0; i < (1 << rightSize); i++) {",
            "            long sum = 0;",
            "            for (int j = 0; j < rightSize; j++) if ((i & (1 << j)) != 0) sum += a[mid + j];",
            "            rightSums.add(sum);",
            "        }",
            "        ",
            "        Collections.sort(rightSums);",
            "        long closestSum = 0;",
            "        ",
            "        for (long leftSum : leftSums) {",
            "            if (leftSum > target) continue;",
            "            long remainder = target - leftSum;",
            "            ",
            "            // Binary Search to find the largest rightSum <= remainder",
            "            int l = 0, r = rightSums.size() - 1, bestIdx = -1;",
            "            while (l <= r) {",
            "                int m = l + (r - l) / 2;",
            "                if (rightSums.get(m) <= remainder) {",
            "                    bestIdx = m;",
            "                    l = m + 1;",
            "                } else {",
            "                    r = m - 1;",
            "                }",
            "            }",
            "            if (bestIdx != -1) {",
            "                closestSum = Math.max(closestSum, leftSum + rightSums.get(bestIdx));",
            "            }",
            "        }",
            "        return closestSum;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: algomeetmiddle -> O(2^(N/2) * log(2^(N/2))) Cracks O(2^N) constraints by splitting search space"
    },
    "CP Algo: Ternary Search (Min/Max of Unimodal Function)": {
        "scope": "java",
        "prefix": "algoternary",
        "body": [
            "    // Used for Geometry, physics formulas, and continuous convex/concave functions.",
            "    static double f(double x) {",
            "        // Define unimodal function here",
            "        return -(x * x) + 5 * x + 10; ",
            "    }",
            "",
            "    static double ternarySearch(double l, double r) {",
            "        double EPS = 1e-9;",
            "        // Use exact loop counts (e.g., 200 iterations) for extreme precision safety without infinite loops",
            "        for (int i = 0; i < 200; i++) {",
            "            double m1 = l + (r - l) / 3.0;",
            "            double m2 = r - (r - l) / 3.0;",
            "            ",
            "            if (f(m1) < f(m2)) {",
            "                l = m1; // Finding MAXIMUM. Reverse for minimum.",
            "            } else {",
            "                r = m2;",
            "            }",
            "        }",
            "        return f(l); // Return f(l) for max value, or l for the x-coordinate",
            "    }",
            "    $0"
        ],
        "description": "Prefix: algoternary -> O(log_1.5 N) Finds peak/valley of continuous or discrete unimodal graphs"
    },
    "CP Algo: 2D Fenwick Tree (Binary Indexed Tree)": {
        "scope": "java",
        "prefix": "algobit2d",
        "body": [
            "    static class FenwickTree2D {",
            "        long[][] tree;",
            "        int r, c;",
            "        FenwickTree2D(int r, int c) {",
            "            this.r = r; this.c = c;",
            "            tree = new long[r + 1][c + 1];",
            "        }",
            "        ",
            "        // 1-indexed coordinates.",
            "        void add(int x, int y, long delta) {",
            "            for (int i = x; i <= r; i += i & -i) {",
            "                for (int j = y; j <= c; j += j & -j) {",
            "                    tree[i][j] += delta;",
            "                }",
            "            }",
            "        }",
            "        ",
            "        long query(int x, int y) {",
            "            long sum = 0;",
            "            for (int i = x; i > 0; i -= i & -i) {",
            "                for (int j = y; j > 0; j -= j & -j) {",
            "                    sum += tree[i][j];",
            "                }",
            "            }",
            "            return sum;",
            "        }",
            "        ",
            "        // Query exact submatrix from (x1, y1) to (x2, y2)",
            "        long queryRect(int x1, int y1, int x2, int y2) {",
            "            return query(x2, y2) - query(x1 - 1, y2) - query(x2, y1 - 1) + query(x1 - 1, y1 - 1);",
            "        }",
            "    }",
            "    $0"
        ],
        "description": "Prefix: algobit2d -> O(log R * log C) Dynamic 2D Prefix Sums with Point Updates"
    },
    "CP Algo: Simulated Annealing (Heuristic Optimization)": {
        "scope": "java",
        "prefix": "algosiman",
        "body": [
            "    // USE CASE: NP-Hard problems (TSP variations, complex geometry packing) when N is too large.",
            "    static double solveSimulatedAnnealing() {",
            "        double temp = 10000.0;",
            "        double coolingRate = 0.995;",
            "        double absoluteTemp = 0.00001;",
            "        ",
            "        // Define initial state and calculate its energy (cost/score)",
            "        double currentEnergy = calculateEnergy(/* initialState */);",
            "        double bestEnergy = currentEnergy;",
            "        ",
            "        Random rand = new Random();",
            "        ",
            "        while (temp > absoluteTemp) {",
            "            // Create a small random modification to the state (e.g., swap two elements)",
            "            double neighborEnergy = calculateEnergy(/* modifiedState */);",
            "            ",
            "            // If it's better, or if probability function allows a worse move to escape local minima",
            "            if (neighborEnergy < currentEnergy || Math.exp((currentEnergy - neighborEnergy) / temp) > rand.nextDouble()) {",
            "                currentEnergy = neighborEnergy;",
            "                // Apply the modification permanently to the state",
            "                ",
            "                if (currentEnergy < bestEnergy) {",
            "                    bestEnergy = currentEnergy;",
            "                    // Save best absolute state",
            "                }",
            "            } else {",
            "                // Revert the modification",
            "            }",
            "            temp *= coolingRate;",
            "        }",
            "        return bestEnergy;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: algosiman -> Probabilistic approximation algorithm to break NP-Complete TLE barriers"
    },
    "CP Algo: QuickSelect (O(N) K-th Smallest/Largest)": {
        "scope": "java",
        "prefix": "algoquickselect",
        "body": [
            "    // Finds the K-th smallest element (0-indexed) in O(N) average time.",
            "    // Modifies the array in place.",
            "    static int quickSelect(int[] a, int left, int right, int k) {",
            "        if (left == right) return a[left];",
            "        ",
            "        // Random pivot to prevent O(N^2) worst case on sorted arrays",
            "        int pivotIndex = left + (int)(Math.random() * (right - left + 1));",
            "        pivotIndex = partition(a, left, right, pivotIndex);",
            "        ",
            "        if (k == pivotIndex) return a[k];",
            "        else if (k < pivotIndex) return quickSelect(a, left, pivotIndex - 1, k);",
            "        else return quickSelect(a, pivotIndex + 1, right, k);",
            "    }",
            "",
            "    static int partition(int[] a, int left, int right, int pivotIndex) {",
            "        int pivotValue = a[pivotIndex];",
            "        swap(a, pivotIndex, right); // Move pivot to end",
            "        int storeIndex = left;",
            "        for (int i = left; i < right; i++) {",
            "            if (a[i] < pivotValue) {",
            "                swap(a, storeIndex, i);",
            "                storeIndex++;",
            "            }",
            "        }",
            "        swap(a, right, storeIndex); // Move pivot to its final place",
            "        return storeIndex;",
            "    }",
            "",
            "    static void swap(int[] a, int i, int j) {",
            "        int temp = a[i]; a[i] = a[j]; a[j] = temp;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: algoquickselect -> O(N) average time selection algorithm, avoiding O(N log N) sorting overhead"
    },
    "CP Algo: Merge Sort Tree (Segment Tree of Arrays)": {
        "scope": "java",
        "prefix": "algomergesorttree",
        "body": [
            "    // Answers queries like: \"How many elements in range [L, R] are strictly less than K?\"",
            "    static class MergeSortTree {",
            "        List<Integer>[] tree;",
            "        int n;",
            "        ",
            "        MergeSortTree(int[] a) {",
            "            n = a.length;",
            "            tree = new ArrayList[4 * n];",
            "            for (int i = 0; i < tree.length; i++) tree[i] = new ArrayList<>();",
            "            build(1, 0, n - 1, a);",
            "        }",
            "        ",
            "        void build(int node, int start, int end, int[] a) {",
            "            if (start == end) {",
            "                tree[node].add(a[start]);",
            "                return;",
            "            }",
            "            int mid = (start + end) / 2;",
            "            build(2 * node, start, mid, a);",
            "            build(2 * node + 1, mid + 1, end, a);",
            "            ",
            "            // Merge the two sorted child arrays into the parent node",
            "            int i = 0, j = 0;",
            "            List<Integer> left = tree[2 * node];",
            "            List<Integer> right = tree[2 * node + 1];",
            "            while (i < left.size() && j < right.size()) {",
            "                if (left.get(i) <= right.get(j)) tree[node].add(left.get(i++));",
            "                else tree[node].add(right.get(j++));",
            "            }",
            "            while (i < left.size()) tree[node].add(left.get(i++));",
            "            while (j < right.size()) tree[node].add(right.get(j++));",
            "        }",
            "        ",
            "        // Returns count of elements strictly less than K in range [l, r]",
            "        int query(int node, int start, int end, int l, int r, int k) {",
            "            if (start > end || start > r || end < l) return 0;",
            "            if (start >= l && end <= r) {",
            "                // Binary Search (Lower Bound) inside the node's list",
            "                int lSearch = 0, rSearch = tree[node].size();",
            "                while (lSearch < rSearch) {",
            "                    int mid = lSearch + (rSearch - lSearch) / 2;",
            "                    if (tree[node].get(mid) < k) lSearch = mid + 1;",
            "                    else rSearch = mid;",
            "                }",
            "                return lSearch;",
            "            }",
            "            int mid = (start + end) / 2;",
            "            return query(2 * node, start, mid, l, r, k) + ",
            "                   query(2 * node + 1, mid + 1, end, l, r, k);",
            "        }",
            "    }",
            "    $0"
        ],
        "description": "Prefix: algomergesorttree -> O(N log N) build, O(log^2 N) query for dynamic range counting"
    },
    "CP Algo: Persistent Segment Tree": {
        "scope": "java",
        "prefix": "algopersistent",
        "body": [
            "    static class PersistentSegTree {",
            "        int[] left, right, val;",
            "        int cnt = 0;",
            "",
            "        PersistentSegTree(int maxNodes) {",
            "            left = new int[maxNodes];",
            "            right = new int[maxNodes];",
            "            val = new int[maxNodes];",
            "        }",
            "",
            "        int newNode(int l, int r, int v) {",
            "            left[cnt] = l; right[cnt] = r; val[cnt] = v;",
            "            return cnt++;",
            "        }",
            "",
            "        int build(int lo, int hi) {",
            "            if (lo == hi) return newNode(0, 0, 0);",
            "            int mid = (lo + hi) / 2;",
            "            int l = build(lo, mid);",
            "            int r = build(mid + 1, hi);",
            "            return newNode(l, r, 0);",
            "        }",
            "",
            "        // Point update: create new version by inserting value at position pos",
            "        int update(int prev, int lo, int hi, int pos, int delta) {",
            "            if (lo == hi) return newNode(0, 0, val[prev] + delta);",
            "            int mid = (lo + hi) / 2;",
            "            int l = left[prev], r = right[prev];",
            "            if (pos <= mid) l = update(left[prev], lo, mid, pos, delta);",
            "            else r = update(right[prev], mid + 1, hi, pos, delta);",
            "            return newNode(l, r, val[l] + val[r]);",
            "        }",
            "",
            "        // K-th smallest in range [L, R] using two versions (roots[L-1] and roots[R])",
            "        int kth(int prevRoot, int curRoot, int lo, int hi, int k) {",
            "            if (lo == hi) return lo;",
            "            int mid = (lo + hi) / 2;",
            "            int leftCount = val[left[curRoot]] - val[left[prevRoot]];",
            "            if (k <= leftCount) return kth(left[prevRoot], left[curRoot], lo, mid, k);",
            "            else return kth(right[prevRoot], right[curRoot], mid + 1, hi, k - leftCount);",
            "        }",
            "    }",
            "",
            "    // Usage: Coordinate-compress values, build version 0, then for each element:",
            "    // roots[i] = pst.update(roots[i-1], 0, maxVal-1, compressedVal, 1);",
            "    // Query k-th smallest in [L, R]: pst.kth(roots[L-1], roots[R], 0, maxVal-1, k);",
            "    $0"
        ],
        "description": "Prefix: algopersistent -> O(N log N) Persistent Segment Tree for K-th smallest in range queries"
    },
    "CP Algo: Implicit Treap (Order Statistics + Range Operations)": {
        "scope": "java",
        "prefix": "algotreap",
        "body": [
            "    static class ImplicitTreap {",
            "        static Random rng = new Random(42);",
            "        int[] val, sz, pri;",
            "        int[] left, right;",
            "        long[] sum;",
            "        boolean[] rev;",
            "        int cnt = 0;",
            "",
            "        ImplicitTreap(int maxN) {",
            "            val = new int[maxN]; sz = new int[maxN]; pri = new int[maxN];",
            "            left = new int[maxN]; right = new int[maxN];",
            "            sum = new long[maxN]; rev = new boolean[maxN];",
            "        }",
            "",
            "        int newNode(int v) {",
            "            val[cnt] = v; sz[cnt] = 1; pri[cnt] = rng.nextInt();",
            "            left[cnt] = right[cnt] = -1; sum[cnt] = v; rev[cnt] = false;",
            "            return cnt++;",
            "        }",
            "",
            "        int size(int t) { return t == -1 ? 0 : sz[t]; }",
            "        long getSum(int t) { return t == -1 ? 0 : sum[t]; }",
            "",
            "        void pull(int t) {",
            "            if (t == -1) return;",
            "            sz[t] = 1 + size(left[t]) + size(right[t]);",
            "            sum[t] = val[t] + getSum(left[t]) + getSum(right[t]);",
            "        }",
            "",
            "        void push(int t) {",
            "            if (t != -1 && rev[t]) {",
            "                int tmp = left[t]; left[t] = right[t]; right[t] = tmp;",
            "                if (left[t] != -1) rev[left[t]] ^= true;",
            "                if (right[t] != -1) rev[right[t]] ^= true;",
            "                rev[t] = false;",
            "            }",
            "        }",
            "",
            "        // Returns {leftRoot, rightRoot} splitting at position k (0-indexed, first k elements go left)",
            "        int[] split(int t, int k) {",
            "            if (t == -1) return new int[]{-1, -1};",
            "            push(t);",
            "            int leftSz = size(left[t]);",
            "            if (leftSz >= k) {",
            "                int[] res = split(left[t], k);",
            "                left[t] = res[1]; pull(t);",
            "                return new int[]{res[0], t};",
            "            } else {",
            "                int[] res = split(right[t], k - leftSz - 1);",
            "                right[t] = res[0]; pull(t);",
            "                return new int[]{t, res[1]};",
            "            }",
            "        }",
            "",
            "        int merge(int l, int r) {",
            "            if (l == -1) return r;",
            "            if (r == -1) return l;",
            "            push(l); push(r);",
            "            if (pri[l] > pri[r]) {",
            "                right[l] = merge(right[l], r); pull(l); return l;",
            "            } else {",
            "                left[r] = merge(l, left[r]); pull(r); return r;",
            "            }",
            "        }",
            "",
            "        // Insert value v at position pos (0-indexed)",
            "        int insert(int root, int pos, int v) {",
            "            int[] parts = split(root, pos);",
            "            return merge(merge(parts[0], newNode(v)), parts[1]);",
            "        }",
            "",
            "        // Reverse subarray [l, r] (0-indexed)",
            "        int reverse(int root, int l, int r) {",
            "            int[] ab = split(root, l);",
            "            int[] bc = split(ab[1], r - l + 1);",
            "            rev[bc[0]] ^= true;",
            "            return merge(ab[0], merge(bc[0], bc[1]));",
            "        }",
            "    }",
            "    $0"
        ],
        "description": "Prefix: algotreap -> O(log N) Implicit Treap for insert/delete/reverse/sum at any position"
    },
    "CP Algo: Square Root Decomposition": {
        "scope": "java",
        "prefix": "algosqrt",
        "body": [
            "    static class SqrtDecomp {",
            "        int[] a;",
            "        long[] blockSum;",
            "        int n, blockSize, numBlocks;",
            "",
            "        SqrtDecomp(int[] arr) {",
            "            n = arr.length;",
            "            a = Arrays.copyOf(arr, n);",
            "            blockSize = (int) Math.sqrt(n) + 1;",
            "            numBlocks = (n + blockSize - 1) / blockSize;",
            "            blockSum = new long[numBlocks];",
            "            for (int i = 0; i < n; i++) blockSum[i / blockSize] += a[i];",
            "        }",
            "",
            "        void update(int idx, int val) {",
            "            blockSum[idx / blockSize] += val - a[idx];",
            "            a[idx] = val;",
            "        }",
            "",
            "        long query(int l, int r) {",
            "            long sum = 0;",
            "            int bl = l / blockSize, br = r / blockSize;",
            "            if (bl == br) {",
            "                for (int i = l; i <= r; i++) sum += a[i];",
            "            } else {",
            "                for (int i = l; i < (bl + 1) * blockSize; i++) sum += a[i];",
            "                for (int b = bl + 1; b < br; b++) sum += blockSum[b];",
            "                for (int i = br * blockSize; i <= r; i++) sum += a[i];",
            "            }",
            "            return sum;",
            "        }",
            "    }",
            "    $0"
        ],
        "description": "Prefix: algosqrt -> O(sqrt N) per query/update, simpler alternative to segment tree"
    },
    "CP Algo: Hungarian Algorithm (Min Cost Assignment)": {
        "scope": "java",
        "prefix": "algohungarian",
        "body": [
            "    // Solves the assignment problem: assign N workers to N jobs minimizing total cost",
            "    // cost[i][j] = cost of assigning worker i to job j. O(N^3)",
            "    static long hungarian(long[][] cost) {",
            "        int n = cost.length;",
            "        long[] u = new long[n + 1], v = new long[n + 1];",
            "        int[] p = new int[n + 1], way = new int[n + 1];",
            "",
            "        for (int i = 1; i <= n; i++) {",
            "            p[0] = i;",
            "            int j0 = 0;",
            "            long[] minv = new long[n + 1];",
            "            boolean[] used = new boolean[n + 1];",
            "            Arrays.fill(minv, Long.MAX_VALUE);",
            "",
            "            do {",
            "                used[j0] = true;",
            "                int i0 = p[j0], j1 = 0;",
            "                long delta = Long.MAX_VALUE;",
            "                for (int j = 1; j <= n; j++) {",
            "                    if (!used[j]) {",
            "                        long cur = cost[i0 - 1][j - 1] - u[i0] - v[j];",
            "                        if (cur < minv[j]) { minv[j] = cur; way[j] = j0; }",
            "                        if (minv[j] < delta) { delta = minv[j]; j1 = j; }",
            "                    }",
            "                }",
            "                for (int j = 0; j <= n; j++) {",
            "                    if (used[j]) { u[p[j]] += delta; v[j] -= delta; }",
            "                    else minv[j] -= delta;",
            "                }",
            "                j0 = j1;",
            "            } while (p[j0] != 0);",
            "",
            "            do { int j1 = way[j0]; p[j0] = p[j1]; j0 = j1; } while (j0 != 0);",
            "        }",
            "",
            "        long totalCost = 0;",
            "        int[] assignment = new int[n]; // assignment[j-1] = worker index (0-based)",
            "        for (int j = 1; j <= n; j++) {",
            "            assignment[j - 1] = p[j] - 1;",
            "            totalCost += cost[p[j] - 1][j - 1];",
            "        }",
            "        return totalCost;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: algohungarian -> O(N^3) Optimal assignment of N workers to N jobs"
    }
}