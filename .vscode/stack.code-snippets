{
    "CP Stack: Monotonic Stacks (All Variations)": {
        "scope": "java",
        "prefix": "stackmono",
        "body": [
            "    static class MonotonicStack {",
            "        // Returns array of indices. If no valid element exists, returns defaultVal (-1 or n).",
            "        static int[] nextGreater(int[] a, int defaultVal) {",
            "            int n = a.length;",
            "            int[] res = new int[n];",
            "            Arrays.fill(res, defaultVal);",
            "            int[] stack = new int[n];",
            "            int top = -1;",
            "            for (int i = 0; i < n; i++) {",
            "                while (top >= 0 && a[stack[top]] < a[i]) {",
            "                    res[stack[top--]] = i;",
            "                }",
            "                stack[++top] = i;",
            "            }",
            "            return res;",
            "        }",
            "",
            "        static int[] nextSmaller(int[] a, int defaultVal) {",
            "            int n = a.length;",
            "            int[] res = new int[n];",
            "            Arrays.fill(res, defaultVal);",
            "            int[] stack = new int[n];",
            "            int top = -1;",
            "            for (int i = 0; i < n; i++) {",
            "                while (top >= 0 && a[stack[top]] > a[i]) {",
            "                    res[stack[top--]] = i;",
            "                }",
            "                stack[++top] = i;",
            "            }",
            "            return res;",
            "        }",
            "",
            "        static int[] prevGreater(int[] a, int defaultVal) {",
            "            int n = a.length;",
            "            int[] res = new int[n];",
            "            Arrays.fill(res, defaultVal);",
            "            int[] stack = new int[n];",
            "            int top = -1;",
            "            for (int i = n - 1; i >= 0; i--) {",
            "                while (top >= 0 && a[stack[top]] < a[i]) {",
            "                    res[stack[top--]] = i;",
            "                }",
            "                stack[++top] = i;",
            "            }",
            "            return res;",
            "        }",
            "",
            "        static int[] prevSmaller(int[] a, int defaultVal) {",
            "            int n = a.length;",
            "            int[] res = new int[n];",
            "            Arrays.fill(res, defaultVal);",
            "            int[] stack = new int[n];",
            "            int top = -1;",
            "            for (int i = n - 1; i >= 0; i--) {",
            "                while (top >= 0 && a[stack[top]] > a[i]) {",
            "                    res[stack[top--]] = i;",
            "                }",
            "                stack[++top] = i;",
            "            }",
            "            return res;",
            "        }",
            "    }",
            "    $0"
        ],
        "description": "Prefix: stackmono -> O(N) Next/Prev Greater/Smaller Element using Array-based stack"
    },
    "CP Stack: Largest Rectangle in Histogram": {
        "scope": "java",
        "prefix": "stackhist",
        "body": [
            "    static long maxHistogramArea(long[] heights) {",
            "        int n = heights.length;",
            "        int[] stack = new int[n + 1];",
            "        int top = -1;",
            "        long maxArea = 0;",
            "        ",
            "        for (int i = 0; i <= n; i++) {",
            "            long h = (i == n ? 0 : heights[i]);",
            "            while (top >= 0 && heights[stack[top]] > h) {",
            "                long height = heights[stack[top--]];",
            "                int width = (top == -1) ? i : (i - stack[top] - 1);",
            "                maxArea = Math.max(maxArea, height * width);",
            "            }",
            "            stack[++top] = i;",
            "        }",
            "        return maxArea;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: stackhist -> O(N) Maximum rectangular area under a histogram"
    },
    "CP Stack: Shunting-Yard (Infix to Postfix & Eval)": {
        "scope": "java",
        "prefix": "stackshunting",
        "body": [
            "    static class ShuntingYard {",
            "        static int precedence(char op) {",
            "            if (op == '+' || op == '-') return 1;",
            "            if (op == '*' || op == '/') return 2;",
            "            if (op == '^') return 3;",
            "            return -1;",
            "        }",
            "",
            "        static long applyOp(char op, long b, long a) {",
            "            switch (op) {",
            "                case '+': return a + b;",
            "                case '-': return a - b;",
            "                case '*': return a * b;",
            "                case '/': return a / b;",
            "                case '^': return (long) Math.pow(a, b);",
            "            }",
            "            return 0;",
            "        }",
            "",
            "        static long evaluate(String expression) {",
            "            char[] tokens = expression.toCharArray();",
            "            long[] values = new long[tokens.length];",
            "            char[] ops = new char[tokens.length];",
            "            int vTop = -1, oTop = -1;",
            "",
            "            for (int i = 0; i < tokens.length; i++) {",
            "                if (tokens[i] == ' ') continue;",
            "                if (tokens[i] >= '0' && tokens[i] <= '9') {",
            "                    long val = 0;",
            "                    while (i < tokens.length && tokens[i] >= '0' && tokens[i] <= '9') {",
            "                        val = val * 10 + (tokens[i] - '0');",
            "                        i++;",
            "                    }",
            "                    values[++vTop] = val;",
            "                    i--;",
            "                } else if (tokens[i] == '(') {",
            "                    ops[++oTop] = tokens[i];",
            "                } else if (tokens[i] == ')') {",
            "                    while (oTop >= 0 && ops[oTop] != '(') {",
            "                        values[vTop - 1] = applyOp(ops[oTop--], values[vTop], values[vTop - 1]);",
            "                        vTop--;",
            "                    }",
            "                    oTop--; // Pop '('",
            "                } else {",
            "                    while (oTop >= 0 && precedence(ops[oTop]) >= precedence(tokens[i])) {",
            "                        values[vTop - 1] = applyOp(ops[oTop--], values[vTop], values[vTop - 1]);",
            "                        vTop--;",
            "                    }",
            "                    ops[++oTop] = tokens[i];",
            "                }",
            "            }",
            "            while (oTop >= 0) {",
            "                values[vTop - 1] = applyOp(ops[oTop--], values[vTop], values[vTop - 1]);",
            "                vTop--;",
            "            }",
            "            return values[0];",
            "        }",
            "    }",
            "    $0"
        ],
        "description": "Prefix: stackshunting -> O(N) Evaluates mathematical string expressions respecting precedence"
    },
    "CP Stack: Min Stack (O(1) Minimum Retrieval)": {
        "scope": "java",
        "prefix": "stackmin",
        "body": [
            "    static class MinStack {",
            "        long[] stack, minStack;",
            "        int top;",
            "",
            "        MinStack(int capacity) {",
            "            stack = new long[capacity];",
            "            minStack = new long[capacity];",
            "            top = -1;",
            "        }",
            "",
            "        void push(long val) {",
            "            stack[++top] = val;",
            "            if (top == 0) minStack[top] = val;",
            "            else minStack[top] = Math.min(val, minStack[top - 1]);",
            "        }",
            "",
            "        long pop() {",
            "            return stack[top--];",
            "        }",
            "",
            "        long getMin() {",
            "            return minStack[top];",
            "        }",
            "        ",
            "        boolean isEmpty() {",
            "            return top == -1;",
            "        }",
            "    }",
            "    $0"
        ],
        "description": "Prefix: stackmin -> O(1) Push, Pop, and Get Minimum operations using parallel primitive arrays"
    },
    "CP Stack: Longest Valid Parentheses": {
        "scope": "java",
        "prefix": "stackvalidparens",
        "body": [
            "    static int longestValidParentheses(String s) {",
            "        int n = s.length();",
            "        int[] stack = new int[n + 1];",
            "        int top = -1;",
            "        stack[++top] = -1; // Base index for length calculation",
            "        int maxLen = 0;",
            "        ",
            "        for (int i = 0; i < n; i++) {",
            "            if (s.charAt(i) == '(') {",
            "                stack[++top] = i;",
            "            } else {",
            "                top--; // Pop matching '('",
            "                if (top == -1) {",
            "                    stack[++top] = i; // Push current invalid ')' index as new base",
            "                } else {",
            "                    maxLen = Math.max(maxLen, i - stack[top]);",
            "                }",
            "            }",
            "        }",
            "        return maxLen;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: stackvalidparens -> O(N) Finds the length of the longest valid (well-formed) parentheses substring"
    },
    "CP Stack: Trapping Rain Water": {
        "scope": "java",
        "prefix": "stackrainwater",
        "body": [
            "    static long trapRainWater(int[] height) {",
            "        int n = height.length;",
            "        int[] stack = new int[n];",
            "        int top = -1;",
            "        long water = 0;",
            "        ",
            "        for (int i = 0; i < n; i++) {",
            "            while (top >= 0 && height[i] > height[stack[top]]) {",
            "                int bottom = stack[top--];",
            "                if (top == -1) break; // No left boundary",
            "                ",
            "                int left = stack[top];",
            "                int width = i - left - 1;",
            "                int boundedHeight = Math.min(height[i], height[left]) - height[bottom];",
            "                water += (long) width * boundedHeight;",
            "            }",
            "            stack[++top] = i;",
            "        }",
            "        return water;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: stackrainwater -> O(N) Computes trapped water using a monotonically decreasing stack"
    },
    "CP Stack: Maximal Rectangle in 2D Binary Matrix": {
        "scope": "java",
        "prefix": "stackmaxrect",
        "body": [
            "    // Requires the 'stackhist' (maxHistogramArea) snippet to be present in the class.",
            "    static long maximalRectangle(char[][] matrix) {",
            "        if (matrix == null || matrix.length == 0) return 0;",
            "        int r = matrix.length, c = matrix[0].length;",
            "        long[] heights = new long[c];",
            "        long maxArea = 0;",
            "        ",
            "        for (int i = 0; i < r; i++) {",
            "            for (int j = 0; j < c; j++) {",
            "                if (matrix[i][j] == '1') heights[j]++;",
            "                else heights[j] = 0;",
            "            }",
            "            // Call maxHistogramArea on the updated row heights",
            "            maxArea = Math.max(maxArea, maxHistogramArea(heights));",
            "        }",
            "        return maxArea;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: stackmaxrect -> O(R * C) Finds largest rectangle of 1s in a binary grid"
    },
    "CP Stack: Remove K Digits (Lexicographically Smallest)": {
        "scope": "java",
        "prefix": "stackremovek",
        "body": [
            "    static String removeKdigits(String num, int k) {",
            "        int n = num.length();",
            "        if (k == n) return \"0\";",
            "        ",
            "        char[] stack = new char[n];",
            "        int top = -1;",
            "        ",
            "        for (int i = 0; i < n; i++) {",
            "            char c = num.charAt(i);",
            "            while (top >= 0 && k > 0 && stack[top] > c) {",
            "                top--;",
            "                k--;",
            "            }",
            "            stack[++top] = c;",
            "        }",
            "        ",
            "        // If k > 0, pop from the end (e.g., strictly increasing sequence)",
            "        top -= k;",
            "        ",
            "        // Build result and strip leading zeros",
            "        int start = 0;",
            "        while (start <= top && stack[start] == '0') start++;",
            "        ",
            "        if (start > top) return \"0\";",
            "        return new String(stack, start, top - start + 1);",
            "    }",
            "    $0"
        ],
        "description": "Prefix: stackremovek -> O(N) Greedy monotonic stack to build smallest number after K removals"
    },
    "CP Stack: Ultra-Fast Primitive Int Stack": {
        "scope": "java",
        "prefix": "stackint",
        "body": [
            "    static class IntStack {",
            "        int[] a;",
            "        int top;",
            "        IntStack(int capacity) {",
            "            a = new int[capacity];",
            "            top = -1;",
            "        }",
            "        void push(int val) { a[++top] = val; }",
            "        int pop() { return a[top--]; }",
            "        int peek() { return a[top]; }",
            "        boolean isEmpty() { return top == -1; }",
            "        int size() { return top + 1; }",
            "        void clear() { top = -1; }",
            "    }",
            "    $0"
        ],
        "description": "Prefix: stackint -> O(1) Zero-overhead primitive integer stack to bypass java.util.Stack object overhead"
    },
    "CP Stack: Explicit Iterative DFS (Bypass JVM Recursion Limit)": {
        "scope": "java",
        "prefix": "stackdfs",
        "body": [
            "    // Use this when N > 10^4 and a deep degenerate graph would cause StackOverflowError",
            "    static void iterativeDFS(int startNode, int n, List<Integer>[] adj) {",
            "        boolean[] vis = new boolean[n];",
            "        int[] stack = new int[n];",
            "        int top = -1;",
            "        ",
            "        stack[++top] = startNode;",
            "        vis[startNode] = true;",
            "        ",
            "        while (top >= 0) {",
            "            int u = stack[top--];",
            "            ",
            "            // Process node u here (Pre-order equivalent)",
            "            ",
            "            // Traverse neighbors. Reverse order to match exact recursive DFS visitation",
            "            for (int i = adj[u].size() - 1; i >= 0; i--) {",
            "                int v = adj[u].get(i);",
            "                if (!vis[v]) {",
            "                    vis[v] = true;",
            "                    stack[++top] = v;",
            "                }",
            "            }",
            "        }",
            "    }",
            "    $0"
        ],
        "description": "Prefix: stackdfs -> O(V+E) Explicit stack DFS to prevent Java recursion depth crashes"
    },
    "CP Stack: Basic Balanced Brackets Check": {
        "scope": "java",
        "prefix": "stackbalanced",
        "body": [
            "    static boolean isBalanced(String s) {",
            "        char[] stack = new char[s.length()];",
            "        int top = -1;",
            "        for (int i = 0; i < s.length(); i++) {",
            "            char c = s.charAt(i);",
            "            if (c == '(' || c == '{' || c == '[') {",
            "                stack[++top] = c;",
            "            } else {",
            "                if (top == -1) return false;",
            "                char last = stack[top--];",
            "                if (c == ')' && last != '(') return false;",
            "                if (c == '}' && last != '{') return false;",
            "                if (c == ']' && last != '[') return false;",
            "            }",
            "        }",
            "        return top == -1;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: stackbalanced -> O(N) Validates {}, [], () cleanly using primitive char array"
    },
    "CP Stack: Minimum Bracket Reversals to Balance": {
        "scope": "java",
        "prefix": "stackreversals",
        "body": [
            "    // Calculates the minimum number of bracket reversals to make a string balanced. e.g., \"}{\" -> 2",
            "    static int minReversals(String s) {",
            "        if (s.length() % 2 != 0) return -1;",
            "        int open = 0, close = 0;",
            "        ",
            "        for (int i = 0; i < s.length(); i++) {",
            "            if (s.charAt(i) == '{') {",
            "                open++;",
            "            } else {",
            "                if (open > 0) open--;",
            "                else close++;",
            "            }",
            "        }",
            "        // Math optimization: ceil(open/2) + ceil(close/2)",
            "        return (open + 1) / 2 + (close + 1) / 2;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: stackreversals -> O(N) Fast math + implicit stack logic for bracket balancing"
    },
    "CP Stack: Decode String (Nested Multipliers)": {
        "scope": "java",
        "prefix": "stackdecode",
        "body": [
            "    // Decodes strings like \"3[a2[c]]\" into \"accaccacc\"",
            "    static String decodeString(String s) {",
            "        int[] counts = new int[s.length()];",
            "        String[] strings = new String[s.length()];",
            "        int cTop = -1, sTop = -1;",
            "        ",
            "        StringBuilder currStr = new StringBuilder();",
            "        int currNum = 0;",
            "        ",
            "        for (int i = 0; i < s.length(); i++) {",
            "            char c = s.charAt(i);",
            "            if (c >= '0' && c <= '9') {",
            "                currNum = currNum * 10 + (c - '0');",
            "            } else if (c == '[') {",
            "                counts[++cTop] = currNum;",
            "                strings[++sTop] = currStr.toString();",
            "                currNum = 0;",
            "                currStr = new StringBuilder();",
            "            } else if (c == ']') {",
            "                StringBuilder temp = new StringBuilder(strings[sTop--]);",
            "                int repeatTimes = counts[cTop--];",
            "                for (int j = 0; j < repeatTimes; j++) temp.append(currStr);",
            "                currStr = temp;",
            "            } else {",
            "                currStr.append(c);",
            "            }",
            "        }",
            "        return currStr.toString();",
            "    }",
            "    $0"
        ],
        "description": "Prefix: stackdecode -> O(N * MaxMultiplier) Decodes nested string patterns efficiently"
    },
    "CP Stack: Stock Span Problem": {
        "scope": "java",
        "prefix": "stackspan",
        "body": [
            "    // The span of a stock's price today is the maximum number of consecutive days ",
            "    // (starting from today and going backward) for which the price was <= today's price.",
            "    static int[] calculateSpan(int[] prices) {",
            "        int n = prices.length;",
            "        int[] span = new int[n];",
            "        int[] stack = new int[n]; // stores indices",
            "        int top = -1;",
            "        ",
            "        for (int i = 0; i < n; i++) {",
            "            while (top >= 0 && prices[stack[top]] <= prices[i]) {",
            "                top--;",
            "            }",
            "            span[i] = (top == -1) ? (i + 1) : (i - stack[top]);",
            "            stack[++top] = i;",
            "        }",
            "        return span;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: stackspan -> O(N) Classic stock span implementation using monotonic stack"
    }
}