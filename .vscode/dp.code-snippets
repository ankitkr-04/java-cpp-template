{
    "CP DP: Digit DP Template": {
        "scope": "java",
        "prefix": "dpdigit",
        "body": [
            "    static class DigitDP {",
            "        static Long[][][] memo;",
            "        static char[] num;",
            "        ",
            "        // Call this as: solve(String.valueOf(R).toCharArray()) - solve(String.valueOf(L - 1).toCharArray())",
            "        static long solve(char[] R) {",
            "            num = R;",
            "            // State: [position][tight boolean][problem_specific_state (e.g., sum)]",
            "            memo = new Long[num.length][2][200]; ",
            "            return dp(0, 1, 0);",
            "        }",
            "",
            "        static long dp(int pos, int tight, int state) {",
            "            if (pos == num.length) return state; // Return valid condition (e.g., state == targetSum ? 1 : 0)",
            "            if (memo[pos][tight][state] != null) return memo[pos][tight][state];",
            "",
            "            int limit = (tight == 1) ? (num[pos] - '0') : 9;",
            "            long res = 0;",
            "            ",
            "            for (int d = 0; d <= limit; d++) {",
            "                int nextTight = (tight == 1 && d == limit) ? 1 : 0;",
            "                int nextState = state + d; // Problem specific logic here (e.g., counting digit occurrences)",
            "                res += dp(pos + 1, nextTight, nextState);",
            "            }",
            "            ",
            "            return memo[pos][tight][state] = res;",
            "        }",
            "    }",
            "    $0"
        ],
        "description": "Prefix: dpdigit -> O(log N) Digit Dynamic Programming for counting in massive ranges"
    },
    "CP DP: Submask Iteration O(3^N)": {
        "scope": "java",
        "prefix": "dpsubmask",
        "body": [
            "    // Used when transitioning from a mask to any of its subsets (e.g., partitioning problems)",
            "    static long solveSubmaskDP(int n, long[] subsetCost) {",
            "        long[] dp = new long[1 << n];",
            "        Arrays.fill(dp, Long.MAX_VALUE / 2);",
            "        dp[0] = 0;",
            "        ",
            "        for (int mask = 1; mask < (1 << n); mask++) {",
            "            // Iterate through all submasks of 'mask' in O(3^N) total time across all masks",
            "            for (int sub = mask; sub > 0; sub = (sub - 1) & mask) {",
            "                // Example: dp[mask] = min(dp[mask], dp[mask ^ sub] + cost[sub])",
            "                dp[mask] = Math.min(dp[mask], dp[mask ^ sub] + subsetCost[sub]);",
            "            }",
            "        }",
            "        return dp[(1 << n) - 1];",
            "    }",
            "    $0"
        ],
        "description": "Prefix: dpsubmask -> O(3^N) Bitmask DP for exact set partitioning and set covering"
    },
    "CP DP: Game Theory (Sprague-Grundy / MEX)": {
        "scope": "java",
        "prefix": "dpsprague",
        "body": [
            "    static class SpragueGrundy {",
            "        static int[] grundy;",
            "        ",
            "        static int calculateMex(Set<Integer> set) {",
            "            int mex = 0;",
            "            while (set.contains(mex)) mex++;",
            "            return mex;",
            "        }",
            "",
            "        // Populates Grundy numbers up to n.",
            "        static void buildGrundy(int n, int[] possibleMoves) {",
            "            grundy = new int[n + 1];",
            "            grundy[0] = 0; // Terminal state is usually a loss (Grundy = 0)",
            "            ",
            "            for (int state = 1; state <= n; state++) {",
            "                Set<Integer> reachableStates = new HashSet<>();",
            "                for (int move : possibleMoves) {",
            "                    if (state - move >= 0) {",
            "                        reachableStates.add(grundy[state - move]);",
            "                    }",
            "                }",
            "                grundy[state] = calculateMex(reachableStates);",
            "            }",
            "        }",
            "        ",
            "        // For multiple independent games, XOR their Grundy values.",
            "        // If final XOR sum > 0, First Player wins. If == 0, Second Player wins.",
            "    }",
            "    $0"
        ],
        "description": "Prefix: dpsprague -> Computes Nim-values (Grundy numbers) for impartial games using MEX"
    },
    "CP DP: Longest Increasing Subsequence O(N log N)": {
        "scope": "java",
        "prefix": "dplis",
        "body": [
            "    static int getLIS(int[] a) {",
            "        int n = a.length;",
            "        if (n == 0) return 0;",
            "        int[] tails = new int[n];",
            "        int size = 0;",
            "        ",
            "        for (int x : a) {",
            "            int l = 0, r = size;",
            "            while (l < r) {",
            "                int mid = l + (r - l) / 2;",
            "                if (tails[mid] < x) l = mid + 1;",
            "                else r = mid;",
            "            }",
            "            tails[l] = x;",
            "            if (l == size) size++;",
            "        }",
            "        return size;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: dplis -> O(N log N) Longest Increasing Subsequence using Binary Search and Tails array"
    },
    "CP DP: Space Optimized Knapsack": {
        "scope": "java",
        "prefix": "dpknapsack",
        "body": [
            "    static long solve01Knapsack(int maxWeight, int[] weights, long[] values) {",
            "        long[] dp = new long[maxWeight + 1];",
            "        for (int i = 0; i < weights.length; i++) {",
            "            // Traverse backwards for 0/1 Knapsack to avoid item reuse",
            "            for (int w = maxWeight; w >= weights[i]; w--) {",
            "                dp[w] = Math.max(dp[w], dp[w - weights[i]] + values[i]);",
            "            }",
            "        }",
            "        return dp[maxWeight];",
            "    }",
            "",
            "    static long solveUnboundedKnapsack(int maxWeight, int[] weights, long[] values) {",
            "        long[] dp = new long[maxWeight + 1];",
            "        for (int i = 0; i < weights.length; i++) {",
            "            // Traverse forwards for Unbounded Knapsack to allow item reuse",
            "            for (int w = weights[i]; w <= maxWeight; w++) {",
            "                dp[w] = Math.max(dp[w], dp[w - weights[i]] + values[i]);",
            "            }",
            "        }",
            "        return dp[maxWeight];",
            "    }",
            "    $0"
        ],
        "description": "Prefix: dpknapsack -> O(N * W) 0/1 and Unbounded Knapsack optimized to 1D arrays"
    },
    "CP DP: Interval DP (Matrix Chain Multiplication Pattern)": {
        "scope": "java",
        "prefix": "dpinterval",
        "body": [
            "    // Evaluates optimal cost to combine adjacent elements/intervals in an array",
            "    static long solveIntervalDP(int[] a) {",
            "        int n = a.length;",
            "        long[][] dp = new long[n][n];",
            "        ",
            "        // Base cases: intervals of length 1 are usually 0 cost or a[i]",
            "        // for (int i = 0; i < n; i++) dp[i][i] = 0;",
            "        ",
            "        for (int len = 2; len <= n; len++) {",
            "            for (int i = 0; i <= n - len; i++) {",
            "                int j = i + len - 1;",
            "                dp[i][j] = Long.MAX_VALUE;",
            "                ",
            "                for (int k = i; k < j; k++) {",
            "                    // Transition: Cost of left part + right part + cost to merge",
            "                    long cost = dp[i][k] + dp[k + 1][j] + (long) a[i] * a[k + 1] * a[j]; // Example MCM cost",
            "                    dp[i][j] = Math.min(dp[i][j], cost);",
            "                }",
            "            }",
            "        }",
            "        return dp[0][n - 1];",
            "    }",
            "    $0"
        ],
        "description": "Prefix: dpinterval -> O(N^3) DP over contiguous subarrays/intervals"
    },
    "CP DP: SOS DP (Sum Over Subsets)": {
        "scope": "java",
        "prefix": "dpsos",
        "body": [
            "    // Calculates the sum of A[x] for all x that are submasks of mask in O(N * 2^N)",
            "    static long[] solveSOS(int n, long[] a) {",
            "        int limit = 1 << n;",
            "        long[] dp = Arrays.copyOf(a, limit);",
            "        ",
            "        for (int i = 0; i < n; i++) {",
            "            for (int mask = 0; mask < limit; mask++) {",
            "                if ((mask & (1 << i)) != 0) {",
            "                    dp[mask] += dp[mask ^ (1 << i)];",
            "                }",
            "            }",
            "        }",
            "        return dp;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: dpsos -> O(N * 2^N) Highly optimized Sum Over Subsets"
    },
    "CP DP: Bitmask Job Assignment": {
        "scope": "java",
        "prefix": "dpassignment",
        "body": [
            "    // Assigns N workers to N jobs minimizing/maximizing total cost.",
            "    // costMatrix[worker][job] = cost",
            "    static long solveAssignment(int n, long[][] costMatrix) {",
            "        long[] dp = new long[1 << n];",
            "        Arrays.fill(dp, Long.MAX_VALUE);",
            "        dp[0] = 0;",
            "        ",
            "        for (int mask = 0; mask < (1 << n); mask++) {",
            "            if (dp[mask] == Long.MAX_VALUE) continue;",
            "            int worker = Integer.bitCount(mask); // Which worker we are assigning next",
            "            ",
            "            if (worker == n) continue;",
            "            ",
            "            for (int job = 0; job < n; job++) {",
            "                if ((mask & (1 << job)) == 0) {",
            "                    int nextMask = mask | (1 << job);",
            "                    dp[nextMask] = Math.min(dp[nextMask], dp[mask] + costMatrix[worker][job]);",
            "                }",
            "            }",
            "        }",
            "        return dp[(1 << n) - 1];",
            "    }",
            "    $0"
        ],
        "description": "Prefix: dpassignment -> O(N * 2^N) Job assignment/matching utilizing bitmasks"
    },
    "CP DP: 2D Kadane (Maximum Sum Submatrix)": {
        "scope": "java",
        "prefix": "dpkadane2d",
        "body": [
            "    static long maxSubmatrixSum(long[][] matrix) {",
            "        int r = matrix.length, c = matrix[0].length;",
            "        long maxSum = Long.MIN_VALUE;",
            "        ",
            "        for (int top = 0; top < r; top++) {",
            "            long[] temp = new long[c];",
            "            for (int bottom = top; bottom < r; bottom++) {",
            "                for (int col = 0; col < c; col++) {",
            "                    temp[col] += matrix[bottom][col];",
            "                }",
            "                ",
            "                // 1D Kadane on the compressed columns",
            "                long currentSum = 0;",
            "                long localMax = Long.MIN_VALUE;",
            "                for (long val : temp) {",
            "                    currentSum = Math.max(val, currentSum + val);",
            "                    localMax = Math.max(localMax, currentSum);",
            "                }",
            "                maxSum = Math.max(maxSum, localMax);",
            "            }",
            "        }",
            "        return maxSum;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: dpkadane2d -> O(R^2 * C) Maximum sum rectangle in a 2D grid"
    },
    "CP DP: Coin Change (Min Coins & Number of Ways)": {
        "scope": "java",
        "prefix": "dpcoin",
        "body": [
            "    static long minCoins(int amount, int[] coins) {",
            "        long[] dp = new long[amount + 1];",
            "        Arrays.fill(dp, Integer.MAX_VALUE);",
            "        dp[0] = 0;",
            "        for (int coin : coins) {",
            "            for (int i = coin; i <= amount; i++) {",
            "                if (dp[i - coin] != Integer.MAX_VALUE) {",
            "                    dp[i] = Math.min(dp[i], dp[i - coin] + 1);",
            "                }",
            "            }",
            "        }",
            "        return dp[amount] == Integer.MAX_VALUE ? -1 : dp[amount];",
            "    }",
            "",
            "    static long waysToMakeChange(int amount, int[] coins, long mod) {",
            "        long[] dp = new long[amount + 1];",
            "        dp[0] = 1;",
            "        for (int coin : coins) {",
            "            for (int i = coin; i <= amount; i++) {",
            "                dp[i] = (dp[i] + dp[i - coin]) % mod;",
            "            }",
            "        }",
            "        return dp[amount];",
            "    }",
            "    $0"
        ],
        "description": "Prefix: dpcoin -> O(N * Amount) Coin Change combinations and minimums"
    },
    "CP DP: Subset Sum (Boolean Space Optimized)": {
        "scope": "java",
        "prefix": "dpsubsetsum",
        "body": [
            "    static boolean canFormSum(int target, int[] a) {",
            "        boolean[] dp = new boolean[target + 1];",
            "        dp[0] = true;",
            "        for (int x : a) {",
            "            for (int i = target; i >= x; i--) {",
            "                if (dp[i - x]) dp[i] = true;",
            "            }",
            "        }",
            "        return dp[target];",
            "    }",
            "    $0"
        ],
        "description": "Prefix: dpsubsetsum -> O(N * Target) Checks if a specific subset sum is possible"
    }
}