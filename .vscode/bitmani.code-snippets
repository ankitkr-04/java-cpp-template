{
    "CP Bit: Check / Set / Clear / Toggle (The Primitives)": {
        "scope": "java",
        "prefix": "bitbasics",
        "body": [
            "    static boolean checkBit(long mask, int i) { return (mask & (1L << i)) != 0; }",
            "    static long setBit(long mask, int i) { return mask | (1L << i); }",
            "    static long clearBit(long mask, int i) { return mask & ~(1L << i); }",
            "    static long toggleBit(long mask, int i) { return mask ^ (1L << i); }",
            "    $0"
        ],
        "description": "Prefix: bitbasics -> O(1) Core 0-indexed bit manipulations"
    },
    "CP Bit: Isolate & Strip Rightmost 1-Bit": {
        "scope": "java",
        "prefix": "bitrightmost",
        "body": [
            "    // Returns the value of only the lowest set bit (e.g., 10110 -> 00010)",
            "    static long isolateRightmostOne(long x) { return x & -x; }",
            "",
            "    // Clears the lowest set bit (e.g., 10110 -> 10100). Crucial for Brian Kernighan's popcount.",
            "    static long stripRightmostOne(long x) { return x & (x - 1); }",
            "    $0"
        ],
        "description": "Prefix: bitrightmost -> O(1) Fast rightmost bit extraction and stripping"
    },
    "CP Bit: Power of 2 Checks & Closest Powers": {
        "scope": "java",
        "prefix": "bitpow2",
        "body": [
            "    static boolean isPowerOfTwo(long x) {",
            "        return x > 0 && (x & (x - 1)) == 0;",
            "    }",
            "",
            "    // Returns the smallest power of 2 that is >= x",
            "    static long nextPowerOfTwo(long x) {",
            "        if (x == 0) return 1;",
            "        x--;",
            "        x |= x >> 1; x |= x >> 2;",
            "        x |= x >> 4; x |= x >> 8;",
            "        x |= x >> 16; x |= x >> 32;",
            "        return x + 1;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: bitpow2 -> O(1) Validations and math for powers of 2"
    },
    "CP Bit: Fast XOR Sum from 1 to N": {
        "scope": "java",
        "prefix": "bitxorsum",
        "body": [
            "    // Returns (1 ^ 2 ^ 3 ^ ... ^ N) strictly in O(1) time",
            "    static long xorSum(long n) {",
            "        long rem = n % 4;",
            "        if (rem == 0) return n;",
            "        if (rem == 1) return 1;",
            "        if (rem == 2) return n + 1;",
            "        return 0;",
            "    }",
            "",
            "    // Returns (L ^ L+1 ^ ... ^ R) in O(1)",
            "    static long xorSumRange(long l, long r) {",
            "        return xorSum(r) ^ xorSum(l - 1);",
            "    }",
            "    $0"
        ],
        "description": "Prefix: bitxorsum -> O(1) Direct calculation of continuous XOR sums"
    },
    "CP Bit: Iterate All Submasks of a Mask": {
        "scope": "java",
        "prefix": "bitsubmasks",
        "body": [
            "    static void iterateSubmasks(int mask) {",
            "        // Iterates through every valid submask exactly once in descending order",
            "        for (int sub = mask; sub > 0; sub = (sub - 1) & mask) {",
            "            // process(sub);",
            "        }",
            "        // Process the empty subset (0) if needed:",
            "        // process(0);",
            "    }",
            "    $0"
        ],
        "description": "Prefix: bitsubmasks -> O(2^K) Iterates through all combinations of the set bits in a specific mask"
    },
    "CP Bit: Gosper's Hack (Combinations of K bits)": {
        "scope": "java",
        "prefix": "bitgospers",
        "body": [
            "    // Iterates exactly through all masks of length N that have exactly K bits set.",
            "    // Far faster than checking Integer.bitCount() on all numbers.",
            "    static void iterateKBitCombinations(int n, int k) {",
            "        if (k == 0) return;",
            "        int set = (1 << k) - 1;",
            "        int limit = (1 << n);",
            "        while (set < limit) {",
            "            // process(set);",
            "            ",
            "            // The Hack:",
            "            int c = set & -set;",
            "            int r = set + c;",
            "            set = (((r ^ set) >> 2) / c) | r;",
            "        }",
            "    }",
            "    $0"
        ],
        "description": "Prefix: bitgospers -> Next lexicographical bitmask with exactly K bits set"
    },
    "CP Bit: Gray Code Conversion": {
        "scope": "java",
        "prefix": "bitgray",
        "body": [
            "    // Gray code ensures consecutive numbers differ by exactly ONE bit.",
            "    static long toGray(long n) {",
            "        return n ^ (n >> 1);",
            "    }",
            "",
            "    static long fromGray(long g) {",
            "        long n = 0;",
            "        for (; g > 0; g >>= 1) {",
            "            n ^= g;",
            "        }",
            "        return n;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: bitgray -> O(1) / O(Bits) Translate to and from Gray Code sequences"
    },
    "CP Bit: Find Single Element II (Others appear 3 times)": {
        "scope": "java",
        "prefix": "bitsingle3",
        "body": [
            "    // Every element appears 3 times except one which appears exactly once.",
            "    static int findSingleNumberThrice(int[] a) {",
            "        int ones = 0, twos = 0;",
            "        for (int x : a) {",
            "            ones = (ones ^ x) & ~twos;",
            "            twos = (twos ^ x) & ~ones;",
            "        }",
            "        return ones;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: bitsingle3 -> O(N) Space O(1) Boolean logic to find unique element among triples"
    },
    "CP Bit: Find Two Unique Elements (Others appear 2 times)": {
        "scope": "java",
        "prefix": "bittwounique",
        "body": [
            "    static int[] findTwoUnique(int[] a) {",
            "        int xorAll = 0;",
            "        for (int x : a) xorAll ^= x;",
            "        ",
            "        // Find the rightmost set bit which differentiates the two unique numbers",
            "        int setBit = xorAll & -xorAll;",
            "        ",
            "        int num1 = 0, num2 = 0;",
            "        for (int x : a) {",
            "            if ((x & setBit) != 0) num1 ^= x;",
            "            else num2 ^= x;",
            "        }",
            "        return new int[]{num1, num2};",
            "    }",
            "    $0"
        ],
        "description": "Prefix: bittwounique -> O(N) Space O(1) Partitions array based on differentiating bit"
    },
    "CP Bit: Bitwise Prefix 2D Array (Bits Frequency)": {
        "scope": "java",
        "prefix": "bitprefix2d",
        "body": [
            "    // Allows O(1) reconstruction of XOR, OR, and AND over any range [L, R]",
            "    static int[][] buildBitPrefix(int[] a, int maxBits) {",
            "        int n = a.length;",
            "        int[][] pref = new int[n + 1][maxBits];",
            "        for (int i = 0; i < n; i++) {",
            "            for (int j = 0; j < maxBits; j++) {",
            "                pref[i + 1][j] = pref[i][j] + ((a[i] >> j) & 1);",
            "            }",
            "        }",
            "        return pref;",
            "    }",
            "",
            "    // Example: Range AND. A bit remains set only if its frequency equals the range length.",
            "    static int queryRangeAND(int[][] pref, int l, int r, int maxBits) {",
            "        int res = 0;",
            "        int len = r - l + 1;",
            "        for (int j = 0; j < maxBits; j++) {",
            "            int setBits = pref[r + 1][j] - pref[l][j];",
            "            if (setBits == len) res |= (1 << j);",
            "        }",
            "        return res;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: bitprefix2d -> O(N * Bits) Evaluates bit frequencies to answer arbitrary range logic queries"
    },
    "CP Bit: Maximum XOR Pair (Trie)": {
        "scope": "java",
        "prefix": "bitmaxxor",
        "body": [
            "    static class XorTrie {",
            "        static class Node {",
            "            Node[] child = new Node[2];",
            "        }",
            "        Node root = new Node();",
            "        int maxBits = 31; // Set to 62 for longs",
            "        ",
            "        void insert(int num) {",
            "            Node curr = root;",
            "            for (int i = maxBits; i >= 0; i--) {",
            "                int bit = (num >> i) & 1;",
            "                if (curr.child[bit] == null) curr.child[bit] = new Node();",
            "                curr = curr.child[bit];",
            "            }",
            "        }",
            "        ",
            "        int getMaxXor(int num) {",
            "            Node curr = root;",
            "            int maxXor = 0;",
            "            for (int i = maxBits; i >= 0; i--) {",
            "                int bit = (num >> i) & 1;",
            "                int targetBit = 1 - bit; // Try to pick the opposite bit for max XOR",
            "                if (curr.child[targetBit] != null) {",
            "                    maxXor |= (1 << i);",
            "                    curr = curr.child[targetBit];",
            "                } else {",
            "                    curr = curr.child[bit];",
            "                }",
            "            }",
            "            return maxXor;",
            "        }",
            "    }",
            "    $0"
        ],
        "description": "Prefix: bitmaxxor -> O(N * 32) Finds the maximum possible XOR pairing of a number against an array"
    },
    "CP Bit: Linear Basis (Subset XOR Maximization)": {
        "scope": "java",
        "prefix": "bitbasis",
        "body": [
            "    // Extracts the independent vector basis of an array. ",
            "    // Solves \"Maximum XOR of any subset\" in O(N log(MaxVal)).",
            "    static class XorBasis {",
            "        long[] basis = new long[64];",
            "        int size = 0;",
            "        ",
            "        // Returns true if the number added a new dimension to the basis",
            "        boolean insert(long mask) {",
            "            for (int i = 63; i >= 0; i--) {",
            "                if ((mask & (1L << i)) == 0) continue;",
            "                if (basis[i] == 0) {",
            "                    basis[i] = mask;",
            "                    size++;",
            "                    return true;",
            "                }",
            "                mask ^= basis[i];",
            "            }",
            "            return false; // Can be formed by XORing existing basis elements",
            "        }",
            "        ",
            "        // Returns the absolute maximum XOR possible from ANY subset",
            "        long getMaxPossibleXor() {",
            "            long res = 0;",
            "            for (int i = 63; i >= 0; i--) {",
            "                if ((res ^ basis[i]) > res) {",
            "                    res ^= basis[i];",
            "                }",
            "            }",
            "            return res;",
            "        }",
            "    }",
            "    $0"
        ],
        "description": "Prefix: bitbasis -> O(N * 64) Linear Algebra XOR Basis. Extremely powerful for CodeVita subsets."
    },
    "CP Bit: Custom Long Array BitSet (Memory Efficient)": {
        "scope": "java",
        "prefix": "bitcustomset",
        "body": [
            "    // Replaces java.util.BitSet for massive graph matrix operations without Object overhead",
            "    static class FastBitSet {",
            "        long[] bits;",
            "        FastBitSet(int maxElements) {",
            "            bits = new long[(maxElements >> 6) + 1];",
            "        }",
            "        void set(int i) { bits[i >> 6] |= (1L << (i & 63)); }",
            "        void clear(int i) { bits[i >> 6] &= ~(1L << (i & 63)); }",
            "        boolean get(int i) { return (bits[i >> 6] & (1L << (i & 63))) != 0; }",
            "        ",
            "        // Fast bulk bitwise OR (e.g., merging reachability matrices)",
            "        void or(FastBitSet other) {",
            "            for (int i = 0; i < bits.length; i++) bits[i] |= other.bits[i];",
            "        }",
            "        // Counts total set bits in O(ArrayLen) instead of O(N)",
            "        int cardinality() {",
            "            int count = 0;",
            "            for (long b : bits) count += Long.bitCount(b);",
            "            return count;",
            "        }",
            "    }",
            "    $0"
        ],
        "description": "Prefix: bitcustomset -> Raw long[] bitset. Essential for bypassing MLE limits in V=10^5 dense graphs."
    }
}