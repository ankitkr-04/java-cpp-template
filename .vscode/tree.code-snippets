{
    "CP Tree: Binary Lifting LCA": {
        "scope": "java",
        "prefix": "treelca",
        "body": [
            "    static class BinaryLifting {",
            "        int n, maxLog;",
            "        int[][] up;",
            "        int[] depth, tin, tout;",
            "        int timer;",
            "        List<Integer>[] adj;",
            "",
            "        BinaryLifting(int n, int root, List<Integer>[] adj) {",
            "            this.n = n; this.adj = adj;",
            "            maxLog = Integer.numberOfTrailingZeros(Integer.highestOneBit(n)) + 2;",
            "            up = new int[n][maxLog];",
            "            depth = new int[n]; tin = new int[n]; tout = new int[n];",
            "            dfs(root, root, 0);",
            "        }",
            "",
            "        void dfs(int u, int p, int d) {",
            "            tin[u] = ++timer;",
            "            up[u][0] = p; depth[u] = d;",
            "            for (int i = 1; i < maxLog; i++) up[u][i] = up[up[u][i - 1]][i - 1];",
            "            for (int v : adj[u]) if (v != p) dfs(v, u, d + 1);",
            "            tout[u] = ++timer;",
            "        }",
            "",
            "        boolean isAncestor(int u, int v) { return tin[u] <= tin[v] && tout[u] >= tout[v]; }",
            "",
            "        int lca(int u, int v) {",
            "            if (isAncestor(u, v)) return u;",
            "            if (isAncestor(v, u)) return v;",
            "            for (int i = maxLog - 1; i >= 0; i--) {",
            "                if (!isAncestor(up[u][i], v)) u = up[u][i];",
            "            }",
            "            return up[u][0];",
            "        }",
            "",
            "        int dist(int u, int v) { return depth[u] + depth[v] - 2 * depth[lca(u, v)]; }",
            "    }",
            "    $0"
        ],
        "description": "Prefix: treelca -> O(N log N) init, O(log N) queries for Lowest Common Ancestor & Distance"
    },
    "CP Tree: Heavy-Light Decomposition": {
        "scope": "java",
        "prefix": "treehld",
        "body": [
            "    static class HLD {",
            "        int n, timer;",
            "        List<Integer>[] adj;",
            "        int[] parent, depth, heavy, head, pos, sz;",
            "",
            "        HLD(int n, int root, List<Integer>[] adj) {",
            "            this.n = n; this.adj = adj;",
            "            parent = new int[n]; depth = new int[n]; heavy = new int[n];",
            "            head = new int[n]; pos = new int[n]; sz = new int[n];",
            "            Arrays.fill(heavy, -1);",
            "            dfsSz(root, -1, 0);",
            "            dfsHld(root, -1, root);",
            "        }",
            "",
            "        int dfsSz(int u, int p, int d) {",
            "            sz[u] = 1; parent[u] = p; depth[u] = d;",
            "            int maxSub = 0;",
            "            for (int v : adj[u]) {",
            "                if (v == p) continue;",
            "                int subSz = dfsSz(v, u, d + 1);",
            "                sz[u] += subSz;",
            "                if (subSz > maxSub) { maxSub = subSz; heavy[u] = v; }",
            "            }",
            "            return sz[u];",
            "        }",
            "",
            "        void dfsHld(int u, int p, int h) {",
            "            head[u] = h; pos[u] = timer++;",
            "            if (heavy[u] != -1) dfsHld(heavy[u], u, h);",
            "            for (int v : adj[u]) {",
            "                if (v != p && v != heavy[u]) dfsHld(v, u, v);",
            "            }",
            "        }",
            "",
            "        // Query path from u to v. Implement standard Segment Tree over `pos` array to use this.",
            "        void queryPath(int u, int v) {",
            "            while (head[u] != head[v]) {",
            "                if (depth[head[u]] < depth[head[v]]) { int t = u; u = v; v = t; }",
            "                // SegmentTree.query(pos[head[u]], pos[u]);",
            "                u = parent[head[u]];",
            "            }",
            "            if (depth[u] > depth[v]) { int t = u; u = v; v = t; }",
            "            // SegmentTree.query(pos[u], pos[v]); // Use pos[heavy[u]] if edge weights!",
            "        }",
            "    }",
            "    $0"
        ],
        "description": "Prefix: treehld -> Flattens trees into arrays for O(log^2 N) path updates via Segment Trees"
    },
    "CP Tree: HLD + Segment Tree Integration": {
        "scope": "java",
        "prefix": "treehldseg",
        "body": [
            "    static class HLD {",
            "        int n, timer;",
            "        List<Integer>[] adj;",
            "        int[] parent, depth, heavy, head, pos, sz;",
            "",
            "        HLD(int n, int root, List<Integer>[] adj) {",
            "            this.n = n; this.adj = adj;",
            "            parent = new int[n]; depth = new int[n]; heavy = new int[n];",
            "            head = new int[n]; pos = new int[n]; sz = new int[n];",
            "            Arrays.fill(heavy, -1);",
            "            dfsSz(root, -1, 0);",
            "            dfsHld(root, -1, root);",
            "        }",
            "",
            "        int dfsSz(int u, int p, int d) {",
            "            sz[u] = 1; parent[u] = p; depth[u] = d;",
            "            int maxSub = 0;",
            "            for (int v : adj[u]) {",
            "                if (v == p) continue;",
            "                int subSz = dfsSz(v, u, d + 1);",
            "                sz[u] += subSz;",
            "                if (subSz > maxSub) { maxSub = subSz; heavy[u] = v; }",
            "            }",
            "            return sz[u];",
            "        }",
            "",
            "        void dfsHld(int u, int p, int h) {",
            "            head[u] = h; pos[u] = timer++;",
            "            if (heavy[u] != -1) dfsHld(heavy[u], u, h);",
            "            for (int v : adj[u]) {",
            "                if (v != p && v != heavy[u]) dfsHld(v, u, v);",
            "            }",
            "        }",
            "",
            "        // 1. DIRECT METHOD: Maps inclusive [l, r] array queries to your exclusive [l, r) Segment Tree.",
            "        long queryDirect(SegmentTree st, int l, int r) {",
            "            if (l > r) { int t = l; l = r; r = t; } // Safety swap to ensure l <= r",
            "            return st.query(l, r + 1);",
            "        }",
            "",
            "        // 2. HLD BASE METHOD: Climbs the tree, breaking u <-> v into heavy paths.",
            "        long queryPath(int u, int v, SegmentTree st) {",
            "            long res = 0; // Default identity (e.g., 0 for sum, Long.MIN_VALUE for max)",
            "            while (head[u] != head[v]) {",
            "                if (depth[head[u]] < depth[head[v]]) { int t = u; u = v; v = t; }",
            "                // u is on a deeper heavy path. Traverse from head[u] to u.",
            "                res += queryDirect(st, pos[head[u]], pos[u]); ",
            "                u = parent[head[u]];",
            "            }",
            "            // Both are now on the exact same heavy path.",
            "            if (depth[u] > depth[v]) { int t = u; u = v; v = t; }",
            "            ",
            "            // If values are stored on VERTICES:",
            "            res += queryDirect(st, pos[u], pos[v]);",
            "            ",
            "            // If values are stored on EDGES (skip the LCA node u itself):",
            "            // if (u != v) res += queryDirect(st, pos[heavy[u]], pos[v]);",
            "            ",
            "            return res;",
            "        }",
            "    }",
            "    $0"
        ],
        "description": "Prefix: treehldseg -> HLD integrated with Segment Tree using Base and Direct query methods"
    },
    "CP Tree: Centroid Decomposition": {
        "scope": "java",
        "prefix": "treecentroid",
        "body": [
            "    static class CentroidDecomposition {",
            "        List<Integer>[] adj;",
            "        int[] sz, parent;",
            "        boolean[] removed;",
            "",
            "        CentroidDecomposition(int n, List<Integer>[] adj) {",
            "            this.adj = adj;",
            "            sz = new int[n]; parent = new int[n];",
            "            removed = new boolean[n];",
            "            build(0, -1);",
            "        }",
            "",
            "        void calcSz(int u, int p) {",
            "            sz[u] = 1;",
            "            for (int v : adj[u]) {",
            "                if (v != p && !removed[v]) { calcSz(v, u); sz[u] += sz[v]; }",
            "            }",
            "        }",
            "",
            "        int getCentroid(int u, int p, int total) {",
            "            for (int v : adj[u]) {",
            "                if (v != p && !removed[v] && sz[v] > total / 2) return getCentroid(v, u, total);",
            "            }",
            "            return u;",
            "        }",
            "",
            "        void build(int u, int p) {",
            "            calcSz(u, -1);",
            "            int centroid = getCentroid(u, -1, sz[u]);",
            "            parent[centroid] = p; // Links centroid tree",
            "            removed[centroid] = true;",
            "            ",
            "            // TODO: Calculate required paths passing specifically through `centroid` here",
            "",
            "            for (int v : adj[centroid]) {",
            "                if (!removed[v]) build(v, centroid);",
            "            }",
            "        }",
            "    }",
            "    $0"
        ],
        "description": "Prefix: treecentroid -> O(N log N) recursive graph fracturing for global path counting"
    },
    "CP Tree: AHU Isomorphism (Tree Hashing)": {
        "scope": "java",
        "prefix": "treeahu",
        "body": [
            "    static class TreeIsomorphism {",
            "        static long MOD = (long)1e9 + 7;",
            "        ",
            "        // Shifts hashes to avoid collisions on identical subtrees",
            "        static long shift(long x) {",
            "            x ^= x << 13;",
            "            x ^= x >> 7;",
            "            x ^= x << 17;",
            "            return x;",
            "        }",
            "",
            "        static long getHash(int u, int p, List<Integer>[] adj) {",
            "            long sum = 1;",
            "            for (int v : adj[u]) {",
            "                if (v != p) sum = (sum + shift(getHash(v, u, adj))) % MOD;",
            "            }",
            "            return sum;",
            "        }",
            "",
            "        static boolean isIsomorphic(List<Integer>[] adj1, int root1, List<Integer>[] adj2, int root2) {",
            "            return getHash(root1, -1, adj1) == getHash(root2, -1, adj2);",
            "        }",
            "    }",
            "    $0"
        ],
        "description": "Prefix: treeahu -> O(N) Hash-based structural comparison of two rooted trees"
    },
    "CP Tree: Basic Metadata (Depth, Parent, Subtree Size)": {
        "scope": "java",
        "prefix": "treebasic",
        "body": [
            "    static int[] depth, parent, sz;",
            "    static void initTree(int n, int root, List<Integer>[] adj) {",
            "        depth = new int[n]; parent = new int[n]; sz = new int[n];",
            "        Arrays.fill(parent, -1);",
            "        dfsTree(root, -1, 0, adj);",
            "    }",
            "",
            "    static void dfsTree(int u, int p, int d, List<Integer>[] adj) {",
            "        depth[u] = d;",
            "        parent[u] = p;",
            "        sz[u] = 1;",
            "        for (int v : adj[u]) {",
            "            if (v != p) {",
            "                dfsTree(v, u, d + 1, adj);",
            "                sz[u] += sz[v];",
            "            }",
            "        }",
            "    }",
            "    $0"
        ],
        "description": "Prefix: treebasic -> O(N) Maps out standard tree structure variables"
    },
    "CP Tree: Diameter (2-DFS Method)": {
        "scope": "java",
        "prefix": "treediameter",
        "body": [
            "    static int maxDist, farthestNode;",
            "    static void dfsDiameter(int u, int p, int d, List<Integer>[] adj) {",
            "        if (d > maxDist) {",
            "            maxDist = d;",
            "            farthestNode = u;",
            "        }",
            "        for (int v : adj[u]) {",
            "            if (v != p) dfsDiameter(v, u, d + 1, adj);",
            "        }",
            "    }",
            "",
            "    static int getDiameter(int n, List<Integer>[] adj) {",
            "        if (n <= 1) return 0;",
            "        maxDist = -1;",
            "        dfsDiameter(0, -1, 0, adj); // 1st pass: find one end of the diameter",
            "        maxDist = -1;",
            "        dfsDiameter(farthestNode, -1, 0, adj); // 2nd pass: find the actual diameter",
            "        return maxDist;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: treediameter -> O(N) Finds the longest path in a tree using two traversals"
    },
    "CP Tree: Euler Tour (Subtree Flattening)": {
        "scope": "java",
        "prefix": "treeeuler",
        "body": [
            "    // Flattens a tree so every subtree becomes a contiguous subarray [tin[u], tout[u]]",
            "    static int timer;",
            "    static int[] tin, tout, eulerArray;",
            "",
            "    static void initEuler(int n, int root, List<Integer>[] adj) {",
            "        tin = new int[n]; tout = new int[n]; eulerArray = new int[n];",
            "        timer = 0;",
            "        dfsEuler(root, -1, adj);",
            "    }",
            "",
            "    static void dfsEuler(int u, int p, List<Integer>[] adj) {",
            "        tin[u] = timer;",
            "        eulerArray[timer++] = u;",
            "        for (int v : adj[u]) {",
            "            if (v != p) dfsEuler(v, u, adj);",
            "        }",
            "        tout[u] = timer - 1;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: treeeuler -> O(N) Maps subtrees to 1D arrays for Range Queries (Segment Tree / Fenwick)"
    },
    "CP Tree: LCA via RMQ (O(1) Query Time)": {
        "scope": "java",
        "prefix": "treelcarmq",
        "body": [
            "    static class LcaRmq {",
            "        int n, timer;",
            "        int[] first, depth, euler;",
            "        int[][] st;",
            "        int[] log2;",
            "",
            "        LcaRmq(int n, int root, List<Integer>[] adj) {",
            "            this.n = n;",
            "            first = new int[n];",
            "            depth = new int[n];",
            "            euler = new int[2 * n]; // Euler tour with returns",
            "            timer = 0;",
            "            dfs(root, -1, 0, adj);",
            "            buildSparseTable();",
            "        }",
            "",
            "        void dfs(int u, int p, int d, List<Integer>[] adj) {",
            "            first[u] = timer;",
            "            euler[timer] = u;",
            "            depth[timer++] = d;",
            "            for (int v : adj[u]) {",
            "                if (v != p) {",
            "                    dfs(v, u, d + 1, adj);",
            "                    euler[timer] = u;",
            "                    depth[timer++] = d;",
            "                }",
            "            }",
            "        }",
            "",
            "        void buildSparseTable() {",
            "            int m = timer;",
            "            log2 = new int[m + 1];",
            "            for (int i = 2; i <= m; i++) log2[i] = log2[i / 2] + 1;",
            "            int K = log2[m] + 1;",
            "            st = new int[m][K];",
            "            for (int i = 0; i < m; i++) st[i][0] = i;",
            "            for (int j = 1; j < K; j++) {",
            "                for (int i = 0; i + (1 << j) <= m; i++) {",
            "                    int left = st[i][j - 1];",
            "                    int right = st[i + (1 << (j - 1))][j - 1];",
            "                    st[i][j] = depth[left] < depth[right] ? left : right;",
            "                }",
            "            }",
            "        }",
            "",
            "        int lca(int u, int v) {",
            "            int l = first[u], r = first[v];",
            "            if (l > r) { int t = l; l = r; r = t; }",
            "            int j = log2[r - l + 1];",
            "            int left = st[l][j];",
            "            int right = st[r - (1 << j) + 1][j];",
            "            int minIdx = depth[left] < depth[right] ? left : right;",
            "            return euler[minIdx];",
            "        }",
            "    }",
            "    $0"
        ],
        "description": "Prefix: treelcarmq -> O(N log N) init, absolute O(1) LCA Query. Best for millions of queries."
    },
    "CP Tree: Rerooting DP (In/Out DP)": {
        "scope": "java",
        "prefix": "treererooting",
        "body": [
            "    static class RerootingDP {",
            "        int n;",
            "        long[] dpIn, dpOut, ans;",
            "        List<Integer>[] adj;",
            "",
            "        RerootingDP(int n, List<Integer>[] adj) {",
            "            this.n = n; this.adj = adj;",
            "            dpIn = new long[n];",
            "            dpOut = new long[n];",
            "            ans = new long[n];",
            "            dfsIn(0, -1);",
            "            dfsOut(0, -1, 0);",
            "        }",
            "",
            "        // 1. Bottom-up accumulation (e.g., Subtree sum/max)",
            "        void dfsIn(int u, int p) {",
            "            dpIn[u] = 0; // Initialize base state",
            "            for (int v : adj[u]) {",
            "                if (v == p) continue;",
            "                dfsIn(v, u);",
            "                // dpIn[u] += dpIn[v] + weight; // Example transition",
            "            }",
            "        }",
            "",
            "        // 2. Top-down propagation (e.g., Global optimal for each root)",
            "        void dfsOut(int u, int p, long outVal) {",
            "            dpOut[u] = outVal;",
            "            ans[u] = dpIn[u] + dpOut[u]; // Combine for final answer",
            "            ",
            "            // Prefix and Suffix arrays are often needed here if transition is non-invertible (like MAX)",
            "            long currentSum = outVal;",
            "            for (int v : adj[u]) {",
            "                if (v != p) {",
            "                    // Pass the combined state of parent MINUS the child's own contribution",
            "                    dfsOut(v, u, currentSum /* + transition_weight */);",
            "                }",
            "            }",
            "        }",
            "    }",
            "    $0"
        ],
        "description": "Prefix: treererooting -> O(N) Computes DP answers for ALL nodes acting as the root"
    },
    "CP Tree: DSU on Tree / Sack (Small to Large)": {
        "scope": "java",
        "prefix": "treesack",
        "body": [
            "    static class DsuOnTree {",
            "        int[] sz, heavy;",
            "        List<Integer>[] adj;",
            "        // Add global arrays for counting frequencies/answers here",
            "",
            "        DsuOnTree(int n, List<Integer>[] adj) {",
            "            this.adj = adj;",
            "            sz = new int[n]; heavy = new int[n];",
            "            Arrays.fill(heavy, -1);",
            "            dfsSz(0, -1);",
            "            dfsSack(0, -1, true);",
            "        }",
            "",
            "        int dfsSz(int u, int p) {",
            "            sz[u] = 1;",
            "            int maxSub = 0;",
            "            for (int v : adj[u]) {",
            "                if (v != p) {",
            "                    int subSz = dfsSz(v, u);",
            "                    sz[u] += subSz;",
            "                    if (subSz > maxSub) { maxSub = subSz; heavy[u] = v; }",
            "                }",
            "            }",
            "            return sz[u];",
            "        }",
            "",
            "        void add(int u, int p, int delta) {",
            "            // Update global frequency arrays/answers with node u",
            "            for (int v : adj[u]) if (v != p) add(v, u, delta);",
            "        }",
            "",
            "        void dfsSack(int u, int p, boolean keep) {",
            "            for (int v : adj[u]) {",
            "                if (v != p && v != heavy[u]) dfsSack(v, u, false); // Process light children",
            "            }",
            "            if (heavy[u] != -1) dfsSack(heavy[u], u, true); // Process heavy child",
            "            ",
            "            // Add u and light subtrees to current state",
            "            // Node u itself:",
            "            // frequency[color[u]]++;",
            "            for (int v : adj[u]) {",
            "                if (v != p && v != heavy[u]) add(v, u, 1);",
            "            }",
            "            ",
            "            // Store answer for subtree u here",
            "            ",
            "            if (!keep) {",
            "                // Remove all from state to avoid bleeding into siblings",
            "                add(u, p, -1); ",
            "            }",
            "        }",
            "    }",
            "    $0"
        ],
        "description": "Prefix: treesack -> O(N log N) Offline subtree queries without updates (Sack algorithm)"
    },
    "CP Tree: K-th Ancestor (Binary Lifting)": {
        "scope": "java",
        "prefix": "treekthancestor",
        "body": [
            "    // Requires BinaryLifting table (up[][]) to be precalculated",
            "    static int getKthAncestor(int u, int k, int[][] up, int maxLog) {",
            "        for (int i = 0; i < maxLog; i++) {",
            "            if ((k & (1 << i)) != 0) {",
            "                u = up[u][i];",
            "                if (u == -1) return -1; // Out of bounds",
            "            }",
            "        }",
            "        return u;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: treekthancestor -> O(log K) Jump to the K-th parent using powers of 2"
    },
    "CP Tree: Tree Center(s) (Leaf Peeling)": {
        "scope": "java",
        "prefix": "treecenter",
        "body": [
            "    // Finds the 1 or 2 centers of a tree (nodes minimizing max distance to all other nodes)",
            "    static List<Integer> findTreeCenters(int n, List<Integer>[] adj) {",
            "        if (n == 1) return Collections.singletonList(0);",
            "        int[] deg = new int[n];",
            "        Queue<Integer> q = new ArrayDeque<>();",
            "        for (int i = 0; i < n; i++) {",
            "            deg[i] = adj[i].size();",
            "            if (deg[i] == 1) q.add(i);",
            "        }",
            "        ",
            "        int remainingNodes = n;",
            "        while (remainingNodes > 2) {",
            "            int leaves = q.size();",
            "            remainingNodes -= leaves;",
            "            for (int i = 0; i < leaves; i++) {",
            "                int u = q.poll();",
            "                for (int v : adj[u]) {",
            "                    if (--deg[v] == 1) q.add(v);",
            "                }",
            "            }",
            "        }",
            "        return new ArrayList<>(q);",
            "    }",
            "    $0"
        ],
        "description": "Prefix: treecenter -> O(N) topological leaf peeling to find the absolute middle of the tree"
    },
    "CP Tree: Tree Diameter (DP Method)": {
        "scope": "java",
        "prefix": "treediameterdp",
        "body": [
            "    static long diameter = 0;",
            "    static long dfsDiameterDp(int u, int p, List<int[]>[] adj) {",
            "        long max1 = 0, max2 = 0; // Two longest branches going down",
            "        for (int[] edge : adj[u]) {",
            "            int v = edge[0];",
            "            long w = edge[1];",
            "            if (v != p) {",
            "                long down = dfsDiameterDp(v, u, adj) + w;",
            "                if (down > max1) {",
            "                    max2 = max1;",
            "                    max1 = down;",
            "                } else if (down > max2) {",
            "                    max2 = down;",
            "                }",
            "            }",
            "        }",
            "        diameter = Math.max(diameter, max1 + max2);",
            "        return max1;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: treediameterdp -> O(N) Finds diameter in a single pass. Handles weighted paths easily."
    },
    "CP Tree: Virtual Tree (Auxiliary Tree)": {
        "scope": "java",
        "prefix": "treevirtual",
        "body": [
            "    // Requires: `tin` array from Euler Tour and `LcaRmq` class",
            "    static List<Integer>[] buildVirtualTree(int[] nodes, int[] tin, LcaRmq lca) {",
            "        // Sort strictly by DFS entry time",
            "        nodes = Arrays.stream(nodes)",
            "                      .boxed()",
            "                      .sorted(Comparator.comparingInt(a -> tin[a]))",
            "                      .mapToInt(i -> i).toArray();",
            "        ",
            "        int k = nodes.length;",
            "        List<Integer> vNodes = new ArrayList<>();",
            "        for (int i = 0; i < k - 1; i++) {",
            "            vNodes.add(nodes[i]);",
            "            vNodes.add(lca.lca(nodes[i], nodes[i + 1]));",
            "        }",
            "        vNodes.add(nodes[k - 1]);",
            "        ",
            "        // Deduplicate and re-sort",
            "        vNodes = vNodes.stream().distinct()",
            "                       .sorted(Comparator.comparingInt(a -> tin[a]))",
            "                       .collect(Collectors.toList());",
            "        ",
            "        List<Integer>[] vAdj = new ArrayList[/* Max N */];",
            "        // Initialize lists for nodes present in vNodes...",
            "        ",
            "        Deque<Integer> stack = new ArrayDeque<>();",
            "        stack.push(vNodes.get(0));",
            "        for (int i = 1; i < vNodes.size(); i++) {",
            "            int u = vNodes.get(i);",
            "            while (!stack.isEmpty()) {",
            "                int p = stack.peek();",
            "                // If p is ancestor of u (using tin/tout or LCA depth check)",
            "                if (lca.lca(p, u) == p) break;",
            "                stack.pop();",
            "            }",
            "            if (!stack.isEmpty()) {",
            "                vAdj[stack.peek()].add(u);",
            "                vAdj[u].add(stack.peek()); // If undirected",
            "            }",
            "            stack.push(u);",
            "        }",
            "        return vAdj;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: treevirtual -> O(K log K) Condenses a massive tree into just K queried nodes + their LCAs"
    },
    "CP Tree: Mo's Algorithm on Trees": {
        "scope": "java",
        "prefix": "treemos",
        "body": [
            "    static class MosOnTree {",
            "        int timer;",
            "        int[] tin, tout, euler;",
            "        int[] depth;",
            "        int[][] up;",
            "        int maxLog;",
            "",
            "        MosOnTree(int n, int root, List<Integer>[] adj) {",
            "            tin = new int[n]; tout = new int[n]; euler = new int[2 * n];",
            "            depth = new int[n];",
            "            maxLog = Integer.numberOfTrailingZeros(Integer.highestOneBit(n)) + 2;",
            "            up = new int[n][maxLog];",
            "            timer = 0;",
            "            dfs(root, root, 0, adj);",
            "        }",
            "",
            "        void dfs(int u, int p, int d, List<Integer>[] adj) {",
            "            tin[u] = timer;",
            "            euler[timer++] = u;",
            "            depth[u] = d;",
            "            up[u][0] = p;",
            "            for (int i = 1; i < maxLog; i++) up[u][i] = up[up[u][i - 1]][i - 1];",
            "            ",
            "            for (int v : adj[u]) {",
            "                if (v != p) dfs(v, u, d + 1, adj);",
            "            }",
            "            ",
            "            tout[u] = timer;",
            "            euler[timer++] = u;",
            "        }",
            "",
            "        boolean isAncestor(int u, int v) { return tin[u] <= tin[v] && tout[u] >= tout[v]; }",
            "",
            "        int lca(int u, int v) {",
            "            if (isAncestor(u, v)) return u;",
            "            if (isAncestor(v, u)) return v;",
            "            for (int i = maxLog - 1; i >= 0; i--) {",
            "                if (!isAncestor(up[u][i], v)) u = up[u][i];",
            "            }",
            "            return up[u][0];",
            "        }",
            "",
            "        // Query mapping for Mo's Algorithm:",
            "        // 1. Sort queries by (l / BLOCK_SIZE, r)",
            "        // 2. If lca(u, v) == u, range is [tin[u], tin[v]]",
            "        // 3. Else, range is [tout[u], tin[v]] and you MUST manually add/remove lca(u, v) during the query evaluation",
            "    }",
            "    $0"
        ],
        "description": "Prefix: treemos -> O((N+Q)*sqrt(N)) Offline path queries using 2N Euler Tour flattening"
    },
    "CP Tree: Tarjan's Offline LCA": {
        "scope": "java",
        "prefix": "treetarjanlca",
        "body": [
            "    static class TarjanOfflineLCA {",
            "        int[] parent, ancestor;",
            "        boolean[] visited;",
            "        List<Integer>[] adj;",
            "        List<int[]>[] queries; // queries[u] contains {v, queryIndex}",
            "        int[] lcaAnswers;",
            "",
            "        TarjanOfflineLCA(int n, int numQueries, List<Integer>[] adj, List<int[]>[] queries) {",
            "            this.adj = adj;",
            "            this.queries = queries;",
            "            parent = new int[n];",
            "            ancestor = new int[n];",
            "            visited = new boolean[n];",
            "            lcaAnswers = new int[numQueries];",
            "            for (int i = 0; i < n; i++) {",
            "                parent[i] = i;",
            "                ancestor[i] = i;",
            "            }",
            "            dfs(0); // Assuming 0 is the root",
            "        }",
            "",
            "        int find(int i) {",
            "            if (parent[i] == i) return i;",
            "            return parent[i] = find(parent[i]);",
            "        }",
            "",
            "        void union(int i, int j) {",
            "            int rootI = find(i);",
            "            int rootJ = find(j);",
            "            if (rootI != rootJ) parent[rootI] = rootJ;",
            "        }",
            "",
            "        void dfs(int u) {",
            "            visited[u] = true;",
            "            ancestor[find(u)] = u;",
            "            for (int v : adj[u]) {",
            "                if (!visited[v]) {",
            "                    dfs(v);",
            "                    union(v, u);",
            "                    ancestor[find(u)] = u;",
            "                }",
            "            }",
            "            for (int[] q : queries[u]) {",
            "                int v = q[0], qIdx = q[1];",
            "                if (visited[v]) {",
            "                    lcaAnswers[qIdx] = ancestor[find(v)];",
            "                }",
            "            }",
            "        }",
            "    }",
            "    $0"
        ],
        "description": "Prefix: treetarjanlca -> O(N + Q) Offline Lowest Common Ancestor processing using DSU"
    },
    "CP Tree: Pr√ºfer Code Encoding/Decoding": {
        "scope": "java",
        "prefix": "treeprufer",
        "body": [
            "    static class PruferCode {",
            "        // Encodes a tree (adjacency list) into a Prufer sequence of length N-2",
            "        static int[] encode(int n, List<Integer>[] adj) {",
            "            int[] degree = new int[n];",
            "            int[] parent = new int[n];",
            "            for (int i = 0; i < n; i++) degree[i] = adj[i].size();",
            "            ",
            "            dfs(n - 1, -1, adj, parent);",
            "            ",
            "            int ptr = -1;",
            "            for (int i = 0; i < n; i++) {",
            "                if (degree[i] == 1 && ptr == -1) ptr = i;",
            "            }",
            "            ",
            "            int[] code = new int[n - 2];",
            "            int leaf = ptr;",
            "            for (int i = 0; i < n - 2; i++) {",
            "                int nextNode = parent[leaf];",
            "                code[i] = nextNode;",
            "                degree[nextNode]--;",
            "                if (degree[nextNode] == 1 && nextNode < ptr) leaf = nextNode;",
            "                else {",
            "                    ptr++;",
            "                    while (ptr < n && degree[ptr] != 1) ptr++;",
            "                    leaf = ptr;",
            "                }",
            "            }",
            "            return code;",
            "        }",
            "",
            "        static void dfs(int u, int p, List<Integer>[] adj, int[] parent) {",
            "            parent[u] = p;",
            "            for (int v : adj[u]) {",
            "                if (v != p) dfs(v, u, adj, parent);",
            "            }",
            "        }",
            "",
            "        // Decodes a Prufer sequence of length N-2 into an edge list",
            "        static List<int[]> decode(int[] code) {",
            "            int n = code.length + 2;",
            "            int[] degree = new int[n];",
            "            Arrays.fill(degree, 1);",
            "            for (int node : code) degree[node]++;",
            "            ",
            "            int ptr = 0;",
            "            while (ptr < n && degree[ptr] != 1) ptr++;",
            "            int leaf = ptr;",
            "            ",
            "            List<int[]> edges = new ArrayList<>();",
            "            for (int v : code) {",
            "                edges.add(new int[]{leaf, v});",
            "                degree[v]--;",
            "                if (degree[v] == 1 && v < ptr) leaf = v;",
            "                else {",
            "                    ptr++;",
            "                    while (ptr < n && degree[ptr] != 1) ptr++;",
            "                    leaf = ptr;",
            "                }",
            "            }",
            "            edges.add(new int[]{leaf, n - 1});",
            "            return edges;",
            "        }",
            "    }",
            "    $0"
        ],
        "description": "Prefix: treeprufer -> O(N) Maps a labeled tree to a unique integer sequence (and vice-versa)"
    }
}