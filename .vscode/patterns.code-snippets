{
    "CP Pattern: Binary Search on Answer": {
        "scope": "java",
        "prefix": "patbinsearch",
        "body": [
            "    // Classic \"minimize the maximum\" or \"maximize the minimum\" template.",
            "    // Define check(mid) to return TRUE if `mid` is a valid/feasible answer.",
            "    static boolean check(long mid) {",
            "        // TODO: Implement feasibility check for value `mid`",
            "        return true;",
            "    }",
            "",
            "    static long binarySearchOnAnswer(long lo, long hi) {",
            "        long ans = lo;",
            "        while (lo <= hi) {",
            "            long mid = lo + (hi - lo) / 2;",
            "            if (check(mid)) {",
            "                ans = mid;",
            "                lo = mid + 1; // Maximizing: move right. For minimizing: hi = mid - 1;",
            "            } else {",
            "                hi = mid - 1; // Maximizing: discard right. For minimizing: lo = mid + 1;",
            "            }",
            "        }",
            "        return ans;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: patbinsearch -> Binary search on the answer space. THE most common CP meta-technique."
    },
    "CP Pattern: Binary Search on Answer (Double Precision)": {
        "scope": "java",
        "prefix": "patbinsearchdouble",
        "body": [
            "    static double binarySearchDouble(double lo, double hi) {",
            "        for (int iter = 0; iter < 200; iter++) {",
            "            double mid = (lo + hi) / 2.0;",
            "            if (check(mid)) {",
            "                lo = mid; // or hi = mid depending on direction",
            "            } else {",
            "                hi = mid;",
            "            }",
            "        }",
            "        return lo;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: patbinsearchdouble -> Binary search on real-valued answer (e.g., geometry, physics)"
    },
    "CP Pattern: Two Pointers (Opposite Ends)": {
        "scope": "java",
        "prefix": "pattwoptr",
        "body": [
            "    // Classic two-sum, container-with-most-water, pair-with-target pattern.",
            "    // Array must be SORTED for correctness.",
            "    static long[] twoPointers(long[] a, long target) {",
            "        int l = 0, r = a.length - 1;",
            "        while (l < r) {",
            "            long sum = a[l] + a[r];",
            "            if (sum == target) {",
            "                return new long[]{l, r}; // Found pair",
            "            } else if (sum < target) {",
            "                l++;",
            "            } else {",
            "                r--;",
            "            }",
            "        }",
            "        return new long[]{-1, -1}; // Not found",
            "    }",
            "    $0"
        ],
        "description": "Prefix: pattwoptr -> O(N) Two pointer technique for sorted arrays/pair problems"
    },
    "CP Pattern: Sliding Window (Variable Size)": {
        "scope": "java",
        "prefix": "patslidingwin",
        "body": [
            "    // Finds the shortest/longest subarray satisfying a condition in O(N).",
            "    static int slidingWindow(int[] a, long target) {",
            "        int n = a.length;",
            "        int left = 0;",
            "        long windowSum = 0;",
            "        int bestLen = Integer.MAX_VALUE; // or 0 for longest",
            "        ",
            "        for (int right = 0; right < n; right++) {",
            "            // Expand window: add a[right]",
            "            windowSum += a[right];",
            "            ",
            "            // Shrink window while condition is met (for shortest)",
            "            while (windowSum >= target) {",
            "                bestLen = Math.min(bestLen, right - left + 1);",
            "                windowSum -= a[left];",
            "                left++;",
            "            }",
            "        }",
            "        return bestLen == Integer.MAX_VALUE ? -1 : bestLen;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: patslidingwin -> O(N) Generic variable-size sliding window template"
    },
    "CP Pattern: Sliding Window (Fixed Size K)": {
        "scope": "java",
        "prefix": "patfixedwin",
        "body": [
            "    static long fixedSlidingWindow(long[] a, int k) {",
            "        int n = a.length;",
            "        long windowSum = 0, best = Long.MIN_VALUE;",
            "        ",
            "        for (int i = 0; i < n; i++) {",
            "            windowSum += a[i];",
            "            if (i >= k) windowSum -= a[i - k];",
            "            if (i >= k - 1) best = Math.max(best, windowSum);",
            "        }",
            "        return best;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: patfixedwin -> O(N) Fixed-size window with running aggregate"
    },
    "CP Pattern: Sliding Window (HashMap Distinct Count)": {
        "scope": "java",
        "prefix": "patslidingmap",
        "body": [
            "    // Finds longest subarray with at most K distinct elements.",
            "    static int longestWithKDistinct(int[] a, int k) {",
            "        int n = a.length;",
            "        Map<Integer, Integer> freq = new HashMap<>();",
            "        int left = 0, best = 0;",
            "        ",
            "        for (int right = 0; right < n; right++) {",
            "            freq.merge(a[right], 1, Integer::sum);",
            "            ",
            "            while (freq.size() > k) {",
            "                int cnt = freq.merge(a[left], -1, Integer::sum);",
            "                if (cnt == 0) freq.remove(a[left]);",
            "                left++;",
            "            }",
            "            best = Math.max(best, right - left + 1);",
            "        }",
            "        return best;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: patslidingmap -> O(N) Sliding window with HashMap for distinct element constraints"
    },
    "CP Pattern: Backtracking Template": {
        "scope": "java",
        "prefix": "patbacktrack",
        "body": [
            "    static List<List<Integer>> results = new ArrayList<>();",
            "",
            "    static void backtrack(int[] a, List<Integer> current, boolean[] used) {",
            "        // Base case: solution found",
            "        if (current.size() == a.length) {",
            "            results.add(new ArrayList<>(current)); // MUST copy",
            "            return;",
            "        }",
            "        ",
            "        for (int i = 0; i < a.length; i++) {",
            "            if (used[i]) continue;",
            "            // Pruning: skip duplicates in sorted array",
            "            // if (i > 0 && a[i] == a[i-1] && !used[i-1]) continue;",
            "            ",
            "            used[i] = true;",
            "            current.add(a[i]);",
            "            ",
            "            backtrack(a, current, used);",
            "            ",
            "            current.remove(current.size() - 1);",
            "            used[i] = false;",
            "        }",
            "    }",
            "    $0"
        ],
        "description": "Prefix: patbacktrack -> Classic backtracking with pruning (permutations, N-Queens, subsets)"
    },
    "CP Pattern: Subsets Generation (Iterative Bitmask)": {
        "scope": "java",
        "prefix": "patsubsets",
        "body": [
            "    static List<List<Integer>> generateSubsets(int[] a) {",
            "        int n = a.length;",
            "        List<List<Integer>> subsets = new ArrayList<>();",
            "        for (int mask = 0; mask < (1 << n); mask++) {",
            "            List<Integer> subset = new ArrayList<>();",
            "            for (int i = 0; i < n; i++) {",
            "                if ((mask & (1 << i)) != 0) subset.add(a[i]);",
            "            }",
            "            subsets.add(subset);",
            "        }",
            "        return subsets;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: patsubsets -> O(2^N * N) Generates all subsets iteratively via bitmask"
    },
    "CP Pattern: Custom Primitive Sort (Avoid TLE)": {
        "scope": "java",
        "prefix": "patsort",
        "body": [
            "    // Java's Arrays.sort(int[]) uses DUAL-PIVOT QUICKSORT which is O(N^2) worst case.",
            "    // Shuffle before sorting, OR use Arrays.sort(Integer[]), OR this custom merge sort.",
            "    static void shuffleAndSort(int[] a) {",
            "        Random rng = new Random();",
            "        for (int i = a.length - 1; i > 0; i--) {",
            "            int j = rng.nextInt(i + 1);",
            "            int tmp = a[i]; a[i] = a[j]; a[j] = tmp;",
            "        }",
            "        Arrays.sort(a);",
            "    }",
            "    ",
            "    static void shuffleAndSort(long[] a) {",
            "        Random rng = new Random();",
            "        for (int i = a.length - 1; i > 0; i--) {",
            "            int j = rng.nextInt(i + 1);",
            "            long tmp = a[i]; a[i] = a[j]; a[j] = tmp;",
            "        }",
            "        Arrays.sort(a);",
            "    }",
            "    $0"
        ],
        "description": "Prefix: patsort -> Prevents O(N^2) worst case by shuffling before Arrays.sort"
    },
    "CP Pattern: Custom 2D Sort (Sort by Column)": {
        "scope": "java",
        "prefix": "patsort2d",
        "body": [
            "    // Sort 2D array by first column ascending, then by second column descending",
            "    // Arrays.sort(arr, (a, b) -> a[0] != b[0] ? Integer.compare(a[0], b[0]) : Integer.compare(b[1], a[1]));",
            "    ",
            "    // Sort intervals by end time (greedy scheduling)",
            "    // Arrays.sort(intervals, Comparator.comparingInt(a -> a[1]));",
            "    ",
            "    // Sort events: by time, then by type",
            "    // Arrays.sort(events, (a, b) -> a[0] != b[0] ? Long.compare(a[0], b[0]) : Integer.compare(a[1], b[1]));",
            "    $0"
        ],
        "description": "Prefix: patsort2d -> Common 2D array sort comparators for intervals/events"
    },
    "CP Pattern: Random Utilities": {
        "scope": "java",
        "prefix": "patrandom",
        "body": [
            "    static Random rng = new Random(System.nanoTime());",
            "    ",
            "    static int randInt(int lo, int hi) {",
            "        return lo + rng.nextInt(hi - lo + 1);",
            "    }",
            "    ",
            "    static long randLong(long lo, long hi) {",
            "        return lo + (long) (rng.nextDouble() * (hi - lo + 1));",
            "    }",
            "    ",
            "    static void shuffle(int[] a) {",
            "        for (int i = a.length - 1; i > 0; i--) {",
            "            int j = rng.nextInt(i + 1);",
            "            int tmp = a[i]; a[i] = a[j]; a[j] = tmp;",
            "        }",
            "    }",
            "    $0"
        ],
        "description": "Prefix: patrandom -> Seeded random utils for hashing, shuffling, and randomized algorithms"
    },
    "CP Pattern: Coordinate Compression (Generic)": {
        "scope": "java",
        "prefix": "patcompress",
        "body": [
            "    // Maps large values to [0, uniqueCount-1] using a sorted unique array + TreeMap.",
            "    static Map<Long, Integer> compress(long[] values) {",
            "        TreeSet<Long> set = new TreeSet<>();",
            "        for (long v : values) set.add(v);",
            "        Map<Long, Integer> map = new HashMap<>();",
            "        int idx = 0;",
            "        for (long v : set) map.put(v, idx++);",
            "        return map;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: patcompress -> Generic coordinate compression returning value->index map"
    },
    "CP Pattern: Interval Merge": {
        "scope": "java",
        "prefix": "patmergeintervals",
        "body": [
            "    // Merges overlapping intervals. Input: array of [start, end].",
            "    static List<int[]> mergeIntervals(int[][] intervals) {",
            "        Arrays.sort(intervals, Comparator.comparingInt(a -> a[0]));",
            "        List<int[]> merged = new ArrayList<>();",
            "        ",
            "        for (int[] interval : intervals) {",
            "            if (merged.isEmpty() || merged.get(merged.size() - 1)[1] < interval[0]) {",
            "                merged.add(interval);",
            "            } else {",
            "                merged.get(merged.size() - 1)[1] = Math.max(merged.get(merged.size() - 1)[1], interval[1]);",
            "            }",
            "        }",
            "        return merged;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: patmergeintervals -> O(N log N) Merges overlapping intervals into non-overlapping set"
    },
    "CP Pattern: Offline Query Sorting": {
        "scope": "java",
        "prefix": "patoffline",
        "body": [
            "    // Process queries offline by sorting them optimally (e.g., by right endpoint).",
            "    // Useful when online processing per query is O(N) but sorted processing is O(1) amortized.",
            "    static long[] processOfflineQueries(int[] a, int[][] queries) {",
            "        int n = a.length, q = queries.length;",
            "        Integer[] order = new Integer[q];",
            "        for (int i = 0; i < q; i++) order[i] = i;",
            "        Arrays.sort(order, Comparator.comparingInt(i -> queries[i][1])); // Sort by right endpoint",
            "        ",
            "        long[] answers = new long[q];",
            "        int ptr = 0; // Current position in the array",
            "        ",
            "        for (int idx : order) {",
            "            int l = queries[idx][0], r = queries[idx][1];",
            "            while (ptr <= r) {",
            "                // Process a[ptr] into your data structure",
            "                ptr++;",
            "            }",
            "            // Answer query using current state",
            "            // answers[idx] = ...;",
            "        }",
            "        return answers;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: patoffline -> Generic offline query processing template"
    },
    "CP Pattern: Fast HashMap for int keys": {
        "scope": "java",
        "prefix": "patfastmap",
        "body": [
            "    // Avoids Integer autoboxing overhead of HashMap<Integer, Integer>.",
            "    // For keys in range [0, maxKey), use a simple array instead:",
            "    // int[] map = new int[maxKey]; Arrays.fill(map, -1);",
            "    ",
            "    // For general sparse keys, use HashMap with good initial capacity:",
            "    // HashMap<Long, Integer> map = new HashMap<>(expectedSize * 4 / 3 + 1);",
            "    // This prevents rehashing and improves performance significantly.",
            "    $0"
        ],
        "description": "Prefix: patfastmap -> Performance tips for HashMap usage in CP"
    },
    "CP Pattern: Multiple Test Cases Loop": {
        "scope": "java",
        "prefix": "pattestcases",
        "body": [
            "        int T = fs.nextInt();",
            "        while (T-- > 0) {",
            "            solve();",
            "        }",
            "    }",
            "",
            "    static void solve() {",
            "        $0",
            "    "
        ],
        "description": "Prefix: pattestcases -> Standard multi-test-case loop structure"
    },
    "CP Pattern: Ternary Search on Array (Discrete Unimodal)": {
        "scope": "java",
        "prefix": "patternarydiscrete",
        "body": [
            "    // Finds peak index in a discrete unimodal function (e.g., bitonic array).",
            "    static int ternarySearchDiscrete(long[] a) {",
            "        int lo = 0, hi = a.length - 1;",
            "        while (hi - lo > 2) {",
            "            int m1 = lo + (hi - lo) / 3;",
            "            int m2 = hi - (hi - lo) / 3;",
            "            if (a[m1] < a[m2]) lo = m1 + 1;",
            "            else hi = m2 - 1;",
            "        }",
            "        int bestIdx = lo;",
            "        for (int i = lo; i <= hi; i++) {",
            "            if (a[i] > a[bestIdx]) bestIdx = i;",
            "        }",
            "        return bestIdx;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: patternarydiscrete -> O(log N) Finds peak in discrete unimodal data"
    },
    "CP Pattern: Multi-Source Dijkstra (Graph)": {
        "scope": "java",
        "prefix": "patmultidijkstra",
        "body": [
            "    static long[] multiSourceDijkstra(int n, List<int[]>[] adj, List<Integer> sources) {",
            "        long[] dist = new long[n];",
            "        Arrays.fill(dist, Long.MAX_VALUE);",
            "        PriorityQueue<long[]> pq = new PriorityQueue<>(Comparator.comparingLong(a -> a[1]));",
            "        ",
            "        for (int s : sources) {",
            "            dist[s] = 0;",
            "            pq.add(new long[]{s, 0});",
            "        }",
            "        ",
            "        while (!pq.isEmpty()) {",
            "            long[] curr = pq.poll();",
            "            int u = (int) curr[0]; long d = curr[1];",
            "            if (d > dist[u]) continue;",
            "            for (int[] edge : adj[u]) {",
            "                int v = edge[0]; long w = edge[1];",
            "                if (dist[u] + w < dist[v]) {",
            "                    dist[v] = dist[u] + w;",
            "                    pq.add(new long[]{v, dist[v]});",
            "                }",
            "            }",
            "        }",
            "        return dist;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: patmultidijkstra -> O(E log V) Multi-source shortest path on weighted graphs"
    },
    "CP Pattern: Common Java Collections Oneliners": {
        "scope": "java",
        "prefix": "patcollections",
        "body": [
            "    // TreeMap as Sorted Multiset (Frequency Map with O(log N) floor/ceiling)",
            "    TreeMap<Integer, Integer> multiset = new TreeMap<>();",
            "    // Add:    multiset.merge(x, 1, Integer::sum);",
            "    // Remove: { int c = multiset.merge(x, -1, Integer::sum); if (c == 0) multiset.remove(x); }",
            "    // Min:    multiset.firstKey();",
            "    // Max:    multiset.lastKey();",
            "    // Floor:  multiset.floorKey(x);",
            "    // Ceil:   multiset.ceilingKey(x);",
            "    ",
            "    // TreeSet as Ordered Set",
            "    TreeSet<Integer> orderedSet = new TreeSet<>();",
            "    // orderedSet.lower(x)   -> strictly less than x",
            "    // orderedSet.higher(x)  -> strictly greater than x",
            "    // orderedSet.floor(x)   -> <= x",
            "    // orderedSet.ceiling(x) -> >= x",
            "    $0"
        ],
        "description": "Prefix: patcollections -> TreeMap/TreeSet snippets for sorted multiset and ordered set operations"
    },
    "CP Pattern: Contribution Technique": {
        "scope": "java",
        "prefix": "patcontrib",
        "body": [
            "    // Instead of iterating over all subarrays O(N^2), count the CONTRIBUTION of each element.",
            "    // \"How many subarrays does a[i] appear in?\" -> (i + 1) * (n - i)",
            "    // \"Sum of all subarray sums\" = sum over i of a[i] * (i + 1) * (n - i)",
            "    static long sumOfAllSubarraySums(long[] a) {",
            "        int n = a.length;",
            "        long total = 0;",
            "        for (int i = 0; i < n; i++) {",
            "            total += a[i] * (long)(i + 1) * (n - i);",
            "        }",
            "        return total;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: patcontrib -> O(N) Contribution counting technique to avoid O(N^2) enumeration"
    },
    "CP Pattern: Frequency Array + Cycle Detection (Functional Graph)": {
        "scope": "java",
        "prefix": "patfuncgraph",
        "body": [
            "    // In a functional graph, each node has exactly one outgoing edge.",
            "    // Finds cycle length and entry point.",
            "    static int[] findCycle(int[] next, int start) {",
            "        int slow = start, fast = start;",
            "        do {",
            "            slow = next[slow];",
            "            fast = next[next[fast]];",
            "        } while (slow != fast);",
            "        ",
            "        // Find cycle entry",
            "        int entry = start;",
            "        while (entry != slow) {",
            "            entry = next[entry];",
            "            slow = next[slow];",
            "        }",
            "        ",
            "        // Find cycle length",
            "        int len = 1;",
            "        int curr = next[entry];",
            "        while (curr != entry) {",
            "            curr = next[curr];",
            "            len++;",
            "        }",
            "        return new int[]{entry, len};",
            "    }",
            "    $0"
        ],
        "description": "Prefix: patfuncgraph -> O(N) Floyd's algorithm on functional graphs (successor graphs)"
    },
    "CP Pattern: Grid Direction Arrays (4/8 dirs)": {
        "scope": "java",
        "prefix": "patdirs",
        "body": [
            "    // 4-directional (Up, Down, Left, Right)",
            "    static final int[] dr4 = {-1, 1, 0, 0};",
            "    static final int[] dc4 = {0, 0, -1, 1};",
            "    ",
            "    // 8-directional (includes diagonals)",
            "    static final int[] dr8 = {-1, -1, -1, 0, 0, 1, 1, 1};",
            "    static final int[] dc8 = {-1, 0, 1, -1, 1, -1, 0, 1};",
            "    ",
            "    // Knight moves",
            "    static final int[] dkr = {-2, -2, -1, -1, 1, 1, 2, 2};",
            "    static final int[] dkc = {-1, 1, -2, 2, -2, 2, -1, 1};",
            "    ",
            "    static boolean inBounds(int r, int c, int R, int C) {",
            "        return r >= 0 && r < R && c >= 0 && c < C;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: patdirs -> Direction arrays for 4-dir, 8-dir, and knight moves + bounds check"
    },
    "CP Pattern: Flood Fill (DFS on Grid)": {
        "scope": "java",
        "prefix": "patflood",
        "body": [
            "    static void floodFill(char[][] grid, int r, int c, char target, char replacement) {",
            "        int R = grid.length, C = grid[0].length;",
            "        if (r < 0 || r >= R || c < 0 || c >= C) return;",
            "        if (grid[r][c] != target) return;",
            "        ",
            "        grid[r][c] = replacement;",
            "        floodFill(grid, r - 1, c, target, replacement);",
            "        floodFill(grid, r + 1, c, target, replacement);",
            "        floodFill(grid, r, c - 1, target, replacement);",
            "        floodFill(grid, r, c + 1, target, replacement);",
            "    }",
            "    ",
            "    // Iterative version for large grids (no StackOverflow)",
            "    static void floodFillIterative(char[][] grid, int sr, int sc, char target, char replacement) {",
            "        if (grid[sr][sc] != target) return;",
            "        int R = grid.length, C = grid[0].length;",
            "        int[] dr = {-1, 1, 0, 0}, dc = {0, 0, -1, 1};",
            "        Deque<Integer> stack = new ArrayDeque<>();",
            "        grid[sr][sc] = replacement;",
            "        stack.push(sr * C + sc);",
            "        while (!stack.isEmpty()) {",
            "            int pos = stack.pop();",
            "            int cr = pos / C, cc = pos % C;",
            "            for (int i = 0; i < 4; i++) {",
            "                int nr = cr + dr[i], nc = cc + dc[i];",
            "                if (nr >= 0 && nr < R && nc >= 0 && nc < C && grid[nr][nc] == target) {",
            "                    grid[nr][nc] = replacement;",
            "                    stack.push(nr * C + nc);",
            "                }",
            "            }",
            "        }",
            "    }",
            "    $0"
        ],
        "description": "Prefix: patflood -> O(R*C) Recursive + iterative flood fill for grid connected components"
    },
    "CP Pattern: Grid DFS Component Count": {
        "scope": "java",
        "prefix": "patgridcomponents",
        "body": [
            "    static int countIslands(char[][] grid) {",
            "        int R = grid.length, C = grid[0].length;",
            "        int count = 0;",
            "        for (int i = 0; i < R; i++) {",
            "            for (int j = 0; j < C; j++) {",
            "                if (grid[i][j] == '1') {",
            "                    count++;",
            "                    floodFillIterative(grid, i, j, '1', '0');",
            "                }",
            "            }",
            "        }",
            "        return count;",
            "    }",
            "    $0"
        ],
        "description": "Prefix: patgridcomponents -> O(R*C) Count connected components (islands) in a grid"
    },
    "CP Pattern: Increase Stack Size (Thread Trick)": {
        "scope": "java",
        "prefix": "patstacksize",
        "body": [
            "    // Java default stack is ~512KB. Deep recursion (N > 10^4) causes StackOverflowError.",
            "    // Use this to increase to 256MB.",
            "    public static void main(String[] args) {",
            "        new Thread(null, () -> {",
            "            ${1:// Your actual main logic here}",
            "            $0",
            "        }, \"main\", 1 << 28).start();",
            "    }"
        ],
        "description": "Prefix: patstacksize -> Increases JVM stack to 256MB for deep recursion"
    },
    "CP Pattern: DSU with Rollback (Offline)": {
        "scope": "java",
        "prefix": "patdsurollback",
        "body": [
            "    static class DSURollback {",
            "        int[] parent, sz;",
            "        Deque<int[]> history; // stores {node, oldParent, oldSize}",
            "        int components;",
            "        ",
            "        DSURollback(int n) {",
            "            parent = new int[n]; sz = new int[n];",
            "            history = new ArrayDeque<>();",
            "            components = n;",
            "            for (int i = 0; i < n; i++) { parent[i] = i; sz[i] = 1; }",
            "        }",
            "        ",
            "        int find(int i) {",
            "            while (parent[i] != i) i = parent[i]; // NO path compression (to support rollback)",
            "            return i;",
            "        }",
            "        ",
            "        boolean union(int a, int b) {",
            "            a = find(a); b = find(b);",
            "            if (a == b) return false;",
            "            if (sz[a] < sz[b]) { int t = a; a = b; b = t; }",
            "            history.push(new int[]{b, parent[b], sz[a]});",
            "            parent[b] = a;",
            "            sz[a] += sz[b];",
            "            components--;",
            "            return true;",
            "        }",
            "        ",
            "        void rollback() {",
            "            int[] snap = history.pop();",
            "            int node = snap[0], oldParent = snap[1], oldSize = snap[2];",
            "            sz[parent[node]] = oldSize;",
            "            parent[node] = oldParent;",
            "            components++;",
            "        }",
            "        ",
            "        int savepoint() { return history.size(); }",
            "        void rollbackTo(int sp) { while (history.size() > sp) rollback(); }",
            "    }",
            "    $0"
        ],
        "description": "Prefix: patdsurollback -> DSU with undo capability for offline divide-and-conquer on edges"
    }
}